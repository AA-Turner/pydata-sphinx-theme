<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Intro to Data Structures &#8212; pandas 0.25.0 documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/pandas_styles.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/carousel.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/pandas_logo.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.25.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../install.html">Install</a></li>
                <li><a href="../docs.html">Documentation</a></li>
                <li><a href="../community.html">Community</a></li>
            
            
              
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">Intro to Data Structures</a><ul>
<li><a class="reference internal" href="#series">Series</a></li>
<li><a class="reference internal" href="#dataframe">DataFrame</a></li>
<li><a class="reference internal" href="#panel">Panel</a></li>
<li><a class="reference internal" href="#deprecate-panel">Deprecate Panel</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    <div class="col-md-9 content">
      
  <div class="section" id="intro-to-data-structures">
<h1>Intro to Data Structures<a class="headerlink" href="#intro-to-data-structures" title="Permalink to this headline">¶</a></h1>
<p>We’ll start with a quick, non-comprehensive overview of the fundamental data
structures in pandas to get you started. The fundamental behavior about data
types, indexing, and axis labeling / alignment apply across all of the
objects. To get started, import NumPy and load pandas into your namespace:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="gp">In [2]: </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
</pre></div>
</div>
<p>Here is a basic tenet to keep in mind: <strong>data alignment is intrinsic</strong>. The link
between labels and data will not be broken unless done so explicitly by you.</p>
<p>We’ll give a brief intro to the data structures, then consider all of the broad
categories of functionality and methods in separate sections.</p>
<div class="section" id="series">
<span id="basics-series"></span><h2>Series<a class="headerlink" href="#series" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="../generated/pandas.Series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> is a one-dimensional labeled array capable of holding any data
type (integers, strings, floating point numbers, Python objects, etc.). The axis
labels are collectively referred to as the <strong>index</strong>. The basic method to create a Series is to call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">data</span></code> can be many different things:</p>
<ul class="simple">
<li><p>a Python dict</p></li>
<li><p>an ndarray</p></li>
<li><p>a scalar value (like 5)</p></li>
</ul>
<p>The passed <strong>index</strong> is a list of axis labels. Thus, this separates into a few
cases depending on what <strong>data is</strong>:</p>
<p><strong>From ndarray</strong></p>
<p>If <code class="docutils literal notranslate"><span class="pre">data</span></code> is an ndarray, <strong>index</strong> must be the same length as <strong>data</strong>. If no
index is passed, one will be created having values <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">...,</span> <span class="pre">len(data)</span> <span class="pre">-</span> <span class="pre">1]</span></code>.</p>
<pre class="literal-block">In [3]: s = pd.Series(np.random.randn(5), index=['a', 'b', 'c', 'd', 'e'])

In [4]: s
Out[4]: 
a    0.469112
b   -0.282863
c   -1.509059
d   -1.135632
e    1.212112
dtype: float64

In [5]: s.index
Out[5]: Index(['a', 'b', 'c', 'd', 'e'], dtype='object')

In [6]: pd.Series(np.random.randn(5))
Out[6]: 
0   -0.173215
1    0.119209
2   -1.044236
3   -0.861849
4   -2.104569
dtype: float64</pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>pandas supports non-unique index values. If an operation
that does not support duplicate index values is attempted, an exception
will be raised at that time. The reason for being lazy is nearly all performance-based
(there are many instances in computations, like parts of GroupBy, where the index
is not used).</p>
</div>
<p><strong>From dict</strong></p>
<p>Series can be instantiated from dicts:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [7]: </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>

<span class="gp">In [8]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gh">Out[8]: </span><span class="go"></span>
<span class="go">b    1</span>
<span class="go">a    0</span>
<span class="go">c    2</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When the data is a dict, and an index is not passed, the <code class="docutils literal notranslate"><span class="pre">Series</span></code> index
will be ordered by the dict’s insertion order, if you’re using Python
version &gt;= 3.6 and Pandas version &gt;= 0.23.</p>
<p>If you’re using Python &lt; 3.6 or Pandas &lt; 0.23, and an index is not passed,
the <code class="docutils literal notranslate"><span class="pre">Series</span></code> index will be the lexically ordered list of dict keys.</p>
</div>
<p>In the example above, if you were on a Python version lower than 3.6 or a
Pandas version lower than 0.23, the <code class="docutils literal notranslate"><span class="pre">Series</span></code> would be ordered by the lexical
order of the dict keys (i.e. <code class="docutils literal notranslate"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c']</span></code> rather than <code class="docutils literal notranslate"><span class="pre">['b',</span> <span class="pre">'a',</span> <span class="pre">'c']</span></code>).</p>
<p>If an index is passed, the values in data corresponding to the labels in the
index will be pulled out.</p>
<pre class="literal-block">In [9]: d = {'a': 0., 'b': 1., 'c': 2.}

In [10]: pd.Series(d)
Out[10]: 
a    0.0
b    1.0
c    2.0
dtype: float64

In [11]: pd.Series(d, index=['b', 'c', 'd', 'a'])
Out[11]: 
b    1.0
c    2.0
d    NaN
a    0.0
dtype: float64</pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>NaN (not a number) is the standard missing data marker used in pandas.</p>
</div>
<p><strong>From scalar value</strong></p>
<p>If <code class="docutils literal notranslate"><span class="pre">data</span></code> is a scalar value, an index must be
provided. The value will be repeated to match the length of <strong>index</strong>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [12]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="mf">5.</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>
<span class="gh">Out[12]: </span><span class="go"></span>
<span class="go">a    5.0</span>
<span class="go">b    5.0</span>
<span class="go">c    5.0</span>
<span class="go">d    5.0</span>
<span class="go">e    5.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<div class="section" id="series-is-ndarray-like">
<h3>Series is ndarray-like<a class="headerlink" href="#series-is-ndarray-like" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Series</span></code> acts very similarly to a <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>, and is a valid argument to most NumPy functions.
However, operations such as slicing will also slice the index.</p>
<pre class="literal-block">In [13]: s[0]
Out[13]: 0.4691122999071863

In [14]: s[:3]
Out[14]: 
a    0.469112
b   -0.282863
c   -1.509059
dtype: float64

In [15]: s[s &gt; s.median()]
Out[15]: 
a    0.469112
e    1.212112
dtype: float64

In [16]: s[[4, 3, 1]]
Out[16]: 
e    1.212112
d   -1.135632
b   -0.282863
dtype: float64

In [17]: np.exp(s)
Out[17]: 
a    1.598575
b    0.753623
c    0.221118
d    0.321219
e    3.360575
dtype: float64</pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We will address array-based indexing like <code class="docutils literal notranslate"><span class="pre">s[[4,</span> <span class="pre">3,</span> <span class="pre">1]]</span></code>
in <a class="reference internal" href="../user_guide/indexing.html#indexing"><span class="std std-ref">section</span></a>.</p>
</div>
<p>Like a NumPy array, a pandas Series has a <a class="reference internal" href="../generated/pandas.Series.dtype.html#pandas.Series.dtype" title="pandas.Series.dtype"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dtype</span></code></a>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [18]: </span><span class="n">s</span><span class="o">.</span><span class="n">dtype</span>
<span class="gh">Out[18]: </span><span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
<p>This is often a NumPy dtype. However, pandas and 3rd-party libraries
extend NumPy’s type system in a few places, in which case the dtype would
be a <a class="reference internal" href="../generated/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype" title="pandas.api.extensions.ExtensionDtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExtensionDtype</span></code></a>. Some examples within
pandas are <span class="xref std std-ref">categorical</span> and <span class="xref std std-ref">integer_na</span>. See <a class="reference internal" href="basics.html#basics-dtypes"><span class="std std-ref">dtypes</span></a>
for more.</p>
<p>If you need the actual array backing a <code class="docutils literal notranslate"><span class="pre">Series</span></code>, use <a class="reference internal" href="../generated/pandas.Series.array.html#pandas.Series.array" title="pandas.Series.array"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Series.array</span></code></a>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [19]: </span><span class="n">s</span><span class="o">.</span><span class="n">array</span>
<span class="gh">Out[19]: </span><span class="go"></span>
<span class="go">&lt;PandasArray&gt;</span>
<span class="go">[ 0.4691122999071863, -0.2828633443286633, -1.5090585031735124,</span>
<span class="go"> -1.1356323710171934,  1.2121120250208506]</span>
<span class="go">Length: 5, dtype: float64</span>
</pre></div>
</div>
<p>Again, this is often a NumPy array, but may instead be a
<a class="reference internal" href="../generated/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray" title="pandas.api.extensions.ExtensionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExtensionArray</span></code></a>. See <a class="reference internal" href="basics.html#basics-dtypes"><span class="std std-ref">dtypes</span></a> for more.
Accessing the array can be useful when you need to do some operation without the
index (to disable <a class="reference internal" href="#dsintro-alignment"><span class="std std-ref">automatic alignment</span></a>, for example).</p>
<p>While Series is ndarray-like, if you need an <em>actual</em> ndarray, then use
<a class="reference internal" href="../generated/pandas.Series.to_numpy.html#pandas.Series.to_numpy" title="pandas.Series.to_numpy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Series.to_numpy()</span></code></a>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [20]: </span><span class="n">s</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
<span class="gh">Out[20]: </span><span class="go">array([ 0.4691, -0.2829, -1.5091, -1.1356,  1.2121])</span>
</pre></div>
</div>
<p>Even if the Series is backed by a <a class="reference internal" href="../generated/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray" title="pandas.api.extensions.ExtensionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExtensionArray</span></code></a>,
<a class="reference internal" href="../generated/pandas.Series.to_numpy.html#pandas.Series.to_numpy" title="pandas.Series.to_numpy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Series.to_numpy()</span></code></a> will return a NumPy ndarray.</p>
</div>
<div class="section" id="series-is-dict-like">
<h3>Series is dict-like<a class="headerlink" href="#series-is-dict-like" title="Permalink to this headline">¶</a></h3>
<p>A Series is like a fixed-size dict in that you can get and set values by index
label:</p>
<pre class="literal-block">In [21]: s['a']
Out[21]: 0.4691122999071863

In [22]: s['e'] = 12.

In [23]: s
Out[23]: 
a     0.469112
b    -0.282863
c    -1.509059
d    -1.135632
e    12.000000
dtype: float64

In [24]: 'e' in s
Out[24]: True

In [25]: 'f' in s
Out[25]: False</pre>
<p>If a label is not contained, an exception is raised:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span>
<span class="go">KeyError: &#39;f&#39;</span>
</pre></div>
</div>
<p>Using the <code class="docutils literal notranslate"><span class="pre">get</span></code> method, a missing label will return None or specified default:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [26]: </span><span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>

<span class="gp">In [27]: </span><span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
<span class="gh">Out[27]: </span><span class="go">nan</span>
</pre></div>
</div>
<p>See also the <a class="reference internal" href="../user_guide/indexing.html#indexing-attribute-access"><span class="std std-ref">section on attribute access</span></a>.</p>
</div>
<div class="section" id="vectorized-operations-and-label-alignment-with-series">
<h3>Vectorized operations and label alignment with Series<a class="headerlink" href="#vectorized-operations-and-label-alignment-with-series" title="Permalink to this headline">¶</a></h3>
<p>When working with raw NumPy arrays, looping through value-by-value is usually
not necessary. The same is true when working with Series in pandas.
Series can also be passed into most NumPy methods expecting an ndarray.</p>
<pre class="literal-block">In [28]: s + s
Out[28]: 
a     0.938225
b    -0.565727
c    -3.018117
d    -2.271265
e    24.000000
dtype: float64

In [29]: s * 2
Out[29]: 
a     0.938225
b    -0.565727
c    -3.018117
d    -2.271265
e    24.000000
dtype: float64

In [30]: np.exp(s)
Out[30]: 
a         1.598575
b         0.753623
c         0.221118
d         0.321219
e    162754.791419
dtype: float64</pre>
<p>A key difference between Series and ndarray is that operations between Series
automatically align the data based on label. Thus, you can write computations
without giving consideration to whether the Series involved have the same
labels.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [31]: </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gh">Out[31]: </span><span class="go"></span>
<span class="go">a         NaN</span>
<span class="go">b   -0.565727</span>
<span class="go">c   -3.018117</span>
<span class="go">d   -2.271265</span>
<span class="go">e         NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>The result of an operation between unaligned Series will have the <strong>union</strong> of
the indexes involved. If a label is not found in one Series or the other, the
result will be marked as missing <code class="docutils literal notranslate"><span class="pre">NaN</span></code>. Being able to write code without doing
any explicit data alignment grants immense freedom and flexibility in
interactive data analysis and research. The integrated data alignment features
of the pandas data structures set pandas apart from the majority of related
tools for working with labeled data.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general, we chose to make the default result of operations between
differently indexed objects yield the <strong>union</strong> of the indexes in order to
avoid loss of information. Having an index label, though the data is
missing, is typically important information as part of a computation. You
of course have the option of dropping labels with missing data via the
<strong>dropna</strong> function.</p>
</div>
</div>
<div class="section" id="name-attribute">
<h3>Name attribute<a class="headerlink" href="#name-attribute" title="Permalink to this headline">¶</a></h3>
<p id="dsintro-name-attribute">Series can also have a <code class="docutils literal notranslate"><span class="pre">name</span></code> attribute:</p>
<pre class="literal-block">In [32]: s = pd.Series(np.random.randn(5), name='something')

In [33]: s
Out[33]: 
0   -0.494929
1    1.071804
2    0.721555
3   -0.706771
4   -1.039575
Name: something, dtype: float64

In [34]: s.name
Out[34]: 'something'</pre>
<p>The Series <code class="docutils literal notranslate"><span class="pre">name</span></code> will be assigned automatically in many cases, in particular
when taking 1D slices of DataFrame as you will see below.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.0.</span></p>
</div>
<p>You can rename a Series with the <a class="reference internal" href="../generated/pandas.Series.rename.html#pandas.Series.rename" title="pandas.Series.rename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pandas.Series.rename()</span></code></a> method.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [35]: </span><span class="n">s2</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;different&quot;</span><span class="p">)</span>

<span class="gp">In [36]: </span><span class="n">s2</span><span class="o">.</span><span class="n">name</span>
<span class="gh">Out[36]: </span><span class="go">&#39;different&#39;</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">s2</span></code> refer to different objects.</p>
</div>
</div>
<div class="section" id="dataframe">
<span id="basics-dataframe"></span><h2>DataFrame<a class="headerlink" href="#dataframe" title="Permalink to this headline">¶</a></h2>
<p><strong>DataFrame</strong> is a 2-dimensional labeled data structure with columns of
potentially different types. You can think of it like a spreadsheet or SQL
table, or a dict of Series objects. It is generally the most commonly used
pandas object. Like Series, DataFrame accepts many different kinds of input:</p>
<ul class="simple">
<li><p>Dict of 1D ndarrays, lists, dicts, or Series</p></li>
<li><p>2-D numpy.ndarray</p></li>
<li><p><a class="reference external" href="https://docs.scipy.org/doc/numpy/user/basics.rec.html">Structured or record</a> ndarray</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">Series</span></code></p></li>
<li><p>Another <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code></p></li>
</ul>
<p>Along with the data, you can optionally pass <strong>index</strong> (row labels) and
<strong>columns</strong> (column labels) arguments. If you pass an index and / or columns,
you are guaranteeing the index and / or columns of the resulting
DataFrame. Thus, a dict of Series plus a specific index will discard all data
not matching up to the passed index.</p>
<p>If axis labels are not passed, they will be constructed from the input data
based on common sense rules.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When the data is a dict, and <code class="docutils literal notranslate"><span class="pre">columns</span></code> is not specified, the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>
columns will be ordered by the dict’s insertion order, if you are using
Python version &gt;= 3.6 and Pandas &gt;= 0.23.</p>
<p>If you are using Python &lt; 3.6 or Pandas &lt; 0.23, and <code class="docutils literal notranslate"><span class="pre">columns</span></code> is not
specified, the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> columns will be the lexically ordered list of dict
keys.</p>
</div>
<div class="section" id="from-dict-of-series-or-dicts">
<h3>From dict of Series or dicts<a class="headerlink" href="#from-dict-of-series-or-dicts" title="Permalink to this headline">¶</a></h3>
<p>The resulting <strong>index</strong> will be the <strong>union</strong> of the indexes of the various
Series. If there are any nested dicts, these will first be converted to
Series. If no columns are passed, the columns will be the ordered list of dict
keys.</p>
<pre class="literal-block">In [37]: d = {'one': pd.Series([1., 2., 3.], index=['a', 'b', 'c']),
   ....:      'two': pd.Series([1., 2., 3., 4.], index=['a', 'b', 'c', 'd'])}
   ....: 

In [38]: df = pd.DataFrame(d)

In [39]: df
Out[39]: 
   one  two
a  1.0  1.0
b  2.0  2.0
c  3.0  3.0
d  NaN  4.0

In [40]: pd.DataFrame(d, index=['d', 'b', 'a'])
Out[40]: 
   one  two
d  NaN  4.0
b  2.0  2.0
a  1.0  1.0

In [41]: pd.DataFrame(d, index=['d', 'b', 'a'], columns=['two', 'three'])
Out[41]: 
   two three
d  4.0   NaN
b  2.0   NaN
a  1.0   NaN</pre>
<p>The row and column labels can be accessed respectively by accessing the
<strong>index</strong> and <strong>columns</strong> attributes:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When a particular set of columns is passed along with a dict of data, the
passed columns override the keys in the dict.</p>
</div>
<pre class="literal-block">In [42]: df.index
Out[42]: Index(['a', 'b', 'c', 'd'], dtype='object')

In [43]: df.columns
Out[43]: Index(['one', 'two'], dtype='object')</pre>
</div>
<div class="section" id="from-dict-of-ndarrays-lists">
<h3>From dict of ndarrays / lists<a class="headerlink" href="#from-dict-of-ndarrays-lists" title="Permalink to this headline">¶</a></h3>
<p>The ndarrays must all be the same length. If an index is passed, it must
clearly also be the same length as the arrays. If no index is passed, the
result will be <code class="docutils literal notranslate"><span class="pre">range(n)</span></code>, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the array length.</p>
<pre class="literal-block">In [44]: d = {'one': [1., 2., 3., 4.],
   ....:      'two': [4., 3., 2., 1.]}
   ....: 

In [45]: pd.DataFrame(d)
Out[45]: 
   one  two
0  1.0  4.0
1  2.0  3.0
2  3.0  2.0
3  4.0  1.0

In [46]: pd.DataFrame(d, index=['a', 'b', 'c', 'd'])
Out[46]: 
   one  two
a  1.0  4.0
b  2.0  3.0
c  3.0  2.0
d  4.0  1.0</pre>
</div>
<div class="section" id="from-structured-or-record-array">
<h3>From structured or record array<a class="headerlink" href="#from-structured-or-record-array" title="Permalink to this headline">¶</a></h3>
<p>This case is handled identically to a dict of arrays.</p>
<pre class="literal-block">In [47]: data = np.zeros((2, ), dtype=[('A', 'i4'), ('B', 'f4'), ('C', 'a10')])

In [48]: data[:] = [(1, 2., 'Hello'), (2, 3., &quot;World&quot;)]

In [49]: pd.DataFrame(data)
Out[49]: 
   A    B         C
0  1  2.0  b'Hello'
1  2  3.0  b'World'

In [50]: pd.DataFrame(data, index=['first', 'second'])
Out[50]: 
        A    B         C
first   1  2.0  b'Hello'
second  2  3.0  b'World'

In [51]: pd.DataFrame(data, columns=['C', 'A', 'B'])
Out[51]: 
          C  A    B
0  b'Hello'  1  2.0
1  b'World'  2  3.0</pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>DataFrame is not intended to work exactly like a 2-dimensional NumPy
ndarray.</p>
</div>
</div>
<div class="section" id="from-a-list-of-dicts">
<span id="basics-dataframe-from-list-of-dicts"></span><h3>From a list of dicts<a class="headerlink" href="#from-a-list-of-dicts" title="Permalink to this headline">¶</a></h3>
<pre class="literal-block">In [52]: data2 = [{'a': 1, 'b': 2}, {'a': 5, 'b': 10, 'c': 20}]

In [53]: pd.DataFrame(data2)
Out[53]: 
   a   b     c
0  1   2   NaN
1  5  10  20.0

In [54]: pd.DataFrame(data2, index=['first', 'second'])
Out[54]: 
        a   b     c
first   1   2   NaN
second  5  10  20.0

In [55]: pd.DataFrame(data2, columns=['a', 'b'])
Out[55]: 
   a   b
0  1   2
1  5  10</pre>
</div>
<div class="section" id="from-a-dict-of-tuples">
<span id="basics-dataframe-from-dict-of-tuples"></span><h3>From a dict of tuples<a class="headerlink" href="#from-a-dict-of-tuples" title="Permalink to this headline">¶</a></h3>
<p>You can automatically create a MultiIndexed frame by passing a tuples
dictionary.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [56]: </span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="p">{(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">):</span> <span class="mi">2</span><span class="p">},</span>
<span class="gp">   ....: </span>              <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="p">{(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">):</span> <span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">):</span> <span class="mi">4</span><span class="p">},</span>
<span class="gp">   ....: </span>              <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">):</span> <span class="p">{(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">):</span> <span class="mi">5</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">):</span> <span class="mi">6</span><span class="p">},</span>
<span class="gp">   ....: </span>              <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="p">{(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">):</span> <span class="mi">7</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">):</span> <span class="mi">8</span><span class="p">},</span>
<span class="gp">   ....: </span>              <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="p">{(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">):</span> <span class="mi">9</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">):</span> <span class="mi">10</span><span class="p">}})</span>
<span class="gp">   ....: </span>
<span class="gh">Out[56]: </span><span class="go"></span>
<span class="go">       a              b      </span>
<span class="go">       b    a    c    a     b</span>
<span class="go">A B  1.0  4.0  5.0  8.0  10.0</span>
<span class="go">  C  2.0  3.0  6.0  7.0   NaN</span>
<span class="go">  D  NaN  NaN  NaN  NaN   9.0</span>
</pre></div>
</div>
</div>
<div class="section" id="from-a-series">
<span id="basics-dataframe-from-series"></span><h3>From a Series<a class="headerlink" href="#from-a-series" title="Permalink to this headline">¶</a></h3>
<p>The result will be a DataFrame with the same index as the input Series, and
with one column whose name is the original name of the Series (only if no other
column name provided).</p>
<p><strong>Missing Data</strong></p>
<p>Much more will be said on this topic in the <a class="reference internal" href="../user_guide/missing_data.html#missing-data"><span class="std std-ref">Missing data</span></a>
section. To construct a DataFrame with missing data, we use <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> to
represent missing values. Alternatively, you may pass a <code class="docutils literal notranslate"><span class="pre">numpy.MaskedArray</span></code>
as the data argument to the DataFrame constructor, and its masked entries will
be considered missing.</p>
</div>
<div class="section" id="alternate-constructors">
<h3>Alternate Constructors<a class="headerlink" href="#alternate-constructors" title="Permalink to this headline">¶</a></h3>
<p id="basics-dataframe-from-dict"><strong>DataFrame.from_dict</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">DataFrame.from_dict</span></code> takes a dict of dicts or a dict of array-like sequences
and returns a DataFrame. It operates like the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> constructor except
for the <code class="docutils literal notranslate"><span class="pre">orient</span></code> parameter which is <code class="docutils literal notranslate"><span class="pre">'columns'</span></code> by default, but which can be
set to <code class="docutils literal notranslate"><span class="pre">'index'</span></code> in order to use the dict keys as row labels.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [57]: </span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])]))</span>
<span class="gh">Out[57]: </span><span class="go"></span>
<span class="go">   A  B</span>
<span class="go">0  1  4</span>
<span class="go">1  2  5</span>
<span class="go">2  3  6</span>
</pre></div>
</div>
<p>If you pass <code class="docutils literal notranslate"><span class="pre">orient='index'</span></code>, the keys will be the row labels. In this
case, you can also pass the desired column names:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [58]: </span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])]),</span>
<span class="gp">   ....: </span>                       <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">])</span>
<span class="gp">   ....: </span>
<span class="gh">Out[58]: </span><span class="go"></span>
<span class="go">   one  two  three</span>
<span class="go">A    1    2      3</span>
<span class="go">B    4    5      6</span>
</pre></div>
</div>
<p id="basics-dataframe-from-records"><strong>DataFrame.from_records</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">DataFrame.from_records</span></code> takes a list of tuples or an ndarray with structured
dtype. It works analogously to the normal <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> constructor, except that
the resulting DataFrame index may be a specific field of the structured
dtype. For example:</p>
<pre class="literal-block">In [59]: data
Out[59]: 
array([(1, 2., b'Hello'), (2, 3., b'World')],
      dtype=[('A', '&lt;i4'), ('B', '&lt;f4'), ('C', 'S10')])

In [60]: pd.DataFrame.from_records(data, index='C')
Out[60]: 
          A    B
C               
b'Hello'  1  2.0
b'World'  2  3.0</pre>
</div>
<div class="section" id="column-selection-addition-deletion">
<h3>Column selection, addition, deletion<a class="headerlink" href="#column-selection-addition-deletion" title="Permalink to this headline">¶</a></h3>
<p>You can treat a DataFrame semantically like a dict of like-indexed Series
objects. Getting, setting, and deleting columns works with the same syntax as
the analogous dict operations:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [61]: </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">]</span>
<span class="gh">Out[61]: </span><span class="go"></span>
<span class="go">a    1.0</span>
<span class="go">b    2.0</span>
<span class="go">c    3.0</span>
<span class="go">d    NaN</span>
<span class="go">Name: one, dtype: float64</span>

<span class="gp">In [62]: </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;three&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;two&#39;</span><span class="p">]</span>

<span class="gp">In [63]: </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;flag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span>

<span class="gp">In [64]: </span><span class="n">df</span>
<span class="gh">Out[64]: </span><span class="go"></span>
<span class="go">   one  two  three   flag</span>
<span class="go">a  1.0  1.0    1.0  False</span>
<span class="go">b  2.0  2.0    4.0  False</span>
<span class="go">c  3.0  3.0    9.0   True</span>
<span class="go">d  NaN  4.0    NaN  False</span>
</pre></div>
</div>
<p>Columns can be deleted or popped like with a dict:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [65]: </span><span class="k">del</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;two&#39;</span><span class="p">]</span>

<span class="gp">In [66]: </span><span class="n">three</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;three&#39;</span><span class="p">)</span>

<span class="gp">In [67]: </span><span class="n">df</span>
<span class="gh">Out[67]: </span><span class="go"></span>
<span class="go">   one   flag</span>
<span class="go">a  1.0  False</span>
<span class="go">b  2.0  False</span>
<span class="go">c  3.0   True</span>
<span class="go">d  NaN  False</span>
</pre></div>
</div>
<p>When inserting a scalar value, it will naturally be propagated to fill the
column:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [68]: </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span>

<span class="gp">In [69]: </span><span class="n">df</span>
<span class="gh">Out[69]: </span><span class="go"></span>
<span class="go">   one   flag  foo</span>
<span class="go">a  1.0  False  bar</span>
<span class="go">b  2.0  False  bar</span>
<span class="go">c  3.0   True  bar</span>
<span class="go">d  NaN  False  bar</span>
</pre></div>
</div>
<p>When inserting a Series that does not have the same index as the DataFrame, it
will be conformed to the DataFrame’s index:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [70]: </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;one_trunc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span>

<span class="gp">In [71]: </span><span class="n">df</span>
<span class="gh">Out[71]: </span><span class="go"></span>
<span class="go">   one   flag  foo  one_trunc</span>
<span class="go">a  1.0  False  bar        1.0</span>
<span class="go">b  2.0  False  bar        2.0</span>
<span class="go">c  3.0   True  bar        NaN</span>
<span class="go">d  NaN  False  bar        NaN</span>
</pre></div>
</div>
<p>You can insert raw ndarrays but their length must match the length of the
DataFrame’s index.</p>
<p>By default, columns get inserted at the end. The <code class="docutils literal notranslate"><span class="pre">insert</span></code> function is
available to insert at a particular location in the columns:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [72]: </span><span class="n">df</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">])</span>

<span class="gp">In [73]: </span><span class="n">df</span>
<span class="gh">Out[73]: </span><span class="go"></span>
<span class="go">   one  bar   flag  foo  one_trunc</span>
<span class="go">a  1.0  1.0  False  bar        1.0</span>
<span class="go">b  2.0  2.0  False  bar        2.0</span>
<span class="go">c  3.0  3.0   True  bar        NaN</span>
<span class="go">d  NaN  NaN  False  bar        NaN</span>
</pre></div>
</div>
</div>
<div class="section" id="assigning-new-columns-in-method-chains">
<span id="dsintro-chained-assignment"></span><h3>Assigning New Columns in Method Chains<a class="headerlink" href="#assigning-new-columns-in-method-chains" title="Permalink to this headline">¶</a></h3>
<p>Inspired by <a class="reference external" href="https://dplyr.tidyverse.org/reference/mutate.html">dplyr’s</a>
<code class="docutils literal notranslate"><span class="pre">mutate</span></code> verb, DataFrame has an <a class="reference internal" href="../generated/pandas.DataFrame.assign.html#pandas.DataFrame.assign" title="pandas.DataFrame.assign"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assign()</span></code></a>
method that allows you to easily create new columns that are potentially
derived from existing columns.</p>
<pre class="literal-block">In [74]: iris = pd.read_csv('data/iris.data')
---------------------------------------------------------------------------
FileNotFoundError                         Traceback (most recent call last)
&lt;ipython-input-74-942100915cc1&gt; in &lt;module&gt;
----&gt; 1 iris = pd.read_csv('data/iris.data')

~/miniconda/lib/python3.7/site-packages/pandas/io/parsers.py in parser_f(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, squeeze, prefix, mangle_dupe_cols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, dialect, error_bad_lines, warn_bad_lines, delim_whitespace, low_memory, memory_map, float_precision)
    683         )
    684 
--&gt; 685         return _read(filepath_or_buffer, kwds)
    686 
    687     parser_f.__name__ = name

~/miniconda/lib/python3.7/site-packages/pandas/io/parsers.py in _read(filepath_or_buffer, kwds)
    455 
    456     # Create the parser.
--&gt; 457     parser = TextFileReader(fp_or_buf, **kwds)
    458 
    459     if chunksize or iterator:

~/miniconda/lib/python3.7/site-packages/pandas/io/parsers.py in __init__(self, f, engine, **kwds)
    893             self.options[&quot;has_index_names&quot;] = kwds[&quot;has_index_names&quot;]
    894 
--&gt; 895         self._make_engine(self.engine)
    896 
    897     def close(self):

~/miniconda/lib/python3.7/site-packages/pandas/io/parsers.py in _make_engine(self, engine)
   1133     def _make_engine(self, engine=&quot;c&quot;):
   1134         if engine == &quot;c&quot;:
-&gt; 1135             self._engine = CParserWrapper(self.f, **self.options)
   1136         else:
   1137             if engine == &quot;python&quot;:

~/miniconda/lib/python3.7/site-packages/pandas/io/parsers.py in __init__(self, src, **kwds)
   1904         kwds[&quot;usecols&quot;] = self.usecols
   1905 
-&gt; 1906         self._reader = parsers.TextReader(src, **kwds)
   1907         self.unnamed_cols = self._reader.unnamed_cols
   1908 

pandas/_libs/parsers.pyx in pandas._libs.parsers.TextReader.__cinit__()

pandas/_libs/parsers.pyx in pandas._libs.parsers.TextReader._setup_parser_source()

FileNotFoundError: [Errno 2] File b'data/iris.data' does not exist: b'data/iris.data'

In [75]: iris.head()
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-75-5c93502afc24&gt; in &lt;module&gt;
----&gt; 1 iris.head()

NameError: name 'iris' is not defined

In [76]: (iris.assign(sepal_ratio=iris['SepalWidth'] / iris['SepalLength'])
   ....:      .head())
   ....: 
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-76-c6c6e2ccc592&gt; in &lt;module&gt;
----&gt; 1 (iris.assign(sepal_ratio=iris['SepalWidth'] / iris['SepalLength'])
      2      .head())

NameError: name 'iris' is not defined</pre>
<p>In the example above, we inserted a precomputed value. We can also pass in
a function of one argument to be evaluated on the DataFrame being assigned to.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [77]: </span><span class="n">iris</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">sepal_ratio</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;SepalWidth&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;SepalLength&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
<span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">NameError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">77</span><span class="o">-</span><span class="mi">5462</span><span class="n">f00a2eb8</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">iris</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">sepal_ratio</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;SepalWidth&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;SepalLength&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>

<span class="ne">NameError</span>: name &#39;iris&#39; is not defined
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">assign</span></code> <strong>always</strong> returns a copy of the data, leaving the original
DataFrame untouched.</p>
<p>Passing a callable, as opposed to an actual value to be inserted, is
useful when you don’t have a reference to the DataFrame at hand. This is
common when using <code class="docutils literal notranslate"><span class="pre">assign</span></code> in a chain of operations. For example,
we can limit the DataFrame to just those observations with a Sepal Length
greater than 5, calculate the ratio, and plot:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [78]: </span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;SepalLength &gt; 5&#39;</span><span class="p">)</span>
<span class="gp">   ....: </span>     <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">SepalRatio</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">SepalWidth</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">SepalLength</span><span class="p">,</span>
<span class="gp">   ....: </span>             <span class="n">PetalRatio</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">PetalWidth</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">PetalLength</span><span class="p">)</span>
<span class="gp">   ....: </span>     <span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;scatter&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s1">&#39;SepalRatio&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;PetalRatio&#39;</span><span class="p">))</span>
<span class="gp">   ....: </span>
<span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">NameError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">78</span><span class="o">-</span><span class="n">e7bb7dadf5fe</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;SepalLength &gt; 5&#39;</span><span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span>      <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">SepalRatio</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">SepalWidth</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">SepalLength</span><span class="p">,</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span>              <span class="n">PetalRatio</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">PetalWidth</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">PetalLength</span><span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">4</span>      <span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;scatter&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s1">&#39;SepalRatio&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s1">&#39;PetalRatio&#39;</span><span class="p">))</span>

<span class="ne">NameError</span>: name &#39;iris&#39; is not defined
</pre></div>
</div>
<img alt="../_images/basics_assign.png" src="../_images/basics_assign.png" />
<p>Since a function is passed in, the function is computed on the DataFrame
being assigned to. Importantly, this is the DataFrame that’s been filtered
to those rows with sepal length greater than 5. The filtering happens first,
and then the ratio calculations. This is an example where we didn’t
have a reference to the <em>filtered</em> DataFrame available.</p>
<p>The function signature for <code class="docutils literal notranslate"><span class="pre">assign</span></code> is simply <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>. The keys
are the column names for the new fields, and the values are either a value
to be inserted (for example, a <code class="docutils literal notranslate"><span class="pre">Series</span></code> or NumPy array), or a function
of one argument to be called on the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>. A <em>copy</em> of the original
DataFrame is returned, with the new values inserted.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.23.0.</span></p>
</div>
<p>Starting with Python 3.6 the order of <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> is preserved. This allows
for <em>dependent</em> assignment, where an expression later in <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> can refer
to a column created earlier in the same <a class="reference internal" href="../generated/pandas.DataFrame.assign.html#pandas.DataFrame.assign" title="pandas.DataFrame.assign"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assign()</span></code></a>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [79]: </span><span class="n">dfa</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">   ....: </span>                    <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]})</span>
<span class="gp">   ....: </span>

<span class="gp">In [80]: </span><span class="n">dfa</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">],</span>
<span class="gp">   ....: </span>           <span class="n">D</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">])</span>
<span class="gp">   ....: </span>
<span class="gh">Out[80]: </span><span class="go"></span>
<span class="go">   A  B  C   D</span>
<span class="go">0  1  4  5   6</span>
<span class="go">1  2  5  7   9</span>
<span class="go">2  3  6  9  12</span>
</pre></div>
</div>
<p>In the second expression, <code class="docutils literal notranslate"><span class="pre">x['C']</span></code> will refer to the newly created column,
that’s equal to <code class="docutils literal notranslate"><span class="pre">dfa['A']</span> <span class="pre">+</span> <span class="pre">dfa['B']</span></code>.</p>
<p>To write code compatible with all versions of Python, split the assignment in two.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [81]: </span><span class="n">dependent</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>

<span class="gp">In [82]: </span><span class="p">(</span><span class="n">dependent</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">   ....: </span>          <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">B</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">   ....: </span>
<span class="gh">Out[82]: </span><span class="go"></span>
<span class="go">   A  B</span>
<span class="go">0  2  4</span>
<span class="go">1  2  4</span>
<span class="go">2  2  4</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Dependent assignment maybe subtly change the behavior of your code between
Python 3.6 and older versions of Python.</p>
<p>If you wish write code that supports versions of python before and after 3.6,
you’ll need to take care when passing <code class="docutils literal notranslate"><span class="pre">assign</span></code> expressions that</p>
<ul class="simple">
<li><p>Updating an existing column</p></li>
<li><p>Referring to the newly updated column in the same <code class="docutils literal notranslate"><span class="pre">assign</span></code></p></li>
</ul>
<p>For example, we’ll update column “A” and then refer to it when creating “B”.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dependent</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dependent</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>For Python 3.5 and earlier the expression creating <code class="docutils literal notranslate"><span class="pre">B</span></code> refers to the
“old” value of <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">1,</span> <span class="pre">1]</span></code>. The output is then</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">   A  B</span>
<span class="go">0  2  3</span>
<span class="go">1  2  3</span>
<span class="go">2  2  3</span>
</pre></div>
</div>
<p>For Python 3.6 and later, the expression creating <code class="docutils literal notranslate"><span class="pre">A</span></code> refers to the
“new” value of <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">[2,</span> <span class="pre">2,</span> <span class="pre">2]</span></code>, which results in</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">   A  B</span>
<span class="go">0  2  4</span>
<span class="go">1  2  4</span>
<span class="go">2  2  4</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="indexing-selection">
<h3>Indexing / Selection<a class="headerlink" href="#indexing-selection" title="Permalink to this headline">¶</a></h3>
<p>The basics of indexing are as follows:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 33%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operation</p></th>
<th class="head"><p>Syntax</p></th>
<th class="head"><p>Result</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Select column</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">df[col]</span></code></p></td>
<td><p>Series</p></td>
</tr>
<tr class="row-odd"><td><p>Select row by label</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">df.loc[label]</span></code></p></td>
<td><p>Series</p></td>
</tr>
<tr class="row-even"><td><p>Select row by integer location</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">df.iloc[loc]</span></code></p></td>
<td><p>Series</p></td>
</tr>
<tr class="row-odd"><td><p>Slice rows</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">df[5:10]</span></code></p></td>
<td><p>DataFrame</p></td>
</tr>
<tr class="row-even"><td><p>Select rows by boolean vector</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">df[bool_vec]</span></code></p></td>
<td><p>DataFrame</p></td>
</tr>
</tbody>
</table>
<p>Row selection, for example, returns a Series whose index is the columns of the
DataFrame:</p>
<pre class="literal-block">In [83]: df.loc['b']
Out[83]: 
one              2
bar              2
flag         False
foo            bar
one_trunc        2
Name: b, dtype: object

In [84]: df.iloc[2]
Out[84]: 
one             3
bar             3
flag         True
foo           bar
one_trunc     NaN
Name: c, dtype: object</pre>
<p>For a more exhaustive treatment of sophisticated label-based indexing and
slicing, see the <a class="reference internal" href="../user_guide/indexing.html#indexing"><span class="std std-ref">section on indexing</span></a>. We will address the
fundamentals of reindexing / conforming to new sets of labels in the
<a class="reference internal" href="basics.html#basics-reindexing"><span class="std std-ref">section on reindexing</span></a>.</p>
</div>
<div class="section" id="data-alignment-and-arithmetic">
<span id="dsintro-alignment"></span><h3>Data alignment and arithmetic<a class="headerlink" href="#data-alignment-and-arithmetic" title="Permalink to this headline">¶</a></h3>
<p>Data alignment between DataFrame objects automatically align on <strong>both the
columns and the index (row labels)</strong>. Again, the resulting object will have the
union of the column and row labels.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [85]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">])</span>

<span class="gp">In [86]: </span><span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>

<span class="gp">In [87]: </span><span class="n">df</span> <span class="o">+</span> <span class="n">df2</span>
<span class="gh">Out[87]: </span><span class="go"></span>
<span class="go">          A         B         C   D</span>
<span class="go">0  0.045691 -0.014138  1.380871 NaN</span>
<span class="go">1 -0.955398 -1.501007  0.037181 NaN</span>
<span class="go">2 -0.662690  1.534833 -0.859691 NaN</span>
<span class="go">3 -2.452949  1.237274 -0.133712 NaN</span>
<span class="go">4  1.414490  1.951676 -2.320422 NaN</span>
<span class="go">5 -0.494922 -1.649727 -1.084601 NaN</span>
<span class="go">6 -1.047551 -0.748572 -0.805479 NaN</span>
<span class="go">7       NaN       NaN       NaN NaN</span>
<span class="go">8       NaN       NaN       NaN NaN</span>
<span class="go">9       NaN       NaN       NaN NaN</span>
</pre></div>
</div>
<p>When doing an operation between DataFrame and Series, the default behavior is
to align the Series <strong>index</strong> on the DataFrame <strong>columns</strong>, thus <a class="reference external" href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">broadcasting</a>
row-wise. For example:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [88]: </span><span class="n">df</span> <span class="o">-</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gh">Out[88]: </span><span class="go"></span>
<span class="go">          A         B         C         D</span>
<span class="go">0  0.000000  0.000000  0.000000  0.000000</span>
<span class="go">1 -1.359261 -0.248717 -0.453372 -1.754659</span>
<span class="go">2  0.253128  0.829678  0.010026 -1.991234</span>
<span class="go">3 -1.311128  0.054325 -1.724913 -1.620544</span>
<span class="go">4  0.573025  1.500742 -0.676070  1.367331</span>
<span class="go">5 -1.741248  0.781993 -1.241620 -2.053136</span>
<span class="go">6 -1.240774 -0.869551 -0.153282  0.000430</span>
<span class="go">7 -0.743894  0.411013 -0.929563 -0.282386</span>
<span class="go">8 -1.194921  1.320690  0.238224 -1.482644</span>
<span class="go">9  2.293786  1.856228  0.773289 -1.446531</span>
</pre></div>
</div>
<p>In the special case of working with time series data, and the DataFrame index
also contains dates, the broadcasting will be column-wise:</p>
<pre class="literal-block">In [89]: index = pd.date_range('1/1/2000', periods=8)

In [90]: df = pd.DataFrame(np.random.randn(8, 3), index=index, columns=list('ABC'))

In [91]: df
Out[91]: 
                   A         B         C
2000-01-01 -1.226825  0.769804 -1.281247
2000-01-02 -0.727707 -0.121306 -0.097883
2000-01-03  0.695775  0.341734  0.959726
2000-01-04 -1.110336 -0.619976  0.149748
2000-01-05 -0.732339  0.687738  0.176444
2000-01-06  0.403310 -0.154951  0.301624
2000-01-07 -2.179861 -1.369849 -0.954208
2000-01-08  1.462696 -1.743161 -0.826591

In [92]: type(df['A'])
Out[92]: pandas.core.series.Series

In [93]: df - df['A']
Out[93]: 
            2000-01-01 00:00:00  2000-01-02 00:00:00  ...   B   C
2000-01-01                  NaN                  NaN  ... NaN NaN
2000-01-02                  NaN                  NaN  ... NaN NaN
2000-01-03                  NaN                  NaN  ... NaN NaN
2000-01-04                  NaN                  NaN  ... NaN NaN
2000-01-05                  NaN                  NaN  ... NaN NaN
2000-01-06                  NaN                  NaN  ... NaN NaN
2000-01-07                  NaN                  NaN  ... NaN NaN
2000-01-08                  NaN                  NaN  ... NaN NaN

[8 rows x 11 columns]</pre>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>is now deprecated and will be removed in a future release. The preferred way
to replicate this behavior is</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>For explicit control over the matching and broadcasting behavior, see the
section on <a class="reference internal" href="basics.html#basics-binop"><span class="std std-ref">flexible binary operations</span></a>.</p>
<p>Operations with scalars are just as you would expect:</p>
<pre class="literal-block">In [94]: df * 5 + 2
Out[94]: 
                   A         B         C
2000-01-01 -4.134126  5.849018 -4.406237
2000-01-02 -1.638535  1.393469  1.510587
2000-01-03  5.478873  3.708672  6.798628
2000-01-04 -3.551681 -1.099880  2.748742
2000-01-05 -1.661697  5.438692  2.882222
2000-01-06  4.016548  1.225246  3.508122
2000-01-07 -8.899303 -4.849247 -2.771039
2000-01-08  9.313480 -6.715805 -2.132955

In [95]: 1 / df
Out[95]: 
                   A         B          C
2000-01-01 -0.815112  1.299033  -0.780489
2000-01-02 -1.374179 -8.243600 -10.216313
2000-01-03  1.437247  2.926250   1.041965
2000-01-04 -0.900628 -1.612966   6.677871
2000-01-05 -1.365487  1.454041   5.667510
2000-01-06  2.479485 -6.453662   3.315381
2000-01-07 -0.458745 -0.730007  -1.047990
2000-01-08  0.683669 -0.573671  -1.209788

In [96]: df ** 4
Out[96]: 
                    A         B         C
2000-01-01   2.265327  0.351172  2.694833
2000-01-02   0.280431  0.000217  0.000092
2000-01-03   0.234355  0.013638  0.848376
2000-01-04   1.519910  0.147740  0.000503
2000-01-05   0.287640  0.223714  0.000969
2000-01-06   0.026458  0.000576  0.008277
2000-01-07  22.579530  3.521204  0.829033
2000-01-08   4.577374  9.233151  0.466834</pre>
<p id="dsintro-boolean">Boolean operators work as well:</p>
<pre class="literal-block">In [97]: df1 = pd.DataFrame({'a': [1, 0, 1], 'b': [0, 1, 1]}, dtype=bool)

In [98]: df2 = pd.DataFrame({'a': [0, 1, 1], 'b': [1, 1, 0]}, dtype=bool)

In [99]: df1 &amp; df2
Out[99]: 
       a      b
0  False  False
1  False   True
2   True  False

In [100]: df1 | df2
Out[100]: 
      a     b
0  True  True
1  True  True
2  True  True

In [101]: df1 ^ df2
Out[101]: 
       a      b
0   True   True
1   True  False
2  False   True

In [102]: -df1
Out[102]: 
       a      b
0  False   True
1   True  False
2  False  False</pre>
</div>
<div class="section" id="transposing">
<h3>Transposing<a class="headerlink" href="#transposing" title="Permalink to this headline">¶</a></h3>
<p>To transpose, access the <code class="docutils literal notranslate"><span class="pre">T</span></code> attribute (also the <code class="docutils literal notranslate"><span class="pre">transpose</span></code> function),
similar to an ndarray:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># only show the first 5 rows</span>
<span class="gp">In [103]: </span><span class="n">df</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
<span class="gh">Out[103]: </span><span class="go"></span>
<span class="go">   2000-01-01  2000-01-02  2000-01-03  2000-01-04  2000-01-05</span>
<span class="go">A   -1.226825   -0.727707    0.695775   -1.110336   -0.732339</span>
<span class="go">B    0.769804   -0.121306    0.341734   -0.619976    0.687738</span>
<span class="go">C   -1.281247   -0.097883    0.959726    0.149748    0.176444</span>
</pre></div>
</div>
</div>
<div class="section" id="dataframe-interoperability-with-numpy-functions">
<h3>DataFrame interoperability with NumPy functions<a class="headerlink" href="#dataframe-interoperability-with-numpy-functions" title="Permalink to this headline">¶</a></h3>
<p id="dsintro-numpy-interop">Elementwise NumPy ufuncs (log, exp, sqrt, …) and various other NumPy functions
can be used with no issues on DataFrame, assuming the data within are numeric:</p>
<pre class="literal-block">In [104]: np.exp(df)
Out[104]: 
                   A         B         C
2000-01-01  0.293222  2.159342  0.277691
2000-01-02  0.483015  0.885763  0.906755
2000-01-03  2.005262  1.407386  2.610980
2000-01-04  0.329448  0.537957  1.161542
2000-01-05  0.480783  1.989212  1.192968
2000-01-06  1.496770  0.856457  1.352053
2000-01-07  0.113057  0.254145  0.385117
2000-01-08  4.317584  0.174966  0.437538

In [105]: np.asarray(df)
Out[105]: 
array([[-1.2268,  0.7698, -1.2812],
       [-0.7277, -0.1213, -0.0979],
       [ 0.6958,  0.3417,  0.9597],
       [-1.1103, -0.62  ,  0.1497],
       [-0.7323,  0.6877,  0.1764],
       [ 0.4033, -0.155 ,  0.3016],
       [-2.1799, -1.3698, -0.9542],
       [ 1.4627, -1.7432, -0.8266]])</pre>
<p>The dot method on DataFrame implements matrix multiplication:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [106]: </span><span class="n">df</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="gh">Out[106]: </span><span class="go"></span>
<span class="go">           A         B         C</span>
<span class="go">A  11.341858 -0.059772  3.007998</span>
<span class="go">B  -0.059772  6.520556  2.083308</span>
<span class="go">C   3.007998  2.083308  4.310549</span>
</pre></div>
</div>
<p>Similarly, the dot method on Series implements dot product:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [107]: </span><span class="n">s1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="gp">In [108]: </span><span class="n">s1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
<span class="gh">Out[108]: </span><span class="go">255</span>
</pre></div>
</div>
<p>DataFrame is not intended to be a drop-in replacement for ndarray as its
indexing semantics are quite different in places from a matrix.</p>
</div>
<div class="section" id="console-display">
<h3>Console display<a class="headerlink" href="#console-display" title="Permalink to this headline">¶</a></h3>
<p>Very large DataFrames will be truncated to display them in the console.
You can also get a summary using <a class="reference internal" href="../generated/pandas.DataFrame.info.html#pandas.DataFrame.info" title="pandas.DataFrame.info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code></a>.
(Here I am reading a CSV version of the <strong>baseball</strong> dataset from the <strong>plyr</strong>
R package):</p>
<pre class="literal-block">In [109]: baseball = pd.read_csv('data/baseball.csv')
---------------------------------------------------------------------------
FileNotFoundError                         Traceback (most recent call last)
&lt;ipython-input-109-02f16f840f65&gt; in &lt;module&gt;
----&gt; 1 baseball = pd.read_csv('data/baseball.csv')

~/miniconda/lib/python3.7/site-packages/pandas/io/parsers.py in parser_f(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, squeeze, prefix, mangle_dupe_cols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, dialect, error_bad_lines, warn_bad_lines, delim_whitespace, low_memory, memory_map, float_precision)
    683         )
    684 
--&gt; 685         return _read(filepath_or_buffer, kwds)
    686 
    687     parser_f.__name__ = name

~/miniconda/lib/python3.7/site-packages/pandas/io/parsers.py in _read(filepath_or_buffer, kwds)
    455 
    456     # Create the parser.
--&gt; 457     parser = TextFileReader(fp_or_buf, **kwds)
    458 
    459     if chunksize or iterator:

~/miniconda/lib/python3.7/site-packages/pandas/io/parsers.py in __init__(self, f, engine, **kwds)
    893             self.options[&quot;has_index_names&quot;] = kwds[&quot;has_index_names&quot;]
    894 
--&gt; 895         self._make_engine(self.engine)
    896 
    897     def close(self):

~/miniconda/lib/python3.7/site-packages/pandas/io/parsers.py in _make_engine(self, engine)
   1133     def _make_engine(self, engine=&quot;c&quot;):
   1134         if engine == &quot;c&quot;:
-&gt; 1135             self._engine = CParserWrapper(self.f, **self.options)
   1136         else:
   1137             if engine == &quot;python&quot;:

~/miniconda/lib/python3.7/site-packages/pandas/io/parsers.py in __init__(self, src, **kwds)
   1904         kwds[&quot;usecols&quot;] = self.usecols
   1905 
-&gt; 1906         self._reader = parsers.TextReader(src, **kwds)
   1907         self.unnamed_cols = self._reader.unnamed_cols
   1908 

pandas/_libs/parsers.pyx in pandas._libs.parsers.TextReader.__cinit__()

pandas/_libs/parsers.pyx in pandas._libs.parsers.TextReader._setup_parser_source()

FileNotFoundError: [Errno 2] File b'data/baseball.csv' does not exist: b'data/baseball.csv'

In [110]: print(baseball)
     team player  batting avg
0   team 1      j     0.317529
1   team 2      g     0.295327
..     ...    ...          ...
23  team 4      n     0.394457
24  team 5      h     0.253395

[25 rows x 3 columns]

In [111]: baseball.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 25 entries, 0 to 24
Data columns (total 3 columns):
team           25 non-null object
player         25 non-null object
batting avg    25 non-null float64
dtypes: float64(1), object(2)
memory usage: 728.0+ bytes</pre>
<p>However, using <code class="docutils literal notranslate"><span class="pre">to_string</span></code> will return a string representation of the
DataFrame in tabular form, though it won’t always fit the console width:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [112]: </span><span class="k">print</span><span class="p">(</span><span class="n">baseball</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">20</span><span class="p">:,</span> <span class="p">:</span><span class="mi">12</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">())</span>
<span class="go">      team player  batting avg</span>
<span class="go">5   team 1      b     0.264472</span>
<span class="go">6   team 2      w     0.217328</span>
<span class="go">7   team 3      e     0.205557</span>
<span class="go">8   team 4      f     0.208757</span>
<span class="go">9   team 5      x     0.396194</span>
<span class="go">10  team 1      c     0.352134</span>
<span class="go">11  team 2      u     0.269304</span>
<span class="go">12  team 3      r     0.397191</span>
<span class="go">13  team 4      v     0.318044</span>
<span class="go">14  team 5      t     0.273606</span>
<span class="go">15  team 1      y     0.338428</span>
<span class="go">16  team 2      z     0.226214</span>
<span class="go">17  team 3      q     0.357841</span>
<span class="go">18  team 4      a     0.244862</span>
<span class="go">19  team 5      k     0.395730</span>
<span class="go">20  team 1      l     0.339411</span>
<span class="go">21  team 2      p     0.254634</span>
<span class="go">22  team 3      m     0.321231</span>
<span class="go">23  team 4      n     0.394457</span>
<span class="go">24  team 5      h     0.253395</span>
</pre></div>
</div>
<p>Wide DataFrames will be printed across multiple rows by
default:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [113]: </span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="gh">Out[113]: </span><span class="go"></span>
<span class="go">         0         1         2   ...        9         10        11</span>
<span class="go">0 -0.345352  1.314232  0.690579  ...  0.896171 -0.487602 -0.082240</span>
<span class="go">1 -2.182937  0.380396  0.084844  ... -0.023688  2.410179  1.450520</span>
<span class="go">2  0.206053 -0.251905 -2.213588  ... -0.025747 -0.988387  0.094055</span>

<span class="go">[3 rows x 12 columns]</span>
</pre></div>
</div>
<p>You can change how much to print on a single row by setting the <code class="docutils literal notranslate"><span class="pre">display.width</span></code>
option:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [114]: </span><span class="n">pd</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s1">&#39;display.width&#39;</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>  <span class="c1"># default is 80</span>

<span class="gp">In [115]: </span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="gh">Out[115]: </span><span class="go"></span>
<span class="go">         0         1         2   ...        9         10        11</span>
<span class="go">0  1.262731  1.289997  0.082423  ... -0.281461  0.030711  0.109121</span>
<span class="go">1  1.126203 -0.977349  1.474071  ...  0.583787  0.221471 -0.744471</span>
<span class="go">2  0.758527  1.729689 -0.964980  ...  0.888782  0.228440  0.901805</span>

<span class="go">[3 rows x 12 columns]</span>
</pre></div>
</div>
<p>You can adjust the max width of the individual columns by setting <code class="docutils literal notranslate"><span class="pre">display.max_colwidth</span></code></p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [116]: </span><span class="n">datafile</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;filename&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;filename_01&#39;</span><span class="p">,</span> <span class="s1">&#39;filename_02&#39;</span><span class="p">],</span>
<span class="gp">   .....: </span>            <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;media/user_name/storage/folder_01/filename_01&quot;</span><span class="p">,</span>
<span class="gp">   .....: </span>                     <span class="s2">&quot;media/user_name/storage/folder_02/filename_02&quot;</span><span class="p">]}</span>
<span class="gp">   .....: </span>

<span class="gp">In [117]: </span><span class="n">pd</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s1">&#39;display.max_colwidth&#39;</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>

<span class="gp">In [118]: </span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">datafile</span><span class="p">)</span>
<span class="gh">Out[118]: </span><span class="go"></span>
<span class="go">      filename                           path</span>
<span class="go">0  filename_01  media/user_name/storage/fo...</span>
<span class="go">1  filename_02  media/user_name/storage/fo...</span>

<span class="gp">In [119]: </span><span class="n">pd</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s1">&#39;display.max_colwidth&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="gp">In [120]: </span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">datafile</span><span class="p">)</span>
<span class="gh">Out[120]: </span><span class="go"></span>
<span class="go">      filename                                           path</span>
<span class="go">0  filename_01  media/user_name/storage/folder_01/filename_01</span>
<span class="go">1  filename_02  media/user_name/storage/folder_02/filename_02</span>
</pre></div>
</div>
<p>You can also disable this feature via the <code class="docutils literal notranslate"><span class="pre">expand_frame_repr</span></code> option.
This will print the table in one block.</p>
</div>
<div class="section" id="dataframe-column-attribute-access-and-ipython-completion">
<h3>DataFrame column attribute access and IPython completion<a class="headerlink" href="#dataframe-column-attribute-access-and-ipython-completion" title="Permalink to this headline">¶</a></h3>
<p>If a DataFrame column label is a valid Python variable name, the column can be
accessed like an attribute:</p>
<pre class="literal-block">In [121]: df = pd.DataFrame({'foo1': np.random.randn(5),
   .....:                    'foo2': np.random.randn(5)})
   .....: 

In [122]: df
Out[122]: 
       foo1      foo2
0  1.171216 -0.858447
1  0.520260  0.306996
2 -1.197071 -0.028665
3 -1.066969  0.384316
4 -0.303421  1.574159

In [123]: df.foo1
Out[123]: 
0    1.171216
1    0.520260
2   -1.197071
3   -1.066969
4   -0.303421
Name: foo1, dtype: float64</pre>
<p>The columns are also connected to the <a class="reference external" href="https://ipython.org">IPython</a>
completion mechanism so they can be tab-completed:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="n">df</span><span class="o">.</span><span class="n">fo</span><span class="o">&lt;</span><span class="n">TAB</span><span class="o">&gt;</span>  <span class="c1"># noqa: E225, E999</span>
<span class="go">df.foo1  df.foo2</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="panel">
<span id="basics-panel"></span><h2>Panel<a class="headerlink" href="#panel" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In 0.20.0, <code class="docutils literal notranslate"><span class="pre">Panel</span></code> is deprecated and will be removed in
a future version. See the section <a class="reference internal" href="#dsintro-deprecate-panel"><span class="std std-ref">Deprecate Panel</span></a>.</p>
</div>
<p>Panel is a somewhat less-used, but still important container for 3-dimensional
data. The term <a class="reference external" href="https://en.wikipedia.org/wiki/Panel_data">panel data</a> is
derived from econometrics and is partially responsible for the name pandas:
pan(el)-da(ta)-s. The names for the 3 axes are intended to give some semantic
meaning to describing operations involving panel data and, in particular,
econometric analysis of panel data. However, for the strict purposes of slicing
and dicing a collection of DataFrame objects, you may find the axis names
slightly arbitrary:</p>
<ul class="simple">
<li><p><strong>items</strong>: axis 0, each item corresponds to a DataFrame contained inside</p></li>
<li><p><strong>major_axis</strong>: axis 1, it is the <strong>index</strong> (rows) of each of the
DataFrames</p></li>
<li><p><strong>minor_axis</strong>: axis 2, it is the <strong>columns</strong> of each of the DataFrames</p></li>
</ul>
<p>Construction of Panels works about like you would expect:</p>
<div class="section" id="from-3d-ndarray-with-optional-axis-labels">
<h3>From 3D ndarray with optional axis labels<a class="headerlink" href="#from-3d-ndarray-with-optional-axis-labels" title="Permalink to this headline">¶</a></h3>
<pre class="literal-block">In [124]: wp = pd.Panel(np.random.randn(2, 5, 4), items=['Item1', 'Item2'],
   .....:               major_axis=pd.date_range('1/1/2000', periods=5),
   .....:               minor_axis=['A', 'B', 'C', 'D'])
   .....: 
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-124-a0e3b0a73fdf&gt; in &lt;module&gt;
      1 wp = pd.Panel(np.random.randn(2, 5, 4), items=['Item1', 'Item2'],
      2               major_axis=pd.date_range('1/1/2000', periods=5),
----&gt; 3               minor_axis=['A', 'B', 'C', 'D'])

TypeError: Panel() takes no arguments

In [125]: wp
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-125-a50596aeb3e2&gt; in &lt;module&gt;
----&gt; 1 wp

NameError: name 'wp' is not defined</pre>
</div>
<div class="section" id="from-dict-of-dataframe-objects">
<h3>From dict of DataFrame objects<a class="headerlink" href="#from-dict-of-dataframe-objects" title="Permalink to this headline">¶</a></h3>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [126]: </span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Item1&#39;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
<span class="gp">   .....: </span>        <span class="s1">&#39;Item2&#39;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))}</span>
<span class="gp">   .....: </span>

<span class="gp">In [127]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Panel</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">TypeError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">127</span><span class="o">-</span><span class="mi">2</span><span class="n">ee4ccb3f0c0</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">pd</span><span class="o">.</span><span class="n">Panel</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="ne">TypeError</span>: Panel() takes no arguments
</pre></div>
</div>
<p>Note that the values in the dict need only be <strong>convertible to
DataFrame</strong>. Thus, they can be any of the other valid inputs to DataFrame as
per above.</p>
<p>One helpful factory method is <code class="docutils literal notranslate"><span class="pre">Panel.from_dict</span></code>, which takes a
dictionary of DataFrames as above, and the following named parameters:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Parameter</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>intersect</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">False</span></code></p></td>
<td><p>drops elements whose indices do not align</p></td>
</tr>
<tr class="row-odd"><td><p>orient</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">items</span></code></p></td>
<td><p>use <code class="docutils literal notranslate"><span class="pre">minor</span></code> to use DataFrames’ columns as panel items</p></td>
</tr>
</tbody>
</table>
<p>For example, compare to the construction above:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [128]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Panel</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;minor&#39;</span><span class="p">)</span>
<span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">AttributeError</span><span class="g g-Whitespace">                            </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">128</span><span class="o">-</span><span class="n">d18ffe807453</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">pd</span><span class="o">.</span><span class="n">Panel</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;minor&#39;</span><span class="p">)</span>

<span class="ne">AttributeError</span>: type object &#39;Panel&#39; has no attribute &#39;from_dict&#39;
</pre></div>
</div>
<p>Orient is especially useful for mixed-type DataFrames. If you pass a dict of
DataFrame objects with mixed-type columns, all of the data will get upcasted to
<code class="docutils literal notranslate"><span class="pre">dtype=object</span></code> unless you pass <code class="docutils literal notranslate"><span class="pre">orient='minor'</span></code>:</p>
<pre class="literal-block">In [129]: df = pd.DataFrame({'a': ['foo', 'bar', 'baz'],
   .....:                    'b': np.random.randn(3)})
   .....: 

In [130]: df
Out[130]: 
     a         b
0  foo -0.308853
1  bar -0.681087
2  baz  0.377953

In [131]: data = {'item1': df, 'item2': df}

In [132]: panel = pd.Panel.from_dict(data, orient='minor')
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-132-be0fa139155b&gt; in &lt;module&gt;
----&gt; 1 panel = pd.Panel.from_dict(data, orient='minor')

AttributeError: type object 'Panel' has no attribute 'from_dict'

In [133]: panel['a']
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-133-9eca4a985241&gt; in &lt;module&gt;
----&gt; 1 panel['a']

NameError: name 'panel' is not defined

In [134]: panel['b']
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-134-1f8bd3f424f8&gt; in &lt;module&gt;
----&gt; 1 panel['b']

NameError: name 'panel' is not defined

In [135]: panel['b'].dtypes
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-135-559cc5565535&gt; in &lt;module&gt;
----&gt; 1 panel['b'].dtypes

NameError: name 'panel' is not defined</pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Panel, being less commonly used than Series and DataFrame,
has been slightly neglected feature-wise. A number of methods and options
available in DataFrame are not available in Panel.</p>
</div>
</div>
<div class="section" id="from-dataframe-using-to-panel-method">
<span id="dsintro-to-panel"></span><h3>From DataFrame using <code class="docutils literal notranslate"><span class="pre">to_panel</span></code> method<a class="headerlink" href="#from-dataframe-using-to-panel-method" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">to_panel</span></code> converts a DataFrame with a two-level index to a Panel.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [136]: </span><span class="n">midx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">(</span><span class="n">levels</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]],</span>
<span class="gp">   .....: </span>                     <span class="n">codes</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">   .....: </span>

<span class="gp">In [137]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]},</span> <span class="n">index</span><span class="o">=</span><span class="n">midx</span><span class="p">)</span>

<span class="gp">In [138]: </span><span class="n">df</span><span class="o">.</span><span class="n">to_panel</span><span class="p">()</span>
<span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">AttributeError</span><span class="g g-Whitespace">                            </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">138</span><span class="o">-</span><span class="mi">751669762</span><span class="n">b7a</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">df</span><span class="o">.</span><span class="n">to_panel</span><span class="p">()</span>

<span class="nn">~/miniconda/lib/python3.7/site-packages/pandas/core/generic.py</span> in <span class="ni">__getattr__</span><span class="nt">(self, name)</span>
<span class="g g-Whitespace">   </span><span class="mi">5178</span>             <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="o">.</span><span class="n">_can_hold_identifiers_and_holds_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
<span class="g g-Whitespace">   </span><span class="mi">5179</span>                 <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
<span class="ne">-&gt; </span><span class="mi">5180</span>             <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="g g-Whitespace">   </span><span class="mi">5181</span> 
<span class="g g-Whitespace">   </span><span class="mi">5182</span>     <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>

<span class="ne">AttributeError</span>: &#39;DataFrame&#39; object has no attribute &#39;to_panel&#39;
</pre></div>
</div>
</div>
<div class="section" id="item-selection-addition-deletion">
<span id="dsintro-panel-item-selection"></span><h3>Item selection / addition / deletion<a class="headerlink" href="#item-selection-addition-deletion" title="Permalink to this headline">¶</a></h3>
<p>Similar to DataFrame functioning as a dict of Series, Panel is like a dict
of DataFrames:</p>
<pre class="literal-block">In [139]: wp['Item1']
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-139-3af2e01ab74a&gt; in &lt;module&gt;
----&gt; 1 wp['Item1']

NameError: name 'wp' is not defined

In [140]: wp['Item3'] = wp['Item1'] / wp['Item2']
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-140-a08ed3c84db4&gt; in &lt;module&gt;
----&gt; 1 wp['Item3'] = wp['Item1'] / wp['Item2']

NameError: name 'wp' is not defined</pre>
<p>The API for insertion and deletion is the same as for DataFrame. And as with
DataFrame, if the item is a valid Python identifier, you can access it as an
attribute and tab-complete it in IPython.</p>
</div>
<div class="section" id="id1">
<h3>Transposing<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>A Panel can be rearranged using its <code class="docutils literal notranslate"><span class="pre">transpose</span></code> method (which does not make a
copy by default unless the data are heterogeneous):</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [141]: </span><span class="n">wp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">NameError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">141</span><span class="o">-</span><span class="mi">46</span><span class="n">c9d98db05a</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">wp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="ne">NameError</span>: name &#39;wp&#39; is not defined
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>Indexing / Selection<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 33%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operation</p></th>
<th class="head"><p>Syntax</p></th>
<th class="head"><p>Result</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Select item</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">wp[item]</span></code></p></td>
<td><p>DataFrame</p></td>
</tr>
<tr class="row-odd"><td><p>Get slice at major_axis label</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">wp.major_xs(val)</span></code></p></td>
<td><p>DataFrame</p></td>
</tr>
<tr class="row-even"><td><p>Get slice at minor_axis label</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">wp.minor_xs(val)</span></code></p></td>
<td><p>DataFrame</p></td>
</tr>
</tbody>
</table>
<p>For example, using the earlier example data, we could do:</p>
<pre class="literal-block">In [142]: wp['Item1']
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-142-3af2e01ab74a&gt; in &lt;module&gt;
----&gt; 1 wp['Item1']

NameError: name 'wp' is not defined

In [143]: wp.major_xs(wp.major_axis[2])
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-143-64f743c8b7ae&gt; in &lt;module&gt;
----&gt; 1 wp.major_xs(wp.major_axis[2])

NameError: name 'wp' is not defined

In [144]: wp.minor_axis
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-144-feec20f85984&gt; in &lt;module&gt;
----&gt; 1 wp.minor_axis

NameError: name 'wp' is not defined

In [145]: wp.minor_xs('C')
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-145-668e39a513f4&gt; in &lt;module&gt;
----&gt; 1 wp.minor_xs('C')

NameError: name 'wp' is not defined</pre>
</div>
<div class="section" id="squeezing">
<h3>Squeezing<a class="headerlink" href="#squeezing" title="Permalink to this headline">¶</a></h3>
<p>Another way to change the dimensionality of an object is to <code class="docutils literal notranslate"><span class="pre">squeeze</span></code> a 1-len
object, similar to <code class="docutils literal notranslate"><span class="pre">wp['Item1']</span></code>.</p>
<pre class="literal-block">In [146]: wp.reindex(items=['Item1']).squeeze()
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-146-1e6441d7f265&gt; in &lt;module&gt;
----&gt; 1 wp.reindex(items=['Item1']).squeeze()

NameError: name 'wp' is not defined

In [147]: wp.reindex(items=['Item1'], minor=['B']).squeeze()
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-147-bd0aa8a207b3&gt; in &lt;module&gt;
----&gt; 1 wp.reindex(items=['Item1'], minor=['B']).squeeze()

NameError: name 'wp' is not defined</pre>
</div>
<div class="section" id="conversion-to-dataframe">
<h3>Conversion to DataFrame<a class="headerlink" href="#conversion-to-dataframe" title="Permalink to this headline">¶</a></h3>
<p>A Panel can be represented in 2D form as a hierarchically indexed
DataFrame. See the section <a class="reference internal" href="../user_guide/advanced.html#advanced-hierarchical"><span class="std std-ref">hierarchical indexing</span></a>
for more on this. To convert a Panel to a DataFrame, use the <code class="docutils literal notranslate"><span class="pre">to_frame</span></code>
method:</p>
<pre class="literal-block">In [148]: panel = pd.Panel(np.random.randn(3, 5, 4), items=['one', 'two', 'three'],
   .....:                  major_axis=pd.date_range('1/1/2000', periods=5),
   .....:                  minor_axis=['a', 'b', 'c', 'd'])
   .....: 
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-148-a933acd2922a&gt; in &lt;module&gt;
      1 panel = pd.Panel(np.random.randn(3, 5, 4), items=['one', 'two', 'three'],
      2                  major_axis=pd.date_range('1/1/2000', periods=5),
----&gt; 3                  minor_axis=['a', 'b', 'c', 'd'])

TypeError: Panel() takes no arguments

In [149]: panel.to_frame()
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-149-2dde65174060&gt; in &lt;module&gt;
----&gt; 1 panel.to_frame()

NameError: name 'panel' is not defined</pre>
</div>
</div>
<div class="section" id="deprecate-panel">
<span id="dsintro-deprecate-panel"></span><h2>Deprecate Panel<a class="headerlink" href="#deprecate-panel" title="Permalink to this headline">¶</a></h2>
<p>Over the last few years, pandas has increased in both breadth and depth, with new features,
datatype support, and manipulation routines. As a result, supporting efficient indexing and functional
routines for <code class="docutils literal notranslate"><span class="pre">Series</span></code>, <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> and <code class="docutils literal notranslate"><span class="pre">Panel</span></code> has contributed to an increasingly fragmented and
difficult-to-understand code base.</p>
<p>The 3-D structure of a <code class="docutils literal notranslate"><span class="pre">Panel</span></code> is much less common for many types of data analysis,
than the 1-D of the <code class="docutils literal notranslate"><span class="pre">Series</span></code> or the 2-D of the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>. Going forward it makes sense for
pandas to focus on these areas exclusively.</p>
<p>Oftentimes, one can simply use a MultiIndex <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> for easily working with higher dimensional data.</p>
<p>In addition, the <code class="docutils literal notranslate"><span class="pre">xarray</span></code> package was built from the ground up, specifically in order to
support the multi-dimensional analysis that is one of <code class="docutils literal notranslate"><span class="pre">Panel</span></code> s main use cases.
<a class="reference external" href="https://xarray.pydata.org/en/stable/pandas.html#panel-transition">Here is a link to the xarray panel-transition documentation</a>.</p>
<pre class="literal-block">In [150]: import pandas.util.testing as tm

In [151]: p = tm.makePanel()
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-151-25f2efd9d6af&gt; in &lt;module&gt;
----&gt; 1 p = tm.makePanel()

AttributeError: module 'pandas.util.testing' has no attribute 'makePanel'

In [152]: p
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-152-6c10289a8da7&gt; in &lt;module&gt;
----&gt; 1 p

NameError: name 'p' is not defined</pre>
<p>Convert to a MultiIndex DataFrame.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [153]: </span><span class="n">p</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
<span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">NameError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">153</span><span class="o">-</span><span class="mf">05e486</span><span class="n">e4a129</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">p</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>

<span class="ne">NameError</span>: name &#39;p&#39; is not defined
</pre></div>
</div>
<p>Alternatively, one can convert to an xarray <code class="docutils literal notranslate"><span class="pre">DataArray</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [154]: </span><span class="n">p</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
<span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">NameError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">154</span><span class="o">-</span><span class="mi">21989</span><span class="n">fb4243c</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="n">p</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>

<span class="ne">NameError</span>: name &#39;p&#39; is not defined
</pre></div>
</div>
<p>You can see the full-documentation for the <a class="reference external" href="https://xarray.pydata.org/en/stable/">xarray package</a>.</p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../_sources/getting_started/dsintro.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2008-2014, the pandas development team.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>