<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Sparse data structures &#8212; pandas 0.25.0 documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/pandas_styles.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/carousel.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/pandas_logo.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.25.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../install.html">Install</a></li>
                <li><a href="../docs.html">Documentation</a></li>
                <li><a href="../community.html">Community</a></li>
            
            
              
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">Sparse data structures</a><ul>
<li><a class="reference internal" href="#sparse-accessor">Sparse Accessor</a></li>
<li><a class="reference internal" href="#sparsearray">SparseArray</a></li>
<li><a class="reference internal" href="#sparseindex-objects">SparseIndex objects</a></li>
<li><a class="reference internal" href="#sparse-dtypes">Sparse Dtypes</a></li>
<li><a class="reference internal" href="#sparse-calculation">Sparse Calculation</a></li>
<li><a class="reference internal" href="#interaction-with-scipy-sparse">Interaction with scipy.sparse</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    <div class="col-md-9 content">
      
  <div class="section" id="sparse-data-structures">
<h1>Sparse data structures<a class="headerlink" href="#sparse-data-structures" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">SparsePanel</span></code> class has been removed in 0.19.0</p>
</div>
<p>We have implemented “sparse” versions of <code class="docutils literal notranslate"><span class="pre">Series</span></code> and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>. These are not sparse
in the typical “mostly 0”. Rather, you can view these objects as being “compressed”
where any data matching a specific value (<code class="docutils literal notranslate"><span class="pre">NaN</span></code> / missing value, though any value
can be chosen) is omitted. A special <code class="docutils literal notranslate"><span class="pre">SparseIndex</span></code> object tracks where data has been
“sparsified”. This will make much more sense with an example. All of the standard pandas
data structures have a <code class="docutils literal notranslate"><span class="pre">to_sparse</span></code> method:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">ts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

<span class="gp">In [2]: </span><span class="n">ts</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

<span class="gp">In [3]: </span><span class="n">sts</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">to_sparse</span><span class="p">()</span>

<span class="gp">In [4]: </span><span class="n">sts</span>
<span class="gh">Out[4]: </span><span class="go"></span>
<span class="go">0    0.469112</span>
<span class="go">1   -0.282863</span>
<span class="go">2         NaN</span>
<span class="go">3         NaN</span>
<span class="go">4         NaN</span>
<span class="go">5         NaN</span>
<span class="go">6         NaN</span>
<span class="go">7         NaN</span>
<span class="go">8   -0.861849</span>
<span class="go">9   -2.104569</span>
<span class="go">dtype: Sparse[float64, nan]</span>
<span class="go">BlockIndex</span>
<span class="go">Block locations: array([0, 8], dtype=int32)</span>
<span class="go">Block lengths: array([2, 2], dtype=int32)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">to_sparse</span></code> method takes a <code class="docutils literal notranslate"><span class="pre">kind</span></code> argument (for the sparse index, see
below) and a <code class="docutils literal notranslate"><span class="pre">fill_value</span></code>. So if we had a mostly zero <code class="docutils literal notranslate"><span class="pre">Series</span></code>, we could
convert it to sparse with <code class="docutils literal notranslate"><span class="pre">fill_value=0</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="n">ts</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">to_sparse</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gh">Out[5]: </span><span class="go"></span>
<span class="go">0    0.469112</span>
<span class="go">1   -0.282863</span>
<span class="go">2    0.000000</span>
<span class="go">3    0.000000</span>
<span class="go">4    0.000000</span>
<span class="go">5    0.000000</span>
<span class="go">6    0.000000</span>
<span class="go">7    0.000000</span>
<span class="go">8   -0.861849</span>
<span class="go">9   -2.104569</span>
<span class="go">dtype: Sparse[float64, 0]</span>
<span class="go">BlockIndex</span>
<span class="go">Block locations: array([0, 8], dtype=int32)</span>
<span class="go">Block lengths: array([2, 2], dtype=int32)</span>
</pre></div>
</div>
<p>The sparse objects exist for memory efficiency reasons. Suppose you had a
large, mostly NA <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>:</p>
<pre class="literal-block">In [6]: df = pd.DataFrame(np.random.randn(10000, 4))

In [7]: df.iloc[:9998] = np.nan

In [8]: sdf = df.to_sparse()

In [9]: sdf
Out[9]: 
             0         1         2         3
0          NaN       NaN       NaN       NaN
1          NaN       NaN       NaN       NaN
2          NaN       NaN       NaN       NaN
3          NaN       NaN       NaN       NaN
4          NaN       NaN       NaN       NaN
...        ...       ...       ...       ...
9995       NaN       NaN       NaN       NaN
9996       NaN       NaN       NaN       NaN
9997       NaN       NaN       NaN       NaN
9998  0.509184 -0.774928 -1.369894 -0.382141
9999  0.280249 -1.648493  1.490865 -0.890819

[10000 rows x 4 columns]

In [10]: sdf.density
Out[10]: 0.0002</pre>
<p>As you can see, the density (% of values that have not been “compressed”) is
extremely low. This sparse object takes up much less memory on disk (pickled)
and in the Python interpreter. Functionally, their behavior should be nearly
identical to their dense counterparts.</p>
<p>Any sparse object can be converted back to the standard dense form by calling
<code class="docutils literal notranslate"><span class="pre">to_dense</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [11]: </span><span class="n">sts</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span>
<span class="gh">Out[11]: </span><span class="go"></span>
<span class="go">0    0.469112</span>
<span class="go">1   -0.282863</span>
<span class="go">2         NaN</span>
<span class="go">3         NaN</span>
<span class="go">4         NaN</span>
<span class="go">5         NaN</span>
<span class="go">6         NaN</span>
<span class="go">7         NaN</span>
<span class="go">8   -0.861849</span>
<span class="go">9   -2.104569</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<div class="section" id="sparse-accessor">
<span id="id1"></span><h2>Sparse Accessor<a class="headerlink" href="#sparse-accessor" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.0.</span></p>
</div>
<p>Pandas provides a <code class="docutils literal notranslate"><span class="pre">.sparse</span></code> accessor, similar to <code class="docutils literal notranslate"><span class="pre">.str</span></code> for string data, <code class="docutils literal notranslate"><span class="pre">.cat</span></code>
for categorical data, and <code class="docutils literal notranslate"><span class="pre">.dt</span></code> for datetime-like data. This namespace provides
attributes and methods that are specific to sparse data.</p>
<pre class="literal-block">In [12]: s = pd.Series([0, 0, 1, 2], dtype=&quot;Sparse[int]&quot;)

In [13]: s.sparse.density
Out[13]: 0.5

In [14]: s.sparse.fill_value
Out[14]: 0</pre>
<p>This accessor is available only on data with <code class="docutils literal notranslate"><span class="pre">SparseDtype</span></code>, and on the <a class="reference internal" href="../generated/pandas.Series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a>
class itself for creating a Series with sparse data from a scipy COO matrix with.</p>
</div>
<div class="section" id="sparsearray">
<span id="sparse-array"></span><h2>SparseArray<a class="headerlink" href="#sparsearray" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">SparseArray</span></code> is the base layer for all of the sparse indexed data
structures. It is a 1-dimensional ndarray-like object storing only values
distinct from the <code class="docutils literal notranslate"><span class="pre">fill_value</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [15]: </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="gp">In [16]: </span><span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

<span class="gp">In [17]: </span><span class="n">arr</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

<span class="gp">In [18]: </span><span class="n">sparr</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">SparseArray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

<span class="gp">In [19]: </span><span class="n">sparr</span>
<span class="gh">Out[19]: </span><span class="go"></span>
<span class="go">[-1.9556635297215477, -1.6588664275960427, nan, nan, nan, 1.1589328886422277, 0.14529711373305043, nan, 0.6060271905134522, 1.3342113401317768]</span>
<span class="go">Fill: nan</span>
<span class="go">IntIndex</span>
<span class="go">Indices: array([0, 1, 5, 6, 8, 9], dtype=int32)</span>
</pre></div>
</div>
<p>Like the indexed objects (SparseSeries, SparseDataFrame), a <code class="docutils literal notranslate"><span class="pre">SparseArray</span></code>
can be converted back to a regular ndarray by calling <code class="docutils literal notranslate"><span class="pre">to_dense</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [20]: </span><span class="n">sparr</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span>
<span class="gh">Out[20]: </span><span class="go"></span>
<span class="go">array([-1.9557, -1.6589,     nan,     nan,     nan,  1.1589,  0.1453,</span>
<span class="go">           nan,  0.606 ,  1.3342])</span>
</pre></div>
</div>
</div>
<div class="section" id="sparseindex-objects">
<h2>SparseIndex objects<a class="headerlink" href="#sparseindex-objects" title="Permalink to this headline">¶</a></h2>
<p>Two kinds of <code class="docutils literal notranslate"><span class="pre">SparseIndex</span></code> are implemented, <code class="docutils literal notranslate"><span class="pre">block</span></code> and <code class="docutils literal notranslate"><span class="pre">integer</span></code>. We
recommend using <code class="docutils literal notranslate"><span class="pre">block</span></code> as it’s more memory efficient. The <code class="docutils literal notranslate"><span class="pre">integer</span></code> format
keeps an arrays of all of the locations where the data are not equal to the
fill value. The <code class="docutils literal notranslate"><span class="pre">block</span></code> format tracks only the locations and sizes of blocks
of data.</p>
</div>
<div class="section" id="sparse-dtypes">
<span id="sparse-dtype"></span><h2>Sparse Dtypes<a class="headerlink" href="#sparse-dtypes" title="Permalink to this headline">¶</a></h2>
<p>Sparse data should have the same dtype as its dense representation. Currently,
<code class="docutils literal notranslate"><span class="pre">float64</span></code>, <code class="docutils literal notranslate"><span class="pre">int64</span></code> and <code class="docutils literal notranslate"><span class="pre">bool</span></code> dtypes are supported. Depending on the original
dtype, <code class="docutils literal notranslate"><span class="pre">fill_value</span></code> default changes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">float64</span></code>: <code class="docutils literal notranslate"><span class="pre">np.nan</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int64</span></code>: <code class="docutils literal notranslate"><span class="pre">0</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span></code>: <code class="docutils literal notranslate"><span class="pre">False</span></code></p></li>
</ul>
<pre class="literal-block">In [21]: s = pd.Series([1, np.nan, np.nan])

In [22]: s
Out[22]: 
0    1.0
1    NaN
2    NaN
dtype: float64

In [23]: s.to_sparse()
Out[23]: 
0    1.0
1    NaN
2    NaN
dtype: Sparse[float64, nan]
BlockIndex
Block locations: array([0], dtype=int32)
Block lengths: array([1], dtype=int32)

In [24]: s = pd.Series([1, 0, 0])

In [25]: s
Out[25]: 
0    1
1    0
2    0
dtype: int64

In [26]: s.to_sparse()
Out[26]: 
0    1
1    0
2    0
dtype: Sparse[int64, 0]
BlockIndex
Block locations: array([0], dtype=int32)
Block lengths: array([1], dtype=int32)

In [27]: s = pd.Series([True, False, True])

In [28]: s
Out[28]: 
0     True
1    False
2     True
dtype: bool

In [29]: s.to_sparse()
Out[29]: 
0     True
1    False
2     True
dtype: Sparse[bool, False]
BlockIndex
Block locations: array([0, 2], dtype=int32)
Block lengths: array([1, 1], dtype=int32)</pre>
<p>You can change the dtype using <code class="docutils literal notranslate"><span class="pre">.astype()</span></code>, the result is also sparse. Note that
<code class="docutils literal notranslate"><span class="pre">.astype()</span></code> also affects to the <code class="docutils literal notranslate"><span class="pre">fill_value</span></code> to keep its dense representation.</p>
<pre class="literal-block">In [30]: s = pd.Series([1, 0, 0, 0, 0])

In [31]: s
Out[31]: 
0    1
1    0
2    0
3    0
4    0
dtype: int64

In [32]: ss = s.to_sparse()

In [33]: ss
Out[33]: 
0    1
1    0
2    0
3    0
4    0
dtype: Sparse[int64, 0]
BlockIndex
Block locations: array([0], dtype=int32)
Block lengths: array([1], dtype=int32)

In [34]: ss.astype(np.float64)
Out[34]: 
0    1.0
1    0.0
2    0.0
3    0.0
4    0.0
dtype: Sparse[float64, 0.0]
BlockIndex
Block locations: array([0], dtype=int32)
Block lengths: array([1], dtype=int32)</pre>
<p>It raises if any value cannot be coerced to specified dtype.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">ss</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">to_sparse</span><span class="p">()</span>
<span class="go">0    1.0</span>
<span class="go">1    NaN</span>
<span class="go">2    NaN</span>
<span class="go">dtype: float64</span>
<span class="go">BlockIndex</span>
<span class="go">Block locations: array([0], dtype=int32)</span>
<span class="go">Block lengths: array([1], dtype=int32)</span>

<span class="gp">In [2]: </span><span class="n">ss</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
<span class="go">ValueError: unable to coerce current fill_value nan to int64 dtype</span>
</pre></div>
</div>
</div>
<div class="section" id="sparse-calculation">
<span id="id2"></span><h2>Sparse Calculation<a class="headerlink" href="#sparse-calculation" title="Permalink to this headline">¶</a></h2>
<p>You can apply NumPy <em>ufuncs</em> to <code class="docutils literal notranslate"><span class="pre">SparseArray</span></code> and get a <code class="docutils literal notranslate"><span class="pre">SparseArray</span></code> as a result.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [35]: </span><span class="n">arr</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">SparseArray</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>

<span class="gp">In [36]: </span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="gh">Out[36]: </span><span class="go"></span>
<span class="go">[1.0, nan, nan, 2.0, nan]</span>
<span class="go">Fill: nan</span>
<span class="go">IntIndex</span>
<span class="go">Indices: array([0, 3], dtype=int32)</span>
</pre></div>
</div>
<p>The <em>ufunc</em> is also applied to <code class="docutils literal notranslate"><span class="pre">fill_value</span></code>. This is needed to get
the correct dense result.</p>
<pre class="literal-block">In [37]: arr = pd.SparseArray([1., -1, -1, -2., -1], fill_value=-1)

In [38]: np.abs(arr)
Out[38]: 
[1.0, 1, 1, 2.0, 1]
Fill: 1
IntIndex
Indices: array([0, 3], dtype=int32)

In [39]: np.abs(arr).to_dense()
Out[39]: array([1., 1., 1., 2., 1.])</pre>
</div>
<div class="section" id="interaction-with-scipy-sparse">
<span id="sparse-scipysparse"></span><h2>Interaction with scipy.sparse<a class="headerlink" href="#interaction-with-scipy-sparse" title="Permalink to this headline">¶</a></h2>
<div class="section" id="sparsedataframe">
<h3>SparseDataFrame<a class="headerlink" href="#sparsedataframe" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.0.</span></p>
</div>
<p>Pandas supports creating sparse dataframes directly from <code class="docutils literal notranslate"><span class="pre">scipy.sparse</span></code> matrices.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [40]: </span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>

<span class="gp">In [41]: </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="gp">In [42]: </span><span class="n">arr</span><span class="p">[</span><span class="n">arr</span> <span class="o">&lt;</span> <span class="o">.</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="gp">In [43]: </span><span class="n">sp_arr</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

<span class="gp">In [44]: </span><span class="n">sp_arr</span>
<span class="gh">Out[44]: </span><span class="go"></span>
<span class="go">&lt;1000x5 sparse matrix of type &#39;&lt;class &#39;numpy.float64&#39;&gt;&#39;</span>
<span class="go">	with 517 stored elements in Compressed Sparse Row format&gt;</span>

<span class="gp">In [45]: </span><span class="n">sdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">SparseDataFrame</span><span class="p">(</span><span class="n">sp_arr</span><span class="p">)</span>

<span class="gp">In [46]: </span><span class="n">sdf</span>
<span class="gh">Out[46]: </span><span class="go"></span>
<span class="go">            0   1        2         3   4</span>
<span class="go">0    0.956380 NaN      NaN       NaN NaN</span>
<span class="go">1         NaN NaN      NaN       NaN NaN</span>
<span class="go">2         NaN NaN      NaN       NaN NaN</span>
<span class="go">3         NaN NaN      NaN       NaN NaN</span>
<span class="go">4    0.999552 NaN      NaN  0.956153 NaN</span>
<span class="go">..        ...  ..      ...       ...  ..</span>
<span class="go">995       NaN NaN      NaN  0.998834 NaN</span>
<span class="go">996       NaN NaN      NaN       NaN NaN</span>
<span class="go">997       NaN NaN      NaN       NaN NaN</span>
<span class="go">998       NaN NaN  0.95659       NaN NaN</span>
<span class="go">999       NaN NaN      NaN       NaN NaN</span>

<span class="go">[1000 rows x 5 columns]</span>
</pre></div>
</div>
<p>All sparse formats are supported, but matrices that are not in <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/sparse.html#module-scipy.sparse" title="(in SciPy v1.3.0)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">COOrdinate</span></code></a> format will be converted, copying data as needed.
To convert a <code class="docutils literal notranslate"><span class="pre">SparseDataFrame</span></code> back to sparse SciPy matrix in COO format, you can use the <a class="reference internal" href="../generated/pandas.SparseDataFrame.to_coo.html#pandas.SparseDataFrame.to_coo" title="pandas.SparseDataFrame.to_coo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SparseDataFrame.to_coo()</span></code></a> method:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [47]: </span><span class="n">sdf</span><span class="o">.</span><span class="n">to_coo</span><span class="p">()</span>
<span class="gh">Out[47]: </span><span class="go"></span>
<span class="go">&lt;1000x5 sparse matrix of type &#39;&lt;class &#39;numpy.float64&#39;&gt;&#39;</span>
<span class="go">	with 517 stored elements in COOrdinate format&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="sparseseries">
<h3>SparseSeries<a class="headerlink" href="#sparseseries" title="Permalink to this headline">¶</a></h3>
<p>A <a class="reference internal" href="../generated/pandas.SparseSeries.to_coo.html#pandas.SparseSeries.to_coo" title="pandas.SparseSeries.to_coo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SparseSeries.to_coo()</span></code></a> method is implemented for transforming a <code class="docutils literal notranslate"><span class="pre">SparseSeries</span></code> indexed by a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> to a <code class="docutils literal notranslate"><span class="pre">scipy.sparse.coo_matrix</span></code>.</p>
<p>The method requires a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> with two or more levels.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [48]: </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>

<span class="gp">In [49]: </span><span class="n">s</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">   ....: </span>                                     <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">   ....: </span>                                     <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">   ....: </span>                                     <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">   ....: </span>                                     <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">   ....: </span>                                     <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="gp">   ....: </span>                                    <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">])</span>
<span class="gp">   ....: </span>

<span class="gp">In [50]: </span><span class="n">s</span>
<span class="gh">Out[50]: </span><span class="go"></span>
<span class="go">A  B  C  D</span>
<span class="go">1  2  a  0    3.0</span>
<span class="go">         1    NaN</span>
<span class="go">   1  b  0    1.0</span>
<span class="go">         1    3.0</span>
<span class="go">2  1  b  0    NaN</span>
<span class="go">         1    NaN</span>
<span class="go">dtype: float64</span>

<span class="go"># SparseSeries</span>
<span class="gp">In [51]: </span><span class="n">ss</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">to_sparse</span><span class="p">()</span>

<span class="gp">In [52]: </span><span class="n">ss</span>
<span class="gh">Out[52]: </span><span class="go"></span>
<span class="go">A  B  C  D</span>
<span class="go">1  2  a  0    3.0</span>
<span class="go">         1    NaN</span>
<span class="go">   1  b  0    1.0</span>
<span class="go">         1    3.0</span>
<span class="go">2  1  b  0    NaN</span>
<span class="go">         1    NaN</span>
<span class="go">dtype: Sparse[float64, nan]</span>
<span class="go">BlockIndex</span>
<span class="go">Block locations: array([0, 2], dtype=int32)</span>
<span class="go">Block lengths: array([1, 2], dtype=int32)</span>
</pre></div>
</div>
<p>In the example below, we transform the <code class="docutils literal notranslate"><span class="pre">SparseSeries</span></code> to a sparse representation of a 2-d array by specifying that the first and second <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> levels define labels for the rows and the third and fourth levels define labels for the columns. We also specify that the column and row labels should be sorted in the final sparse representation.</p>
<pre class="literal-block">In [53]: A, rows, columns = ss.to_coo(row_levels=['A', 'B'],
   ....:                              column_levels=['C', 'D'],
   ....:                              sort_labels=True)
   ....: 

In [54]: A
Out[54]: 
&lt;3x4 sparse matrix of type '&lt;class 'numpy.float64'&gt;'
	with 3 stored elements in COOrdinate format&gt;

In [55]: A.todense()
Out[55]: 
matrix([[0., 0., 1., 3.],
        [3., 0., 0., 0.],
        [0., 0., 0., 0.]])

In [56]: rows
Out[56]: [(1, 1), (1, 2), (2, 1)]

In [57]: columns
Out[57]: [('a', 0), ('a', 1), ('b', 0), ('b', 1)]</pre>
<p>Specifying different row and column labels (and not sorting them) yields a different sparse matrix:</p>
<pre class="literal-block">In [58]: A, rows, columns = ss.to_coo(row_levels=['A', 'B', 'C'],
   ....:                              column_levels=['D'],
   ....:                              sort_labels=False)
   ....: 

In [59]: A
Out[59]: 
&lt;3x2 sparse matrix of type '&lt;class 'numpy.float64'&gt;'
	with 3 stored elements in COOrdinate format&gt;

In [60]: A.todense()
Out[60]: 
matrix([[3., 0.],
        [1., 3.],
        [0., 0.]])

In [61]: rows
Out[61]: [(1, 2, 'a'), (1, 1, 'b'), (2, 1, 'b')]

In [62]: columns
Out[62]: [0, 1]</pre>
<p>A convenience method <a class="reference internal" href="../generated/pandas.SparseSeries.from_coo.html#pandas.SparseSeries.from_coo" title="pandas.SparseSeries.from_coo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SparseSeries.from_coo()</span></code></a> is implemented for creating a <code class="docutils literal notranslate"><span class="pre">SparseSeries</span></code> from a <code class="docutils literal notranslate"><span class="pre">scipy.sparse.coo_matrix</span></code>.</p>
<pre class="literal-block">In [63]: from scipy import sparse

In [64]: A = sparse.coo_matrix(([3.0, 1.0, 2.0], ([1, 0, 0], [0, 2, 3])),
   ....:                       shape=(3, 4))
   ....: 

In [65]: A
Out[65]: 
&lt;3x4 sparse matrix of type '&lt;class 'numpy.float64'&gt;'
	with 3 stored elements in COOrdinate format&gt;

In [66]: A.todense()
Out[66]: 
matrix([[0., 0., 1., 2.],
        [3., 0., 0., 0.],
        [0., 0., 0., 0.]])</pre>
<p>The default behaviour (with <code class="docutils literal notranslate"><span class="pre">dense_index=False</span></code>) simply returns a <code class="docutils literal notranslate"><span class="pre">SparseSeries</span></code> containing
only the non-null entries.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [67]: </span><span class="n">ss</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">SparseSeries</span><span class="o">.</span><span class="n">from_coo</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

<span class="gp">In [68]: </span><span class="n">ss</span>
<span class="gh">Out[68]: </span><span class="go"></span>
<span class="go">0  2    1.0</span>
<span class="go">   3    2.0</span>
<span class="go">1  0    3.0</span>
<span class="go">dtype: Sparse[float64, nan]</span>
<span class="go">BlockIndex</span>
<span class="go">Block locations: array([0], dtype=int32)</span>
<span class="go">Block lengths: array([3], dtype=int32)</span>
</pre></div>
</div>
<p>Specifying <code class="docutils literal notranslate"><span class="pre">dense_index=True</span></code> will result in an index that is the Cartesian product of the
row and columns coordinates of the matrix. Note that this will consume a significant amount of memory
(relative to <code class="docutils literal notranslate"><span class="pre">dense_index=False</span></code>) if the sparse matrix is large (and sparse) enough.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [69]: </span><span class="n">ss_dense</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">SparseSeries</span><span class="o">.</span><span class="n">from_coo</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">dense_index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="gp">In [70]: </span><span class="n">ss_dense</span>
<span class="gh">Out[70]: </span><span class="go"></span>
<span class="go">0  0    NaN</span>
<span class="go">   1    NaN</span>
<span class="go">   2    1.0</span>
<span class="go">   3    2.0</span>
<span class="go">1  0    3.0</span>
<span class="go">   1    NaN</span>
<span class="go">   2    NaN</span>
<span class="go">   3    NaN</span>
<span class="go">2  0    NaN</span>
<span class="go">   1    NaN</span>
<span class="go">   2    NaN</span>
<span class="go">   3    NaN</span>
<span class="go">dtype: Sparse[float64, nan]</span>
<span class="go">BlockIndex</span>
<span class="go">Block locations: array([2], dtype=int32)</span>
<span class="go">Block lengths: array([3], dtype=int32)</span>
</pre></div>
</div>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../_sources/user_guide/sparse.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2008-2014, the pandas development team.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>