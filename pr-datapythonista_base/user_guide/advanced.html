<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>MultiIndex / Advanced Indexing &#8212; pandas 0.25.0 documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/pandas_styles.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/carousel.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/pandas_logo.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.25.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../install.html">Install</a></li>
                <li><a href="../docs.html">Documentation</a></li>
                <li><a href="../community.html">Community</a></li>
            
            
              
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">MultiIndex / Advanced Indexing</a><ul>
<li><a class="reference internal" href="#hierarchical-indexing-multiindex">Hierarchical indexing (MultiIndex)</a></li>
<li><a class="reference internal" href="#advanced-indexing-with-hierarchical-index">Advanced indexing with hierarchical index</a></li>
<li><a class="reference internal" href="#sorting-a-multiindex">Sorting a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code></a></li>
<li><a class="reference internal" href="#take-methods">Take Methods</a></li>
<li><a class="reference internal" href="#index-types">Index Types</a></li>
<li><a class="reference internal" href="#miscellaneous-indexing-faq">Miscellaneous indexing FAQ</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    <div class="col-md-9 content">
      
  <div class="section" id="multiindex-advanced-indexing">
<h1>MultiIndex / Advanced Indexing<a class="headerlink" href="#multiindex-advanced-indexing" title="Permalink to this headline">¶</a></h1>
<p>This section covers <a class="reference internal" href="#advanced-hierarchical"><span class="std std-ref">indexing with a MultiIndex</span></a>
and <a class="reference internal" href="#indexing-index-types"><span class="std std-ref">other advanced indexing features</span></a>.</p>
<p>See the <a class="reference internal" href="indexing.html#indexing"><span class="std std-ref">Indexing and Selecting Data</span></a> for general indexing documentation.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Whether a copy or a reference is returned for a setting operation may
depend on the context.  This is sometimes called <code class="docutils literal notranslate"><span class="pre">chained</span> <span class="pre">assignment</span></code> and
should be avoided.  See <a class="reference internal" href="indexing.html#indexing-view-versus-copy"><span class="std std-ref">Returning a View versus Copy</span></a>.</p>
</div>
<p>See the <a class="reference internal" href="../getting_started/cookbook.html#cookbook-selection"><span class="std std-ref">cookbook</span></a> for some advanced strategies.</p>
<div class="section" id="hierarchical-indexing-multiindex">
<span id="advanced-hierarchical"></span><h2>Hierarchical indexing (MultiIndex)<a class="headerlink" href="#hierarchical-indexing-multiindex" title="Permalink to this headline">¶</a></h2>
<p>Hierarchical / Multi-level indexing is very exciting as it opens the door to some
quite sophisticated data analysis and manipulation, especially for working with
higher dimensional data. In essence, it enables you to store and manipulate
data with an arbitrary number of dimensions in lower dimensional data
structures like <code class="docutils literal notranslate"><span class="pre">Series</span></code> (1d) and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> (2d).</p>
<p>In this section, we will show what exactly we mean by “hierarchical” indexing
and how it integrates with all of the pandas indexing functionality
described above and in prior sections. Later, when discussing <a class="reference internal" href="groupby.html#groupby"><span class="std std-ref">group by</span></a> and <a class="reference internal" href="reshaping.html#reshaping"><span class="std std-ref">pivoting and reshaping data</span></a>, we’ll show
non-trivial applications to illustrate how it aids in structuring data for
analysis.</p>
<p>See the <a class="reference internal" href="../getting_started/cookbook.html#cookbook-multi-index"><span class="std std-ref">cookbook</span></a> for some advanced strategies.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.24.0: </span><code class="xref py py-attr docutils literal notranslate"><span class="pre">MultiIndex.labels</span></code> has been renamed to <a class="reference internal" href="../generated/pandas.MultiIndex.codes.html#pandas.MultiIndex.codes" title="pandas.MultiIndex.codes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">MultiIndex.codes</span></code></a>
and <code class="xref py py-attr docutils literal notranslate"><span class="pre">MultiIndex.set_labels</span></code> to <a class="reference internal" href="../generated/pandas.MultiIndex.set_codes.html#pandas.MultiIndex.set_codes" title="pandas.MultiIndex.set_codes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">MultiIndex.set_codes</span></code></a>.</p>
</div>
<div class="section" id="creating-a-multiindex-hierarchical-index-object">
<h3>Creating a MultiIndex (hierarchical index) object<a class="headerlink" href="#creating-a-multiindex-hierarchical-index-object" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../generated/pandas.MultiIndex.html#pandas.MultiIndex" title="pandas.MultiIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiIndex</span></code></a> object is the hierarchical analogue of the standard
<a class="reference internal" href="../generated/pandas.Index.html#pandas.Index" title="pandas.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a> object which typically stores the axis labels in pandas objects. You
can think of <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> as an array of tuples where each tuple is unique. A
<code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> can be created from a list of arrays (using
<a class="reference internal" href="../generated/pandas.MultiIndex.from_arrays.html#pandas.MultiIndex.from_arrays" title="pandas.MultiIndex.from_arrays"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_arrays()</span></code></a>), an array of tuples (using
<a class="reference internal" href="../generated/pandas.MultiIndex.from_tuples.html#pandas.MultiIndex.from_tuples" title="pandas.MultiIndex.from_tuples"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_tuples()</span></code></a>), a crossed set of iterables (using
<a class="reference internal" href="../generated/pandas.MultiIndex.from_product.html#pandas.MultiIndex.from_product" title="pandas.MultiIndex.from_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_product()</span></code></a>), or a <a class="reference internal" href="../generated/pandas.DataFrame.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> (using
<a class="reference internal" href="../generated/pandas.MultiIndex.from_frame.html#pandas.MultiIndex.from_frame" title="pandas.MultiIndex.from_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_frame()</span></code></a>).  The <code class="docutils literal notranslate"><span class="pre">Index</span></code> constructor will attempt to return
a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> when it is passed a list of tuples.  The following examples
demonstrate different ways to initialize MultiIndexes.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">arrays</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">],</span>
<span class="gp">   ...: </span>          <span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">]]</span>
<span class="gp">   ...: </span>

<span class="gp">In [2]: </span><span class="n">tuples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">))</span>

<span class="gp">In [3]: </span><span class="n">tuples</span>
<span class="gh">Out[3]: </span><span class="go"></span>
<span class="go">[(&#39;bar&#39;, &#39;one&#39;),</span>
<span class="go"> (&#39;bar&#39;, &#39;two&#39;),</span>
<span class="go"> (&#39;baz&#39;, &#39;one&#39;),</span>
<span class="go"> (&#39;baz&#39;, &#39;two&#39;),</span>
<span class="go"> (&#39;foo&#39;, &#39;one&#39;),</span>
<span class="go"> (&#39;foo&#39;, &#39;two&#39;),</span>
<span class="go"> (&#39;qux&#39;, &#39;one&#39;),</span>
<span class="go"> (&#39;qux&#39;, &#39;two&#39;)]</span>

<span class="gp">In [4]: </span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">tuples</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;second&#39;</span><span class="p">])</span>

<span class="gp">In [5]: </span><span class="n">index</span>
<span class="gh">Out[5]: </span><span class="go"></span>
<span class="go">MultiIndex([(&#39;bar&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;bar&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;baz&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;baz&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;qux&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;qux&#39;, &#39;two&#39;)],</span>
<span class="go">           names=[&#39;first&#39;, &#39;second&#39;])</span>

<span class="gp">In [6]: </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

<span class="gp">In [7]: </span><span class="n">s</span>
<span class="gh">Out[7]: </span><span class="go"></span>
<span class="go">first  second</span>
<span class="go">bar    one       0.469112</span>
<span class="go">       two      -0.282863</span>
<span class="go">baz    one      -1.509059</span>
<span class="go">       two      -1.135632</span>
<span class="go">foo    one       1.212112</span>
<span class="go">       two      -0.173215</span>
<span class="go">qux    one       0.119209</span>
<span class="go">       two      -1.044236</span>
<span class="go">Length: 8, dtype: float64</span>
</pre></div>
</div>
<p>When you want every pairing of the elements in two iterables, it can be easier
to use the <a class="reference internal" href="../generated/pandas.MultiIndex.from_product.html#pandas.MultiIndex.from_product" title="pandas.MultiIndex.from_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_product()</span></code></a> method:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [8]: </span><span class="n">iterables</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">]]</span>

<span class="gp">In [9]: </span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">(</span><span class="n">iterables</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;second&#39;</span><span class="p">])</span>
<span class="gh">Out[9]: </span><span class="go"></span>
<span class="go">MultiIndex([(&#39;bar&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;bar&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;baz&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;baz&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;qux&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;qux&#39;, &#39;two&#39;)],</span>
<span class="go">           names=[&#39;first&#39;, &#39;second&#39;])</span>
</pre></div>
</div>
<p>You can also construct a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> from a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> directly, using
the method <a class="reference internal" href="../generated/pandas.MultiIndex.from_frame.html#pandas.MultiIndex.from_frame" title="pandas.MultiIndex.from_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_frame()</span></code></a>. This is a complementary method to
<a class="reference internal" href="../generated/pandas.MultiIndex.to_frame.html#pandas.MultiIndex.to_frame" title="pandas.MultiIndex.to_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.to_frame()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.0.</span></p>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [10]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">],</span>
<span class="gp">   ....: </span>                   <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">]],</span>
<span class="gp">   ....: </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;second&#39;</span><span class="p">])</span>
<span class="gp">   ....: </span>

<span class="gp">In [11]: </span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_frame</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="gh">Out[11]: </span><span class="go"></span>
<span class="go">MultiIndex([(&#39;bar&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;bar&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;two&#39;)],</span>
<span class="go">           names=[&#39;first&#39;, &#39;second&#39;])</span>
</pre></div>
</div>
<p>As a convenience, you can pass a list of arrays directly into <code class="docutils literal notranslate"><span class="pre">Series</span></code> or
<code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> to construct a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> automatically:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [12]: </span><span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">]),</span>
<span class="gp">   ....: </span>          <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">])]</span>
<span class="gp">   ....: </span>

<span class="gp">In [13]: </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">arrays</span><span class="p">)</span>

<span class="gp">In [14]: </span><span class="n">s</span>
<span class="gh">Out[14]: </span><span class="go"></span>
<span class="go">bar  one   -0.861849</span>
<span class="go">     two   -2.104569</span>
<span class="go">baz  one   -0.494929</span>
<span class="go">     two    1.071804</span>
<span class="go">foo  one    0.721555</span>
<span class="go">     two   -0.706771</span>
<span class="go">qux  one   -1.039575</span>
<span class="go">     two    0.271860</span>
<span class="go">Length: 8, dtype: float64</span>

<span class="gp">In [15]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">arrays</span><span class="p">)</span>

<span class="gp">In [16]: </span><span class="n">df</span>
<span class="gh">Out[16]: </span><span class="go"></span>
<span class="go">                0         1         2         3</span>
<span class="go">bar one -0.424972  0.567020  0.276232 -1.087401</span>
<span class="go">    two -0.673690  0.113648 -1.478427  0.524988</span>
<span class="go">baz one  0.404705  0.577046 -1.715002 -1.039268</span>
<span class="go">    two -0.370647 -1.157892 -1.344312  0.844885</span>
<span class="go">foo one  1.075770 -0.109050  1.643563 -1.469388</span>
<span class="go">    two  0.357021 -0.674600 -1.776904 -0.968914</span>
<span class="go">qux one -1.294524  0.413738  0.276662 -0.472035</span>
<span class="go">    two -0.013960 -0.362543 -0.006154 -0.923061</span>

<span class="go">[8 rows x 4 columns]</span>
</pre></div>
</div>
<p>All of the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> constructors accept a <code class="docutils literal notranslate"><span class="pre">names</span></code> argument which stores
string names for the levels themselves. If no names are provided, <code class="docutils literal notranslate"><span class="pre">None</span></code> will
be assigned:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [17]: </span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span>
<span class="gh">Out[17]: </span><span class="go">FrozenList([None, None])</span>
</pre></div>
</div>
<p>This index can back any axis of a pandas object, and the number of <strong>levels</strong>
of the index is up to you:</p>
<pre class="literal-block">In [18]: df = pd.DataFrame(np.random.randn(3, 8), index=['A', 'B', 'C'], columns=index)

In [19]: df
Out[19]: 
first        bar                 baz  ...       foo       qux          
second       one       two       one  ...       two       one       two
A       0.895717  0.805244 -1.206412  ...  1.340309 -1.170299 -0.226169
B       0.410835  0.813850  0.132003  ... -1.187678  1.130127 -1.436737
C      -1.413681  1.607920  1.024180  ... -2.211372  0.974466 -2.006747

[3 rows x 8 columns]

In [20]: pd.DataFrame(np.random.randn(6, 6), index=index[:6], columns=index[:6])
Out[20]: 
first              bar                 baz                 foo          
second             one       two       one       two       one       two
first second                                                            
bar   one    -0.410001 -0.078638  0.545952 -1.219217 -1.226825  0.769804
      two    -1.281247 -0.727707 -0.121306 -0.097883  0.695775  0.341734
baz   one     0.959726 -1.110336 -0.619976  0.149748 -0.732339  0.687738
      two     0.176444  0.403310 -0.154951  0.301624 -2.179861 -1.369849
foo   one    -0.954208  1.462696 -1.743161 -0.826591 -0.345352  1.314232
      two     0.690579  0.995761  2.396780  0.014871  3.357427 -0.317441

[6 rows x 6 columns]</pre>
<p>We’ve “sparsified” the higher levels of the indexes to make the console output a
bit easier on the eyes. Note that how the index is displayed can be controlled using the
<code class="docutils literal notranslate"><span class="pre">multi_sparse</span></code> option in <code class="docutils literal notranslate"><span class="pre">pandas.set_options()</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [21]: </span><span class="k">with</span> <span class="n">pd</span><span class="o">.</span><span class="n">option_context</span><span class="p">(</span><span class="s1">&#39;display.multi_sparse&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="n">df</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<p>It’s worth keeping in mind that there’s nothing preventing you from using
tuples as atomic labels on an axis:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [22]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">tuples</span><span class="p">)</span>
<span class="gh">Out[22]: </span><span class="go"></span>
<span class="go">(bar, one)   -1.236269</span>
<span class="go">(bar, two)    0.896171</span>
<span class="go">(baz, one)   -0.487602</span>
<span class="go">(baz, two)   -0.082240</span>
<span class="go">(foo, one)   -2.182937</span>
<span class="go">(foo, two)    0.380396</span>
<span class="go">(qux, one)    0.084844</span>
<span class="go">(qux, two)    0.432390</span>
<span class="go">Length: 8, dtype: float64</span>
</pre></div>
</div>
<p>The reason that the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> matters is that it can allow you to do
grouping, selection, and reshaping operations as we will describe below and in
subsequent areas of the documentation. As you will see in later sections, you
can find yourself working with hierarchically-indexed data without creating a
<code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> explicitly yourself. However, when loading data from a file, you
may wish to generate your own <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> when preparing the data set.</p>
</div>
<div class="section" id="reconstructing-the-level-labels">
<span id="advanced-get-level-values"></span><h3>Reconstructing the level labels<a class="headerlink" href="#reconstructing-the-level-labels" title="Permalink to this headline">¶</a></h3>
<p>The method <a class="reference internal" href="../generated/pandas.MultiIndex.get_level_values.html#pandas.MultiIndex.get_level_values" title="pandas.MultiIndex.get_level_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_level_values()</span></code></a> will return a vector of the labels for each
location at a particular level:</p>
<pre class="literal-block">In [23]: index.get_level_values(0)
Out[23]: Index(['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux'], dtype='object', name='first')

In [24]: index.get_level_values('second')
Out[24]: Index(['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two'], dtype='object', name='second')</pre>
</div>
<div class="section" id="basic-indexing-on-axis-with-multiindex">
<h3>Basic indexing on axis with MultiIndex<a class="headerlink" href="#basic-indexing-on-axis-with-multiindex" title="Permalink to this headline">¶</a></h3>
<p>One of the important features of hierarchical indexing is that you can select
data by a “partial” label identifying a subgroup in the data. <strong>Partial</strong>
selection “drops” levels of the hierarchical index in the result in a
completely analogous way to selecting a column in a regular DataFrame:</p>
<pre class="literal-block">In [25]: df['bar']
Out[25]: 
second       one       two
A       0.895717  0.805244
B       0.410835  0.813850
C      -1.413681  1.607920

[3 rows x 2 columns]

In [26]: df['bar', 'one']
Out[26]: 
A    0.895717
B    0.410835
C   -1.413681
Name: (bar, one), Length: 3, dtype: float64

In [27]: df['bar']['one']
Out[27]: 
A    0.895717
B    0.410835
C   -1.413681
Name: one, Length: 3, dtype: float64

In [28]: s['qux']
Out[28]: 
one   -1.039575
two    0.271860
Length: 2, dtype: float64</pre>
<p>See <a class="reference internal" href="#advanced-xs"><span class="std std-ref">Cross-section with hierarchical index</span></a> for how to select
on a deeper level.</p>
</div>
<div class="section" id="defined-levels">
<span id="advanced-shown-levels"></span><h3>Defined Levels<a class="headerlink" href="#defined-levels" title="Permalink to this headline">¶</a></h3>
<p>The repr of a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> shows all the defined levels of an index, even
if they are not actually used. When slicing an index, you may notice this.
For example:</p>
<pre class="literal-block">In [29]: df.columns  # original MultiIndex
Out[29]: 
MultiIndex([('bar', 'one'),
            ('bar', 'two'),
            ('baz', 'one'),
            ('baz', 'two'),
            ('foo', 'one'),
            ('foo', 'two'),
            ('qux', 'one'),
            ('qux', 'two')],
           names=['first', 'second'])

In [30]: df[['foo','qux']].columns  # sliced
Out[30]: 
MultiIndex([('foo', 'one'),
            ('foo', 'two'),
            ('qux', 'one'),
            ('qux', 'two')],
           names=['first', 'second'])</pre>
<p>This is done to avoid a recomputation of the levels in order to make slicing
highly performant. If you want to see only the used levels, you can use the
<a class="reference internal" href="../generated/pandas.MultiIndex.get_level_values.html#pandas.MultiIndex.get_level_values" title="pandas.MultiIndex.get_level_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_level_values()</span></code></a> method.</p>
<pre class="literal-block">In [31]: df[['foo', 'qux']].columns.to_numpy()
Out[31]: 
array([('foo', 'one'), ('foo', 'two'), ('qux', 'one'), ('qux', 'two')],
      dtype=object)

# for a specific level
In [32]: df[['foo', 'qux']].columns.get_level_values(0)
Out[32]: Index(['foo', 'foo', 'qux', 'qux'], dtype='object', name='first')</pre>
<p>To reconstruct the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> with only the used levels, the
<a class="reference internal" href="../generated/pandas.MultiIndex.remove_unused_levels.html#pandas.MultiIndex.remove_unused_levels" title="pandas.MultiIndex.remove_unused_levels"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remove_unused_levels()</span></code></a> method may be used.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.0.</span></p>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [33]: </span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">remove_unused_levels</span><span class="p">()</span>
<span class="gh">Out[33]: </span><span class="go"></span>
<span class="go">MultiIndex([(&#39;foo&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;qux&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;qux&#39;, &#39;two&#39;)],</span>
<span class="go">           names=[&#39;first&#39;, &#39;second&#39;])</span>
</pre></div>
</div>
</div>
<div class="section" id="data-alignment-and-using-reindex">
<h3>Data alignment and using <code class="docutils literal notranslate"><span class="pre">reindex</span></code><a class="headerlink" href="#data-alignment-and-using-reindex" title="Permalink to this headline">¶</a></h3>
<p>Operations between differently-indexed objects having <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> on the
axes will work as you expect; data alignment will work the same as an Index of
tuples:</p>
<pre class="literal-block">In [34]: s + s[:-2]
Out[34]: 
bar  one   -1.723698
     two   -4.209138
baz  one   -0.989859
     two    2.143608
foo  one    1.443110
     two   -1.413542
qux  one         NaN
     two         NaN
Length: 8, dtype: float64

In [35]: s + s[::2]
Out[35]: 
bar  one   -1.723698
     two         NaN
baz  one   -0.989859
     two         NaN
foo  one    1.443110
     two         NaN
qux  one   -2.079150
     two         NaN
Length: 8, dtype: float64</pre>
<p>The <a class="reference internal" href="../generated/pandas.DataFrame.reindex.html#pandas.DataFrame.reindex" title="pandas.DataFrame.reindex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reindex()</span></code></a> method of <code class="docutils literal notranslate"><span class="pre">Series</span></code>/<code class="docutils literal notranslate"><span class="pre">DataFrames</span></code> can be
called with another <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>, or even a list or array of tuples:</p>
<pre class="literal-block">In [36]: s.reindex(index[:3])
Out[36]: 
first  second
bar    one      -0.861849
       two      -2.104569
baz    one      -0.494929
Length: 3, dtype: float64

In [37]: s.reindex([('foo', 'two'), ('bar', 'one'), ('qux', 'one'), ('baz', 'one')])
Out[37]: 
foo  two   -0.706771
bar  one   -0.861849
qux  one   -1.039575
baz  one   -0.494929
Length: 4, dtype: float64</pre>
</div>
</div>
<div class="section" id="advanced-indexing-with-hierarchical-index">
<span id="advanced-advanced-hierarchical"></span><h2>Advanced indexing with hierarchical index<a class="headerlink" href="#advanced-indexing-with-hierarchical-index" title="Permalink to this headline">¶</a></h2>
<p>Syntactically integrating <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> in advanced indexing with <code class="docutils literal notranslate"><span class="pre">.loc</span></code> is a
bit challenging, but we’ve made every effort to do so. In general, MultiIndex
keys take the form of tuples. For example, the following works as you would expect:</p>
<pre class="literal-block">In [38]: df = df.T

In [39]: df
Out[39]: 
                     A         B         C
first second                              
bar   one     0.895717  0.410835 -1.413681
      two     0.805244  0.813850  1.607920
baz   one    -1.206412  0.132003  1.024180
      two     2.565646 -0.827317  0.569605
foo   one     1.431256 -0.076467  0.875906
      two     1.340309 -1.187678 -2.211372
qux   one    -1.170299  1.130127  0.974466
      two    -0.226169 -1.436737 -2.006747

[8 rows x 3 columns]

In [40]: df.loc[('bar', 'two')]
Out[40]: 
A    0.805244
B    0.813850
C    1.607920
Name: (bar, two), Length: 3, dtype: float64</pre>
<p>Note that <code class="docutils literal notranslate"><span class="pre">df.loc['bar',</span> <span class="pre">'two']</span></code> would also work in this example, but this shorthand
notation can lead to ambiguity in general.</p>
<p>If you also want to index a specific column with <code class="docutils literal notranslate"><span class="pre">.loc</span></code>, you must use a tuple
like this:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [41]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">),</span> <span class="s1">&#39;A&#39;</span><span class="p">]</span>
<span class="gh">Out[41]: </span><span class="go">0.8052440253863785</span>
</pre></div>
</div>
<p>You don’t have to specify all levels of the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> by passing only the
first elements of the tuple. For example, you can use “partial” indexing to
get all elements with <code class="docutils literal notranslate"><span class="pre">bar</span></code> in the first level as follows:</p>
<p>df.loc[‘bar’]</p>
<p>This is a shortcut for the slightly more verbose notation <code class="docutils literal notranslate"><span class="pre">df.loc[('bar',),]</span></code> (equivalent
to <code class="docutils literal notranslate"><span class="pre">df.loc['bar',]</span></code> in this example).</p>
<p>“Partial” slicing also works quite nicely.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [42]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;baz&#39;</span><span class="p">:</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span>
<span class="gh">Out[42]: </span><span class="go"></span>
<span class="go">                     A         B         C</span>
<span class="go">first second                              </span>
<span class="go">baz   one    -1.206412  0.132003  1.024180</span>
<span class="go">      two     2.565646 -0.827317  0.569605</span>
<span class="go">foo   one     1.431256 -0.076467  0.875906</span>
<span class="go">      two     1.340309 -1.187678 -2.211372</span>

<span class="go">[4 rows x 3 columns]</span>
</pre></div>
</div>
<p>You can slice with a ‘range’ of values, by providing a slice of tuples.</p>
<pre class="literal-block">In [43]: df.loc[('baz', 'two'):('qux', 'one')]
Out[43]: 
                     A         B         C
first second                              
baz   two     2.565646 -0.827317  0.569605
foo   one     1.431256 -0.076467  0.875906
      two     1.340309 -1.187678 -2.211372
qux   one    -1.170299  1.130127  0.974466

[4 rows x 3 columns]

In [44]: df.loc[('baz', 'two'):'foo']
Out[44]: 
                     A         B         C
first second                              
baz   two     2.565646 -0.827317  0.569605
foo   one     1.431256 -0.076467  0.875906
      two     1.340309 -1.187678 -2.211372

[3 rows x 3 columns]</pre>
<p>Passing a list of labels or tuples works similar to reindexing:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [45]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[[(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;qux&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">)]]</span>
<span class="gh">Out[45]: </span><span class="go"></span>
<span class="go">                     A         B         C</span>
<span class="go">first second                              </span>
<span class="go">bar   two     0.805244  0.813850  1.607920</span>
<span class="go">qux   one    -1.170299  1.130127  0.974466</span>

<span class="go">[2 rows x 3 columns]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is important to note that tuples and lists are not treated identically
in pandas when it comes to indexing. Whereas a tuple is interpreted as one
multi-level key, a list is used to specify several keys. Or in other words,
tuples go horizontally (traversing levels), lists go vertically (scanning levels).</p>
</div>
<p>Importantly, a list of tuples indexes several complete <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> keys,
whereas a tuple of lists refer to several values within a level:</p>
<pre class="literal-block">In [46]: s = pd.Series([1, 2, 3, 4, 5, 6],
   ....:               index=pd.MultiIndex.from_product([[&quot;A&quot;, &quot;B&quot;], [&quot;c&quot;, &quot;d&quot;, &quot;e&quot;]]))
   ....: 

In [47]: s.loc[[(&quot;A&quot;, &quot;c&quot;), (&quot;B&quot;, &quot;d&quot;)]]  # list of tuples
Out[47]: 
A  c    1
B  d    5
Length: 2, dtype: int64

In [48]: s.loc[([&quot;A&quot;, &quot;B&quot;], [&quot;c&quot;, &quot;d&quot;])]  # tuple of lists
Out[48]: 
A  c    1
   d    2
B  c    4
   d    5
Length: 4, dtype: int64</pre>
<div class="section" id="using-slicers">
<span id="advanced-mi-slicers"></span><h3>Using slicers<a class="headerlink" href="#using-slicers" title="Permalink to this headline">¶</a></h3>
<p>You can slice a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> by providing multiple indexers.</p>
<p>You can provide any of the selectors as if you are indexing by label, see <a class="reference internal" href="indexing.html#indexing-label"><span class="std std-ref">Selection by Label</span></a>,
including slices, lists of labels, labels, and boolean indexers.</p>
<p>You can use <code class="docutils literal notranslate"><span class="pre">slice(None)</span></code> to select all the contents of <em>that</em> level. You do not need to specify all the
<em>deeper</em> levels, they will be implied as <code class="docutils literal notranslate"><span class="pre">slice(None)</span></code>.</p>
<p>As usual, <strong>both sides</strong> of the slicers are included as this is label indexing.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You should specify all axes in the <code class="docutils literal notranslate"><span class="pre">.loc</span></code> specifier, meaning the indexer for the <strong>index</strong> and
for the <strong>columns</strong>. There are some ambiguous cases where the passed indexer could be mis-interpreted
as indexing <em>both</em> axes, rather than into say the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> for the rows.</p>
<p>You should do this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="s1">&#39;A1&#39;</span><span class="p">,</span> <span class="s1">&#39;A3&#39;</span><span class="p">),</span> <span class="o">...</span><span class="p">),</span> <span class="p">:]</span>             <span class="c1"># noqa: E999</span>
</pre></div>
</div>
<p>You should <strong>not</strong> do this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="s1">&#39;A1&#39;</span><span class="p">,</span> <span class="s1">&#39;A3&#39;</span><span class="p">),</span> <span class="o">...</span><span class="p">)]</span>                <span class="c1"># noqa: E999</span>
</pre></div>
</div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [49]: </span><span class="k">def</span> <span class="nf">mklbl</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
<span class="gp">   ....: </span>

<span class="gp">In [50]: </span><span class="n">miindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="n">mklbl</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
<span class="gp">   ....: </span>                                      <span class="n">mklbl</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">   ....: </span>                                      <span class="n">mklbl</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
<span class="gp">   ....: </span>                                      <span class="n">mklbl</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">   ....: </span>

<span class="gp">In [51]: </span><span class="n">micolumns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">([(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">),</span>
<span class="gp">   ....: </span>                                       <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;bah&#39;</span><span class="p">)],</span>
<span class="gp">   ....: </span>                                      <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;lvl0&#39;</span><span class="p">,</span> <span class="s1">&#39;lvl1&#39;</span><span class="p">])</span>
<span class="gp">   ....: </span>

<span class="gp">In [52]: </span><span class="n">dfmi</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">miindex</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">micolumns</span><span class="p">))</span>
<span class="gp">   ....: </span>                      <span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">miindex</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">micolumns</span><span class="p">))),</span>
<span class="gp">   ....: </span>                    <span class="n">index</span><span class="o">=</span><span class="n">miindex</span><span class="p">,</span>
<span class="gp">   ....: </span>                    <span class="n">columns</span><span class="o">=</span><span class="n">micolumns</span><span class="p">)</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">   ....: </span>

<span class="gp">In [53]: </span><span class="n">dfmi</span>
<span class="gh">Out[53]: </span><span class="go"></span>
<span class="go">lvl0           a         b     </span>
<span class="go">lvl1         bar  foo  bah  foo</span>
<span class="go">A0 B0 C0 D0    1    0    3    2</span>
<span class="go">         D1    5    4    7    6</span>
<span class="go">      C1 D0    9    8   11   10</span>
<span class="go">         D1   13   12   15   14</span>
<span class="go">      C2 D0   17   16   19   18</span>
<span class="go">...          ...  ...  ...  ...</span>
<span class="go">A3 B1 C1 D1  237  236  239  238</span>
<span class="go">      C2 D0  241  240  243  242</span>
<span class="go">         D1  245  244  247  246</span>
<span class="go">      C3 D0  249  248  251  250</span>
<span class="go">         D1  253  252  255  254</span>

<span class="go">[64 rows x 4 columns]</span>
</pre></div>
</div>
<p>Basic MultiIndex slicing using slices, lists, and labels.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [54]: </span><span class="n">dfmi</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="s1">&#39;A1&#39;</span><span class="p">,</span> <span class="s1">&#39;A3&#39;</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">]),</span> <span class="p">:]</span>
<span class="gh">Out[54]: </span><span class="go"></span>
<span class="go">lvl0           a         b     </span>
<span class="go">lvl1         bar  foo  bah  foo</span>
<span class="go">A1 B0 C1 D0   73   72   75   74</span>
<span class="go">         D1   77   76   79   78</span>
<span class="go">      C3 D0   89   88   91   90</span>
<span class="go">         D1   93   92   95   94</span>
<span class="go">   B1 C1 D0  105  104  107  106</span>
<span class="go">...          ...  ...  ...  ...</span>
<span class="go">A3 B0 C3 D1  221  220  223  222</span>
<span class="go">   B1 C1 D0  233  232  235  234</span>
<span class="go">         D1  237  236  239  238</span>
<span class="go">      C3 D0  249  248  251  250</span>
<span class="go">         D1  253  252  255  254</span>

<span class="go">[24 rows x 4 columns]</span>
</pre></div>
</div>
<p>You can use <a class="reference internal" href="../generated/pandas.IndexSlice.html#pandas.IndexSlice" title="pandas.IndexSlice"><code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.IndexSlice</span></code></a> to facilitate a more natural syntax
using <code class="docutils literal notranslate"><span class="pre">:</span></code>, rather than using <code class="docutils literal notranslate"><span class="pre">slice(None)</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [55]: </span><span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">IndexSlice</span>

<span class="gp">In [56]: </span><span class="n">dfmi</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">]],</span> <span class="n">idx</span><span class="p">[:,</span> <span class="s1">&#39;foo&#39;</span><span class="p">]]</span>
<span class="gh">Out[56]: </span><span class="go"></span>
<span class="go">lvl0           a    b</span>
<span class="go">lvl1         foo  foo</span>
<span class="go">A0 B0 C1 D0    8   10</span>
<span class="go">         D1   12   14</span>
<span class="go">      C3 D0   24   26</span>
<span class="go">         D1   28   30</span>
<span class="go">   B1 C1 D0   40   42</span>
<span class="go">...          ...  ...</span>
<span class="go">A3 B0 C3 D1  220  222</span>
<span class="go">   B1 C1 D0  232  234</span>
<span class="go">         D1  236  238</span>
<span class="go">      C3 D0  248  250</span>
<span class="go">         D1  252  254</span>

<span class="go">[32 rows x 2 columns]</span>
</pre></div>
</div>
<p>It is possible to perform quite complicated selections using this method on multiple
axes at the same time.</p>
<pre class="literal-block">In [57]: dfmi.loc['A1', (slice(None), 'foo')]
Out[57]: 
lvl0        a    b
lvl1      foo  foo
B0 C0 D0   64   66
      D1   68   70
   C1 D0   72   74
      D1   76   78
   C2 D0   80   82
...       ...  ...
B1 C1 D1  108  110
   C2 D0  112  114
      D1  116  118
   C3 D0  120  122
      D1  124  126

[16 rows x 2 columns]

In [58]: dfmi.loc[idx[:, :, ['C1', 'C3']], idx[:, 'foo']]
Out[58]: 
lvl0           a    b
lvl1         foo  foo
A0 B0 C1 D0    8   10
         D1   12   14
      C3 D0   24   26
         D1   28   30
   B1 C1 D0   40   42
...          ...  ...
A3 B0 C3 D1  220  222
   B1 C1 D0  232  234
         D1  236  238
      C3 D0  248  250
         D1  252  254

[32 rows x 2 columns]</pre>
<p>Using a boolean indexer you can provide selection related to the <em>values</em>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [59]: </span><span class="n">mask</span> <span class="o">=</span> <span class="n">dfmi</span><span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)]</span> <span class="o">&gt;</span> <span class="mi">200</span>

<span class="gp">In [60]: </span><span class="n">dfmi</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:,</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">]],</span> <span class="n">idx</span><span class="p">[:,</span> <span class="s1">&#39;foo&#39;</span><span class="p">]]</span>
<span class="gh">Out[60]: </span><span class="go"></span>
<span class="go">lvl0           a    b</span>
<span class="go">lvl1         foo  foo</span>
<span class="go">A3 B0 C1 D1  204  206</span>
<span class="go">      C3 D0  216  218</span>
<span class="go">         D1  220  222</span>
<span class="go">   B1 C1 D0  232  234</span>
<span class="go">         D1  236  238</span>
<span class="go">      C3 D0  248  250</span>
<span class="go">         D1  252  254</span>

<span class="go">[7 rows x 2 columns]</span>
</pre></div>
</div>
<p>You can also specify the <code class="docutils literal notranslate"><span class="pre">axis</span></code> argument to <code class="docutils literal notranslate"><span class="pre">.loc</span></code> to interpret the passed
slicers on a single axis.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [61]: </span><span class="n">dfmi</span><span class="o">.</span><span class="n">loc</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">]]</span>
<span class="gh">Out[61]: </span><span class="go"></span>
<span class="go">lvl0           a         b     </span>
<span class="go">lvl1         bar  foo  bah  foo</span>
<span class="go">A0 B0 C1 D0    9    8   11   10</span>
<span class="go">         D1   13   12   15   14</span>
<span class="go">      C3 D0   25   24   27   26</span>
<span class="go">         D1   29   28   31   30</span>
<span class="go">   B1 C1 D0   41   40   43   42</span>
<span class="go">...          ...  ...  ...  ...</span>
<span class="go">A3 B0 C3 D1  221  220  223  222</span>
<span class="go">   B1 C1 D0  233  232  235  234</span>
<span class="go">         D1  237  236  239  238</span>
<span class="go">      C3 D0  249  248  251  250</span>
<span class="go">         D1  253  252  255  254</span>

<span class="go">[32 rows x 4 columns]</span>
</pre></div>
</div>
<p>Furthermore, you can <em>set</em> the values using the following methods.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [62]: </span><span class="n">df2</span> <span class="o">=</span> <span class="n">dfmi</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="gp">In [63]: </span><span class="n">df2</span><span class="o">.</span><span class="n">loc</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span>

<span class="gp">In [64]: </span><span class="n">df2</span>
<span class="gh">Out[64]: </span><span class="go"></span>
<span class="go">lvl0           a         b     </span>
<span class="go">lvl1         bar  foo  bah  foo</span>
<span class="go">A0 B0 C0 D0    1    0    3    2</span>
<span class="go">         D1    5    4    7    6</span>
<span class="go">      C1 D0  -10  -10  -10  -10</span>
<span class="go">         D1  -10  -10  -10  -10</span>
<span class="go">      C2 D0   17   16   19   18</span>
<span class="go">...          ...  ...  ...  ...</span>
<span class="go">A3 B1 C1 D1  -10  -10  -10  -10</span>
<span class="go">      C2 D0  241  240  243  242</span>
<span class="go">         D1  245  244  247  246</span>
<span class="go">      C3 D0  -10  -10  -10  -10</span>
<span class="go">         D1  -10  -10  -10  -10</span>

<span class="go">[64 rows x 4 columns]</span>
</pre></div>
</div>
<p>You can use a right-hand-side of an alignable object as well.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [65]: </span><span class="n">df2</span> <span class="o">=</span> <span class="n">dfmi</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="gp">In [66]: </span><span class="n">df2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">]],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">df2</span> <span class="o">*</span> <span class="mi">1000</span>

<span class="gp">In [67]: </span><span class="n">df2</span>
<span class="gh">Out[67]: </span><span class="go"></span>
<span class="go">lvl0              a               b        </span>
<span class="go">lvl1            bar     foo     bah     foo</span>
<span class="go">A0 B0 C0 D0       1       0       3       2</span>
<span class="go">         D1       5       4       7       6</span>
<span class="go">      C1 D0    9000    8000   11000   10000</span>
<span class="go">         D1   13000   12000   15000   14000</span>
<span class="go">      C2 D0      17      16      19      18</span>
<span class="go">...             ...     ...     ...     ...</span>
<span class="go">A3 B1 C1 D1  237000  236000  239000  238000</span>
<span class="go">      C2 D0     241     240     243     242</span>
<span class="go">         D1     245     244     247     246</span>
<span class="go">      C3 D0  249000  248000  251000  250000</span>
<span class="go">         D1  253000  252000  255000  254000</span>

<span class="go">[64 rows x 4 columns]</span>
</pre></div>
</div>
</div>
<div class="section" id="cross-section">
<span id="advanced-xs"></span><h3>Cross-section<a class="headerlink" href="#cross-section" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../generated/pandas.DataFrame.xs.html#pandas.DataFrame.xs" title="pandas.DataFrame.xs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">xs()</span></code></a> method of <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> additionally takes a level argument to make
selecting data at a particular level of a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> easier.</p>
<pre class="literal-block">In [68]: df
Out[68]: 
                     A         B         C
first second                              
bar   one     0.895717  0.410835 -1.413681
      two     0.805244  0.813850  1.607920
baz   one    -1.206412  0.132003  1.024180
      two     2.565646 -0.827317  0.569605
foo   one     1.431256 -0.076467  0.875906
      two     1.340309 -1.187678 -2.211372
qux   one    -1.170299  1.130127  0.974466
      two    -0.226169 -1.436737 -2.006747

[8 rows x 3 columns]

In [69]: df.xs('one', level='second')
Out[69]: 
              A         B         C
first                              
bar    0.895717  0.410835 -1.413681
baz   -1.206412  0.132003  1.024180
foo    1.431256 -0.076467  0.875906
qux   -1.170299  1.130127  0.974466

[4 rows x 3 columns]</pre>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># using the slicers</span>
<span class="gp">In [70]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="s1">&#39;one&#39;</span><span class="p">),</span> <span class="p">:]</span>
<span class="gh">Out[70]: </span><span class="go"></span>
<span class="go">                     A         B         C</span>
<span class="go">first second                              </span>
<span class="go">bar   one     0.895717  0.410835 -1.413681</span>
<span class="go">baz   one    -1.206412  0.132003  1.024180</span>
<span class="go">foo   one     1.431256 -0.076467  0.875906</span>
<span class="go">qux   one    -1.170299  1.130127  0.974466</span>

<span class="go">[4 rows x 3 columns]</span>
</pre></div>
</div>
<p>You can also select on the columns with <code class="docutils literal notranslate"><span class="pre">xs</span></code>, by
providing the axis argument.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [71]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">T</span>

<span class="gp">In [72]: </span><span class="n">df</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gh">Out[72]: </span><span class="go"></span>
<span class="go">first       bar       baz       foo       qux</span>
<span class="go">A      0.895717 -1.206412  1.431256 -1.170299</span>
<span class="go">B      0.410835  0.132003 -0.076467  1.130127</span>
<span class="go">C     -1.413681  1.024180  0.875906  0.974466</span>

<span class="go">[3 rows x 4 columns]</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># using the slicers</span>
<span class="gp">In [73]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="s1">&#39;one&#39;</span><span class="p">)]</span>
<span class="gh">Out[73]: </span><span class="go"></span>
<span class="go">first        bar       baz       foo       qux</span>
<span class="go">second       one       one       one       one</span>
<span class="go">A       0.895717 -1.206412  1.431256 -1.170299</span>
<span class="go">B       0.410835  0.132003 -0.076467  1.130127</span>
<span class="go">C      -1.413681  1.024180  0.875906  0.974466</span>

<span class="go">[3 rows x 4 columns]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">xs</span></code> also allows selection with multiple keys.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [74]: </span><span class="n">df</span><span class="o">.</span><span class="n">xs</span><span class="p">((</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">),</span> <span class="n">level</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="s1">&#39;first&#39;</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gh">Out[74]: </span><span class="go"></span>
<span class="go">first        bar</span>
<span class="go">second       one</span>
<span class="go">A       0.895717</span>
<span class="go">B       0.410835</span>
<span class="go">C      -1.413681</span>

<span class="go">[3 rows x 1 columns]</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># using the slicers</span>
<span class="gp">In [75]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">)]</span>
<span class="gh">Out[75]: </span><span class="go"></span>
<span class="go">A    0.895717</span>
<span class="go">B    0.410835</span>
<span class="go">C   -1.413681</span>
<span class="go">Name: (bar, one), Length: 3, dtype: float64</span>
</pre></div>
</div>
<p>You can pass <code class="docutils literal notranslate"><span class="pre">drop_level=False</span></code> to <code class="docutils literal notranslate"><span class="pre">xs</span></code> to retain
the level that was selected.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [76]: </span><span class="n">df</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">drop_level</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gh">Out[76]: </span><span class="go"></span>
<span class="go">first        bar       baz       foo       qux</span>
<span class="go">second       one       one       one       one</span>
<span class="go">A       0.895717 -1.206412  1.431256 -1.170299</span>
<span class="go">B       0.410835  0.132003 -0.076467  1.130127</span>
<span class="go">C      -1.413681  1.024180  0.875906  0.974466</span>

<span class="go">[3 rows x 4 columns]</span>
</pre></div>
</div>
<p>Compare the above with the result using <code class="docutils literal notranslate"><span class="pre">drop_level=True</span></code> (the default value).</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [77]: </span><span class="n">df</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">drop_level</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gh">Out[77]: </span><span class="go"></span>
<span class="go">first       bar       baz       foo       qux</span>
<span class="go">A      0.895717 -1.206412  1.431256 -1.170299</span>
<span class="go">B      0.410835  0.132003 -0.076467  1.130127</span>
<span class="go">C     -1.413681  1.024180  0.875906  0.974466</span>

<span class="go">[3 rows x 4 columns]</span>
</pre></div>
</div>
</div>
<div class="section" id="advanced-reindexing-and-alignment">
<span id="advanced-advanced-reindex"></span><h3>Advanced reindexing and alignment<a class="headerlink" href="#advanced-reindexing-and-alignment" title="Permalink to this headline">¶</a></h3>
<p>Using the parameter <code class="docutils literal notranslate"><span class="pre">level</span></code> in the <a class="reference internal" href="../generated/pandas.DataFrame.reindex.html#pandas.DataFrame.reindex" title="pandas.DataFrame.reindex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reindex()</span></code></a> and
<a class="reference internal" href="../generated/pandas.DataFrame.align.html#pandas.DataFrame.align" title="pandas.DataFrame.align"><code class="xref py py-meth docutils literal notranslate"><span class="pre">align()</span></code></a> methods of pandas objects is useful to broadcast
values across a level. For instance:</p>
<pre class="literal-block">In [78]: midx = pd.MultiIndex(levels=[['zero', 'one'], ['x', 'y']],
   ....:                      codes=[[1, 1, 0, 0], [1, 0, 1, 0]])
   ....: 

In [79]: df = pd.DataFrame(np.random.randn(4, 2), index=midx)

In [80]: df
Out[80]: 
               0         1
one  y  1.519970 -0.493662
     x  0.600178  0.274230
zero y  0.132885 -0.023688
     x  2.410179  1.450520

[4 rows x 2 columns]

In [81]: df2 = df.mean(level=0)

In [82]: df2
Out[82]: 
             0         1
one   1.060074 -0.109716
zero  1.271532  0.713416

[2 rows x 2 columns]

In [83]: df2.reindex(df.index, level=0)
Out[83]: 
               0         1
one  y  1.060074 -0.109716
     x  1.060074 -0.109716
zero y  1.271532  0.713416
     x  1.271532  0.713416

[4 rows x 2 columns]

# aligning
In [84]: df_aligned, df2_aligned = df.align(df2, level=0)

In [85]: df_aligned
Out[85]: 
               0         1
one  y  1.519970 -0.493662
     x  0.600178  0.274230
zero y  0.132885 -0.023688
     x  2.410179  1.450520

[4 rows x 2 columns]

In [86]: df2_aligned
Out[86]: 
               0         1
one  y  1.060074 -0.109716
     x  1.060074 -0.109716
zero y  1.271532  0.713416
     x  1.271532  0.713416

[4 rows x 2 columns]</pre>
</div>
<div class="section" id="swapping-levels-with-swaplevel">
<h3>Swapping levels with <code class="docutils literal notranslate"><span class="pre">swaplevel</span></code><a class="headerlink" href="#swapping-levels-with-swaplevel" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../generated/pandas.MultiIndex.swaplevel.html#pandas.MultiIndex.swaplevel" title="pandas.MultiIndex.swaplevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">swaplevel()</span></code></a> method can switch the order of two levels:</p>
<pre class="literal-block">In [87]: df[:5]
Out[87]: 
               0         1
one  y  1.519970 -0.493662
     x  0.600178  0.274230
zero y  0.132885 -0.023688
     x  2.410179  1.450520

[4 rows x 2 columns]

In [88]: df[:5].swaplevel(0, 1, axis=0)
Out[88]: 
               0         1
y one   1.519970 -0.493662
x one   0.600178  0.274230
y zero  0.132885 -0.023688
x zero  2.410179  1.450520

[4 rows x 2 columns]</pre>
</div>
<div class="section" id="reordering-levels-with-reorder-levels">
<span id="advanced-reorderlevels"></span><h3>Reordering levels with <code class="docutils literal notranslate"><span class="pre">reorder_levels</span></code><a class="headerlink" href="#reordering-levels-with-reorder-levels" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../generated/pandas.MultiIndex.reorder_levels.html#pandas.MultiIndex.reorder_levels" title="pandas.MultiIndex.reorder_levels"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reorder_levels()</span></code></a> method generalizes the <code class="docutils literal notranslate"><span class="pre">swaplevel</span></code>
method, allowing you to permute the hierarchical index levels in one step:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [89]: </span><span class="n">df</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">reorder_levels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gh">Out[89]: </span><span class="go"></span>
<span class="go">               0         1</span>
<span class="go">y one   1.519970 -0.493662</span>
<span class="go">x one   0.600178  0.274230</span>
<span class="go">y zero  0.132885 -0.023688</span>
<span class="go">x zero  2.410179  1.450520</span>

<span class="go">[4 rows x 2 columns]</span>
</pre></div>
</div>
</div>
<div class="section" id="renaming-names-of-an-index-or-multiindex">
<span id="advanced-index-names"></span><h3>Renaming names of an <code class="docutils literal notranslate"><span class="pre">Index</span></code> or <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code><a class="headerlink" href="#renaming-names-of-an-index-or-multiindex" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../generated/pandas.DataFrame.rename.html#pandas.DataFrame.rename" title="pandas.DataFrame.rename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rename()</span></code></a> method is used to rename the labels of a
<code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>, and is typically used to rename the columns of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.
The <code class="docutils literal notranslate"><span class="pre">columns</span></code> argument of <code class="docutils literal notranslate"><span class="pre">rename</span></code> allows a dictionary to be specified
that includes only the columns you wish to rename.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [90]: </span><span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;col0&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;col1&quot;</span><span class="p">})</span>
<span class="gh">Out[90]: </span><span class="go"></span>
<span class="go">            col0      col1</span>
<span class="go">one  y  1.519970 -0.493662</span>
<span class="go">     x  0.600178  0.274230</span>
<span class="go">zero y  0.132885 -0.023688</span>
<span class="go">     x  2.410179  1.450520</span>

<span class="go">[4 rows x 2 columns]</span>
</pre></div>
</div>
<p>This method can also be used to rename specific labels of the main index
of the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [91]: </span><span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;one&quot;</span><span class="p">:</span> <span class="s2">&quot;two&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="s2">&quot;z&quot;</span><span class="p">})</span>
<span class="gh">Out[91]: </span><span class="go"></span>
<span class="go">               0         1</span>
<span class="go">two  z  1.519970 -0.493662</span>
<span class="go">     x  0.600178  0.274230</span>
<span class="go">zero z  0.132885 -0.023688</span>
<span class="go">     x  2.410179  1.450520</span>

<span class="go">[4 rows x 2 columns]</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../generated/pandas.DataFrame.rename_axis.html#pandas.DataFrame.rename_axis" title="pandas.DataFrame.rename_axis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rename_axis()</span></code></a> method is used to rename the name of a
<code class="docutils literal notranslate"><span class="pre">Index</span></code> or <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>. In particular, the names of the levels of a
<code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> can be specified, which is useful if <code class="docutils literal notranslate"><span class="pre">reset_index()</span></code> is later
used to move the values from the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> to a column.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [92]: </span><span class="n">df</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="s1">&#39;def&#39;</span><span class="p">])</span>
<span class="gh">Out[92]: </span><span class="go"></span>
<span class="go">                 0         1</span>
<span class="go">abc  def                    </span>
<span class="go">one  y    1.519970 -0.493662</span>
<span class="go">     x    0.600178  0.274230</span>
<span class="go">zero y    0.132885 -0.023688</span>
<span class="go">     x    2.410179  1.450520</span>

<span class="go">[4 rows x 2 columns]</span>
</pre></div>
</div>
<p>Note that the columns of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> are an index, so that using
<code class="docutils literal notranslate"><span class="pre">rename_axis</span></code> with the <code class="docutils literal notranslate"><span class="pre">columns</span></code> argument will change the name of that
index.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [93]: </span><span class="n">df</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;Cols&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span>
<span class="gh">Out[93]: </span><span class="go">RangeIndex(start=0, stop=2, step=1, name=&#39;Cols&#39;)</span>
</pre></div>
</div>
<p>Both <code class="docutils literal notranslate"><span class="pre">rename</span></code> and <code class="docutils literal notranslate"><span class="pre">rename_axis</span></code> support specifying a dictionary,
<code class="docutils literal notranslate"><span class="pre">Series</span></code> or a mapping function to map labels/names to new values.</p>
</div>
</div>
<div class="section" id="sorting-a-multiindex">
<h2>Sorting a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code><a class="headerlink" href="#sorting-a-multiindex" title="Permalink to this headline">¶</a></h2>
<p>For <a class="reference internal" href="../generated/pandas.MultiIndex.html#pandas.MultiIndex" title="pandas.MultiIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiIndex</span></code></a>-ed objects to be indexed and sliced effectively,
they need to be sorted. As with any index, you can use <a class="reference internal" href="../generated/pandas.DataFrame.sort_index.html#pandas.DataFrame.sort_index" title="pandas.DataFrame.sort_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_index()</span></code></a>.</p>
<pre class="literal-block">In [94]: import random

In [95]: random.shuffle(tuples)

In [96]: s = pd.Series(np.random.randn(8), index=pd.MultiIndex.from_tuples(tuples))

In [97]: s
Out[97]: 
foo  one    0.206053
qux  one   -0.251905
baz  one   -2.213588
     two    1.063327
qux  two    1.266143
foo  two    0.299368
bar  two   -0.863838
     one    0.408204
Length: 8, dtype: float64

In [98]: s.sort_index()
Out[98]: 
bar  one    0.408204
     two   -0.863838
baz  one   -2.213588
     two    1.063327
foo  one    0.206053
     two    0.299368
qux  one   -0.251905
     two    1.266143
Length: 8, dtype: float64

In [99]: s.sort_index(level=0)
Out[99]: 
bar  one    0.408204
     two   -0.863838
baz  one   -2.213588
     two    1.063327
foo  one    0.206053
     two    0.299368
qux  one   -0.251905
     two    1.266143
Length: 8, dtype: float64

In [100]: s.sort_index(level=1)
Out[100]: 
bar  one    0.408204
baz  one   -2.213588
foo  one    0.206053
qux  one   -0.251905
bar  two   -0.863838
baz  two    1.063327
foo  two    0.299368
qux  two    1.266143
Length: 8, dtype: float64</pre>
<p id="advanced-sortlevel-byname">You may also pass a level name to <code class="docutils literal notranslate"><span class="pre">sort_index</span></code> if the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> levels
are named.</p>
<pre class="literal-block">In [101]: s.index.set_names(['L1', 'L2'], inplace=True)

In [102]: s.sort_index(level='L1')
Out[102]: 
L1   L2 
bar  one    0.408204
     two   -0.863838
baz  one   -2.213588
     two    1.063327
foo  one    0.206053
     two    0.299368
qux  one   -0.251905
     two    1.266143
Length: 8, dtype: float64

In [103]: s.sort_index(level='L2')
Out[103]: 
L1   L2 
bar  one    0.408204
baz  one   -2.213588
foo  one    0.206053
qux  one   -0.251905
bar  two   -0.863838
baz  two    1.063327
foo  two    0.299368
qux  two    1.266143
Length: 8, dtype: float64</pre>
<p>On higher dimensional objects, you can sort any of the other axes by level if
they have a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [104]: </span><span class="n">df</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gh">Out[104]: </span><span class="go"></span>
<span class="go">        one      zero       one      zero</span>
<span class="go">          x         x         y         y</span>
<span class="go">0  0.600178  2.410179  1.519970  0.132885</span>
<span class="go">1  0.274230  1.450520 -0.493662 -0.023688</span>

<span class="go">[2 rows x 4 columns]</span>
</pre></div>
</div>
<p>Indexing will work even if the data are not sorted, but will be rather
inefficient (and show a <code class="docutils literal notranslate"><span class="pre">PerformanceWarning</span></code>). It will also
return a copy of the data rather than a view:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [105]: </span><span class="n">dfm</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;jim&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">   .....: </span>                    <span class="s1">&#39;joe&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span>
<span class="gp">   .....: </span>                    <span class="s1">&#39;jolie&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">)})</span>
<span class="gp">   .....: </span>

<span class="gp">In [106]: </span><span class="n">dfm</span> <span class="o">=</span> <span class="n">dfm</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;jim&#39;</span><span class="p">,</span> <span class="s1">&#39;joe&#39;</span><span class="p">])</span>

<span class="gp">In [107]: </span><span class="n">dfm</span>
<span class="gh">Out[107]: </span><span class="go"></span>
<span class="go">            jolie</span>
<span class="go">jim joe          </span>
<span class="go">0   x    0.490671</span>
<span class="go">    x    0.120248</span>
<span class="go">1   z    0.537020</span>
<span class="go">    y    0.110968</span>

<span class="go">[4 rows x 1 columns]</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">dfm</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)]</span>
<span class="go">PerformanceWarning: indexing past lexsort depth may impact performance.</span>

<span class="gh">Out[4]:</span>
<span class="go">           jolie</span>
<span class="go">jim joe</span>
<span class="go">1   z    0.64094</span>
</pre></div>
</div>
<p id="advanced-unsorted">Furthermore, if you try to index something that is not fully lexsorted, this can raise:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="n">dfm</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">):(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)]</span>
<span class="go">UnsortedIndexError: &#39;Key length (2) was greater than MultiIndex lexsort depth (1)&#39;</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../generated/pandas.MultiIndex.is_lexsorted.html#pandas.MultiIndex.is_lexsorted" title="pandas.MultiIndex.is_lexsorted"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_lexsorted()</span></code></a> method on a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> shows if the
index is sorted, and the <code class="docutils literal notranslate"><span class="pre">lexsort_depth</span></code> property returns the sort depth:</p>
<pre class="literal-block">In [108]: dfm.index.is_lexsorted()
Out[108]: False

In [109]: dfm.index.lexsort_depth
Out[109]: 1</pre>
<pre class="literal-block">In [110]: dfm = dfm.sort_index()

In [111]: dfm
Out[111]: 
            jolie
jim joe          
0   x    0.490671
    x    0.120248
1   y    0.110968
    z    0.537020

[4 rows x 1 columns]

In [112]: dfm.index.is_lexsorted()
Out[112]: True

In [113]: dfm.index.lexsort_depth
Out[113]: 2</pre>
<p>And now selection works as expected.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [114]: </span><span class="n">dfm</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">):(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)]</span>
<span class="gh">Out[114]: </span><span class="go"></span>
<span class="go">            jolie</span>
<span class="go">jim joe          </span>
<span class="go">1   y    0.110968</span>
<span class="go">    z    0.537020</span>

<span class="go">[2 rows x 1 columns]</span>
</pre></div>
</div>
</div>
<div class="section" id="take-methods">
<h2>Take Methods<a class="headerlink" href="#take-methods" title="Permalink to this headline">¶</a></h2>
<p id="advanced-take">Similar to NumPy ndarrays, pandas <code class="docutils literal notranslate"><span class="pre">Index</span></code>, <code class="docutils literal notranslate"><span class="pre">Series</span></code>, and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> also provides
the <a class="reference internal" href="../generated/pandas.DataFrame.take.html#pandas.DataFrame.take" title="pandas.DataFrame.take"><code class="xref py py-meth docutils literal notranslate"><span class="pre">take()</span></code></a> method that retrieves elements along a given axis at the given
indices. The given indices must be either a list or an ndarray of integer
index positions. <code class="docutils literal notranslate"><span class="pre">take</span></code> will also accept negative integers as relative positions to the end of the object.</p>
<pre class="literal-block">In [115]: index = pd.Index(np.random.randint(0, 1000, 10))

In [116]: index
Out[116]: Int64Index([214, 502, 712, 567, 786, 175, 993, 133, 758, 329], dtype='int64')

In [117]: positions = [0, 9, 3]

In [118]: index[positions]
Out[118]: Int64Index([214, 329, 567], dtype='int64')

In [119]: index.take(positions)
Out[119]: Int64Index([214, 329, 567], dtype='int64')

In [120]: ser = pd.Series(np.random.randn(10))

In [121]: ser.iloc[positions]
Out[121]: 
0   -0.179666
9    1.824375
3    0.392149
Length: 3, dtype: float64

In [122]: ser.take(positions)
Out[122]: 
0   -0.179666
9    1.824375
3    0.392149
Length: 3, dtype: float64</pre>
<p>For DataFrames, the given indices should be a 1d list or ndarray that specifies
row or column positions.</p>
<pre class="literal-block">In [123]: frm = pd.DataFrame(np.random.randn(5, 3))

In [124]: frm.take([1, 4, 3])
Out[124]: 
          0         1         2
1 -1.237881  0.106854 -1.276829
4  0.629675 -1.425966  1.857704
3  0.979542 -1.633678  0.615855

[3 rows x 3 columns]

In [125]: frm.take([0, 2], axis=1)
Out[125]: 
          0         2
0  0.595974  0.601544
1 -1.237881 -1.276829
2 -0.767101  1.499591
3  0.979542  0.615855
4  0.629675  1.857704

[5 rows x 2 columns]</pre>
<p>It is important to note that the <code class="docutils literal notranslate"><span class="pre">take</span></code> method on pandas objects are not
intended to work on boolean indices and may return unexpected results.</p>
<pre class="literal-block">In [126]: arr = np.random.randn(10)

In [127]: arr.take([False, False, True, True])
Out[127]: array([-1.1935, -1.1935,  0.6775,  0.6775])

In [128]: arr[[0, 1]]
Out[128]: array([-1.1935,  0.6775])

In [129]: ser = pd.Series(np.random.randn(10))

In [130]: ser.take([False, False, True, True])
Out[130]: 
0    0.233141
0    0.233141
1   -0.223540
1   -0.223540
Length: 4, dtype: float64

In [131]: ser.iloc[[0, 1]]
Out[131]: 
0    0.233141
1   -0.223540
Length: 2, dtype: float64</pre>
<p>Finally, as a small note on performance, because the <code class="docutils literal notranslate"><span class="pre">take</span></code> method handles
a narrower range of inputs, it can offer performance that is a good deal
faster than fancy indexing.</p>
</div>
<div class="section" id="index-types">
<span id="indexing-index-types"></span><h2>Index Types<a class="headerlink" href="#index-types" title="Permalink to this headline">¶</a></h2>
<p>We have discussed <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> in the previous sections pretty extensively.
Documentation about <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> and <code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code> are shown <a class="reference internal" href="timeseries.html#timeseries-overview"><span class="std std-ref">here</span></a>,
and documentation about <code class="docutils literal notranslate"><span class="pre">TimedeltaIndex</span></code> is found <a class="reference internal" href="timedeltas.html#timedeltas-index"><span class="std std-ref">here</span></a>.</p>
<p>In the following sub-sections we will highlight some other index types.</p>
<div class="section" id="categoricalindex">
<span id="indexing-categoricalindex"></span><h3>CategoricalIndex<a class="headerlink" href="#categoricalindex" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../generated/pandas.CategoricalIndex.html#pandas.CategoricalIndex" title="pandas.CategoricalIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoricalIndex</span></code></a> is a type of index that is useful for supporting
indexing with duplicates. This is a container around a <a class="reference internal" href="../generated/pandas.Categorical.html#pandas.Categorical" title="pandas.Categorical"><code class="xref py py-class docutils literal notranslate"><span class="pre">Categorical</span></code></a>
and allows efficient indexing and storage of an index with a large number of duplicated elements.</p>
<pre class="literal-block">In [132]: from pandas.api.types import CategoricalDtype

In [133]: df = pd.DataFrame({'A': np.arange(6),
   .....:                    'B': list('aabbca')})
   .....: 

In [134]: df['B'] = df['B'].astype(CategoricalDtype(list('cab')))

In [135]: df
Out[135]: 
   A  B
0  0  a
1  1  a
2  2  b
3  3  b
4  4  c
5  5  a

[6 rows x 2 columns]

In [136]: df.dtypes
Out[136]: 
A       int64
B    category
Length: 2, dtype: object

In [137]: df.B.cat.categories
Out[137]: Index(['c', 'a', 'b'], dtype='object')</pre>
<p>Setting the index will create a <code class="docutils literal notranslate"><span class="pre">CategoricalIndex</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [138]: </span><span class="n">df2</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>

<span class="gp">In [139]: </span><span class="n">df2</span><span class="o">.</span><span class="n">index</span>
<span class="gh">Out[139]: </span><span class="go">CategoricalIndex([&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;], categories=[&#39;c&#39;, &#39;a&#39;, &#39;b&#39;], ordered=False, name=&#39;B&#39;, dtype=&#39;category&#39;)</span>
</pre></div>
</div>
<p>Indexing with <code class="docutils literal notranslate"><span class="pre">__getitem__/.iloc/.loc</span></code> works similarly to an <code class="docutils literal notranslate"><span class="pre">Index</span></code> with duplicates.
The indexers <strong>must</strong> be in the category or the operation will raise a <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [140]: </span><span class="n">df2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="gh">Out[140]: </span><span class="go"></span>
<span class="go">   A</span>
<span class="go">B   </span>
<span class="go">a  0</span>
<span class="go">a  1</span>
<span class="go">a  5</span>

<span class="go">[3 rows x 1 columns]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">CategoricalIndex</span></code> is <strong>preserved</strong> after indexing:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [141]: </span><span class="n">df2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
<span class="gh">Out[141]: </span><span class="go">CategoricalIndex([&#39;a&#39;, &#39;a&#39;, &#39;a&#39;], categories=[&#39;c&#39;, &#39;a&#39;, &#39;b&#39;], ordered=False, name=&#39;B&#39;, dtype=&#39;category&#39;)</span>
</pre></div>
</div>
<p>Sorting the index will sort by the order of the categories (recall that we
created the index with <code class="docutils literal notranslate"><span class="pre">CategoricalDtype(list('cab'))</span></code>, so the sorted
order is <code class="docutils literal notranslate"><span class="pre">cab</span></code>).</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [142]: </span><span class="n">df2</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
<span class="gh">Out[142]: </span><span class="go"></span>
<span class="go">   A</span>
<span class="go">B   </span>
<span class="go">c  4</span>
<span class="go">a  0</span>
<span class="go">a  1</span>
<span class="go">a  5</span>
<span class="go">b  2</span>
<span class="go">b  3</span>

<span class="go">[6 rows x 1 columns]</span>
</pre></div>
</div>
<p>Groupby operations on the index will preserve the index nature as well.</p>
<pre class="literal-block">In [143]: df2.groupby(level=0).sum()
Out[143]: 
   A
B   
c  4
a  6
b  5

[3 rows x 1 columns]

In [144]: df2.groupby(level=0).sum().index
Out[144]: CategoricalIndex(['c', 'a', 'b'], categories=['c', 'a', 'b'], ordered=False, name='B', dtype='category')</pre>
<p>Reindexing operations will return a resulting index based on the type of the passed
indexer. Passing a list will return a plain-old <code class="docutils literal notranslate"><span class="pre">Index</span></code>; indexing with
a <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> will return a <code class="docutils literal notranslate"><span class="pre">CategoricalIndex</span></code>, indexed according to the categories
of the <strong>passed</strong> <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> dtype. This allows one to arbitrarily index these even with
values <strong>not</strong> in the categories, similarly to how you can reindex <strong>any</strong> pandas index.</p>
<pre class="literal-block">In [145]: df2.reindex(['a','e'])
Out[145]: 
     A
B     
a  0.0
a  1.0
a  5.0
e  NaN

[4 rows x 1 columns]

In [146]: df2.reindex(['a','e']).index
Out[146]: Index(['a', 'a', 'a', 'e'], dtype='object', name='B')

In [147]: df2.reindex(pd.Categorical(['a','e'],categories=list('abcde')))
Out[147]: 
     A
B     
a  0.0
a  1.0
a  5.0
e  NaN

[4 rows x 1 columns]

In [148]: df2.reindex(pd.Categorical(['a','e'],categories=list('abcde'))).index
Out[148]: CategoricalIndex(['a', 'a', 'a', 'e'], categories=['a', 'b', 'c', 'd', 'e'], ordered=False, name='B', dtype='category')</pre>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Reshaping and Comparison operations on a <code class="docutils literal notranslate"><span class="pre">CategoricalIndex</span></code> must have the same categories
or a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> will be raised.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [9]: </span><span class="n">df3</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;aabbca&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)})</span>

<span class="gp">In [11]: </span><span class="n">df3</span> <span class="o">=</span> <span class="n">df3</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>

<span class="gp">In [11]: </span><span class="n">df3</span><span class="o">.</span><span class="n">index</span>
<span class="gh">Out[11]: </span><span class="go">CategoricalIndex([u&#39;a&#39;, u&#39;a&#39;, u&#39;b&#39;, u&#39;b&#39;, u&#39;c&#39;, u&#39;a&#39;], categories=[u&#39;a&#39;, u&#39;b&#39;, u&#39;c&#39;], ordered=False, name=u&#39;B&#39;, dtype=&#39;category&#39;)</span>

<span class="gp">In [12]: </span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df2</span><span class="p">,</span> <span class="n">df3</span><span class="p">])</span>
<span class="go">TypeError: categories must match existing categories when appending</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="int64index-and-rangeindex">
<span id="indexing-rangeindex"></span><h3>Int64Index and RangeIndex<a class="headerlink" href="#int64index-and-rangeindex" title="Permalink to this headline">¶</a></h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Indexing on an integer-based Index with floats has been clarified in 0.18.0, for a summary of the changes, see <a class="reference internal" href="../release/whatsnew/v0.18.0.html#whatsnew-0180-float-indexers"><span class="std std-ref">here</span></a>.</p>
</div>
<p><a class="reference internal" href="../generated/pandas.Int64Index.html#pandas.Int64Index" title="pandas.Int64Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Int64Index</span></code></a> is a fundamental basic index in pandas.
This is an immutable array implementing an ordered, sliceable set.
Prior to 0.18.0, the <code class="docutils literal notranslate"><span class="pre">Int64Index</span></code> would provide the default index for all <code class="docutils literal notranslate"><span class="pre">NDFrame</span></code> objects.</p>
<p><a class="reference internal" href="../generated/pandas.RangeIndex.html#pandas.RangeIndex" title="pandas.RangeIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">RangeIndex</span></code></a> is a sub-class of <code class="docutils literal notranslate"><span class="pre">Int64Index</span></code> added in version 0.18.0, now providing the default index for all <code class="docutils literal notranslate"><span class="pre">NDFrame</span></code> objects.
<code class="docutils literal notranslate"><span class="pre">RangeIndex</span></code> is an optimized version of <code class="docutils literal notranslate"><span class="pre">Int64Index</span></code> that can represent a monotonic ordered set. These are analogous to Python <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#typesseq-range">range types</a>.</p>
</div>
<div class="section" id="float64index">
<span id="indexing-float64index"></span><h3>Float64Index<a class="headerlink" href="#float64index" title="Permalink to this headline">¶</a></h3>
<p>By default a <a class="reference internal" href="../generated/pandas.Float64Index.html#pandas.Float64Index" title="pandas.Float64Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Float64Index</span></code></a> will be automatically created when passing floating, or mixed-integer-floating values in index creation.
This enables a pure label-based slicing paradigm that makes <code class="docutils literal notranslate"><span class="pre">[],ix,loc</span></code> for scalar indexing and slicing work exactly the
same.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [149]: </span><span class="n">indexf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

<span class="gp">In [150]: </span><span class="n">indexf</span>
<span class="gh">Out[150]: </span><span class="go">Float64Index([1.5, 2.0, 3.0, 4.5, 5.0], dtype=&#39;float64&#39;)</span>

<span class="gp">In [151]: </span><span class="n">sf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">indexf</span><span class="p">)</span>

<span class="gp">In [152]: </span><span class="n">sf</span>
<span class="gh">Out[152]: </span><span class="go"></span>
<span class="go">1.5    0</span>
<span class="go">2.0    1</span>
<span class="go">3.0    2</span>
<span class="go">4.5    3</span>
<span class="go">5.0    4</span>
<span class="go">Length: 5, dtype: int64</span>
</pre></div>
</div>
<p>Scalar selection for <code class="docutils literal notranslate"><span class="pre">[],.loc</span></code> will always be label based. An integer will match an equal float index (e.g. <code class="docutils literal notranslate"><span class="pre">3</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">3.0</span></code>).</p>
<pre class="literal-block">In [153]: sf[3]
Out[153]: 2

In [154]: sf[3.0]
Out[154]: 2

In [155]: sf.loc[3]
Out[155]: 2

In [156]: sf.loc[3.0]
Out[156]: 2</pre>
<p>The only positional indexing is via <code class="docutils literal notranslate"><span class="pre">iloc</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [157]: </span><span class="n">sf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gh">Out[157]: </span><span class="go">3</span>
</pre></div>
</div>
<p>A scalar index that is not found will raise a <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>.
Slicing is primarily on the values of the index when using <code class="docutils literal notranslate"><span class="pre">[],ix,loc</span></code>, and
<strong>always</strong> positional when using <code class="docutils literal notranslate"><span class="pre">iloc</span></code>. The exception is when the slice is
boolean, in which case it will always be positional.</p>
<pre class="literal-block">In [158]: sf[2:4]
Out[158]: 
2.0    1
3.0    2
Length: 2, dtype: int64

In [159]: sf.loc[2:4]
Out[159]: 
2.0    1
3.0    2
Length: 2, dtype: int64

In [160]: sf.iloc[2:4]
Out[160]: 
3.0    2
4.5    3
Length: 2, dtype: int64</pre>
<p>In float indexes, slicing using floats is allowed.</p>
<pre class="literal-block">In [161]: sf[2.1:4.6]
Out[161]: 
3.0    2
4.5    3
Length: 2, dtype: int64

In [162]: sf.loc[2.1:4.6]
Out[162]: 
3.0    2
4.5    3
Length: 2, dtype: int64</pre>
<p>In non-float indexes, slicing using floats will raise a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))[</span><span class="mf">3.5</span><span class="p">]</span>
<span class="go">TypeError: the label [3.5] is not a proper indexer for this index type (Int64Index)</span>

<span class="gp">In [1]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))[</span><span class="mf">3.5</span><span class="p">:</span><span class="mf">4.5</span><span class="p">]</span>
<span class="go">TypeError: the slice start [3.5] is not a proper indexer for this index type (Int64Index)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Using a scalar float indexer for <code class="docutils literal notranslate"><span class="pre">.iloc</span></code> has been removed in 0.18.0, so the following will raise a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [3]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mf">3.0</span><span class="p">]</span>
<span class="go">TypeError: cannot do positional indexing on &lt;class &#39;pandas.indexes.range.RangeIndex&#39;&gt; with these indexers [3.0] of &lt;type &#39;float&#39;&gt;</span>
</pre></div>
</div>
</div>
<p>Here is a typical use-case for using this type of indexing. Imagine that you have a somewhat
irregular timedelta-like indexing scheme, but the data is recorded as floats. This could, for
example, be millisecond offsets.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [163]: </span><span class="n">dfir</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">   .....: </span>                               <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mf">250.0</span><span class="p">,</span>
<span class="gp">   .....: </span>                               <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;AB&#39;</span><span class="p">)),</span>
<span class="gp">   .....: </span>                  <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">   .....: </span>                               <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mf">250.1</span><span class="p">,</span>
<span class="gp">   .....: </span>                               <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;AB&#39;</span><span class="p">))])</span>
<span class="gp">   .....: </span>

<span class="gp">In [164]: </span><span class="n">dfir</span>
<span class="gh">Out[164]: </span><span class="go"></span>
<span class="go">               A         B</span>
<span class="go">0.0     0.997289 -1.693316</span>
<span class="go">250.0  -0.179129 -1.598062</span>
<span class="go">500.0   0.936914  0.912560</span>
<span class="go">750.0  -1.003401  1.632781</span>
<span class="go">1000.0 -0.724626  0.178219</span>
<span class="go">1000.4  0.310610 -0.108002</span>
<span class="go">1250.5 -0.974226 -1.147708</span>
<span class="go">1500.6 -2.281374  0.760010</span>
<span class="go">1750.7 -0.742532  1.533318</span>
<span class="go">2000.8  2.495362 -0.432771</span>
<span class="go">2250.9 -0.068954  0.043520</span>

<span class="go">[11 rows x 2 columns]</span>
</pre></div>
</div>
<p>Selection operations then will always work on a value basis, for all selection operators.</p>
<pre class="literal-block">In [165]: dfir[0:1000.4]
Out[165]: 
               A         B
0.0     0.997289 -1.693316
250.0  -0.179129 -1.598062
500.0   0.936914  0.912560
750.0  -1.003401  1.632781
1000.0 -0.724626  0.178219
1000.4  0.310610 -0.108002

[6 rows x 2 columns]

In [166]: dfir.loc[0:1001, 'A']
Out[166]: 
0.0       0.997289
250.0    -0.179129
500.0     0.936914
750.0    -1.003401
1000.0   -0.724626
1000.4    0.310610
Name: A, Length: 6, dtype: float64

In [167]: dfir.loc[1000.4]
Out[167]: 
A    0.310610
B   -0.108002
Name: 1000.4, Length: 2, dtype: float64</pre>
<p>You could retrieve the first 1 second (1000 ms) of data as such:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [168]: </span><span class="n">dfir</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1000</span><span class="p">]</span>
<span class="gh">Out[168]: </span><span class="go"></span>
<span class="go">               A         B</span>
<span class="go">0.0     0.997289 -1.693316</span>
<span class="go">250.0  -0.179129 -1.598062</span>
<span class="go">500.0   0.936914  0.912560</span>
<span class="go">750.0  -1.003401  1.632781</span>
<span class="go">1000.0 -0.724626  0.178219</span>

<span class="go">[5 rows x 2 columns]</span>
</pre></div>
</div>
<p>If you need integer based selection, you should use <code class="docutils literal notranslate"><span class="pre">iloc</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [169]: </span><span class="n">dfir</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="gh">Out[169]: </span><span class="go"></span>
<span class="go">               A         B</span>
<span class="go">0.0     0.997289 -1.693316</span>
<span class="go">250.0  -0.179129 -1.598062</span>
<span class="go">500.0   0.936914  0.912560</span>
<span class="go">750.0  -1.003401  1.632781</span>
<span class="go">1000.0 -0.724626  0.178219</span>

<span class="go">[5 rows x 2 columns]</span>
</pre></div>
</div>
</div>
<div class="section" id="intervalindex">
<span id="indexing-intervallindex"></span><h3>IntervalIndex<a class="headerlink" href="#intervalindex" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.0.</span></p>
</div>
<p><a class="reference internal" href="../generated/pandas.IntervalIndex.html#pandas.IntervalIndex" title="pandas.IntervalIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntervalIndex</span></code></a> together with its own dtype, <code class="xref py py-class docutils literal notranslate"><span class="pre">IntervalDtype</span></code>
as well as the <a class="reference internal" href="../generated/pandas.Interval.html#pandas.Interval" title="pandas.Interval"><code class="xref py py-class docutils literal notranslate"><span class="pre">Interval</span></code></a> scalar type,  allow first-class support in pandas
for interval notation.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> allows some unique indexing and is also used as a
return type for the categories in <a class="reference internal" href="../generated/pandas.cut.html#pandas.cut" title="pandas.cut"><code class="xref py py-func docutils literal notranslate"><span class="pre">cut()</span></code></a> and <a class="reference internal" href="../generated/pandas.qcut.html#pandas.qcut" title="pandas.qcut"><code class="xref py py-func docutils literal notranslate"><span class="pre">qcut()</span></code></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>These indexing behaviors are provisional and may change in a future version of pandas.</p>
</div>
<p>An <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> can be used in <code class="docutils literal notranslate"><span class="pre">Series</span></code> and in <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> as the index.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [170]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>
<span class="gp">   .....: </span>                  <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">IntervalIndex</span><span class="o">.</span><span class="n">from_breaks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]))</span>
<span class="gp">   .....: </span>

<span class="gp">In [171]: </span><span class="n">df</span>
<span class="gh">Out[171]: </span><span class="go"></span>
<span class="go">        A</span>
<span class="go">(0, 1]  1</span>
<span class="go">(1, 2]  2</span>
<span class="go">(2, 3]  3</span>
<span class="go">(3, 4]  4</span>

<span class="go">[4 rows x 1 columns]</span>
</pre></div>
</div>
<p>Label based indexing via <code class="docutils literal notranslate"><span class="pre">.loc</span></code> along the edges of an interval works as you would expect,
selecting that particular interval.</p>
<pre class="literal-block">In [172]: df.loc[2]
Out[172]: 
A    2
Name: (1, 2], Length: 1, dtype: int64

In [173]: df.loc[[2, 3]]
Out[173]: 
        A
(1, 2]  2
(2, 3]  3

[2 rows x 1 columns]</pre>
<p>If you select a label <em>contained</em> within an interval, this will also select the interval.</p>
<pre class="literal-block">In [174]: df.loc[2.5]
Out[174]: 
A    3
Name: (2, 3], Length: 1, dtype: int64

In [175]: df.loc[[2.5, 3.5]]
Out[175]: 
        A
(2, 3]  3
(3, 4]  4

[2 rows x 1 columns]</pre>
<p><code class="docutils literal notranslate"><span class="pre">Interval</span></code> and <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> are used by <code class="docutils literal notranslate"><span class="pre">cut</span></code> and <code class="docutils literal notranslate"><span class="pre">qcut</span></code>:</p>
<pre class="literal-block">In [176]: c = pd.cut(range(4), bins=2)

In [177]: c
Out[177]: 
[(-0.003, 1.5], (-0.003, 1.5], (1.5, 3.0], (1.5, 3.0]]
Categories (2, interval[float64]): [(-0.003, 1.5] &lt; (1.5, 3.0]]

In [178]: c.categories
Out[178]: 
IntervalIndex([(-0.003, 1.5], (1.5, 3.0]],
              closed='right',
              dtype='interval[float64]')</pre>
<p>Furthermore, <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> allows one to bin <em>other</em> data with these same
bins, with <code class="docutils literal notranslate"><span class="pre">NaN</span></code> representing a missing value similar to other dtypes.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [179]: </span><span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span>
<span class="gh">Out[179]: </span><span class="go"></span>
<span class="go">[(-0.003, 1.5], (1.5, 3.0], NaN, (-0.003, 1.5]]</span>
<span class="go">Categories (2, interval[float64]): [(-0.003, 1.5] &lt; (1.5, 3.0]]</span>
</pre></div>
</div>
<div class="section" id="generating-ranges-of-intervals">
<h4>Generating Ranges of Intervals<a class="headerlink" href="#generating-ranges-of-intervals" title="Permalink to this headline">¶</a></h4>
<p>If we need intervals on a regular frequency, we can use the <a class="reference internal" href="../generated/pandas.interval_range.html#pandas.interval_range" title="pandas.interval_range"><code class="xref py py-func docutils literal notranslate"><span class="pre">interval_range()</span></code></a> function
to create an <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> using various combinations of <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>, and <code class="docutils literal notranslate"><span class="pre">periods</span></code>.
The default frequency for <code class="docutils literal notranslate"><span class="pre">interval_range</span></code> is a 1 for numeric intervals, and calendar day for
datetime-like intervals:</p>
<pre class="literal-block">In [180]: pd.interval_range(start=0, end=5)
Out[180]: 
IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],
              closed='right',
              dtype='interval[int64]')

In [181]: pd.interval_range(start=pd.Timestamp('2017-01-01'), periods=4)
Out[181]: 
IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03], (2017-01-03, 2017-01-04], (2017-01-04, 2017-01-05]],
              closed='right',
              dtype='interval[datetime64[ns]]')

In [182]: pd.interval_range(end=pd.Timedelta('3 days'), periods=3)
Out[182]: 
IntervalIndex([(0 days 00:00:00, 1 days 00:00:00], (1 days 00:00:00, 2 days 00:00:00], (2 days 00:00:00, 3 days 00:00:00]],
              closed='right',
              dtype='interval[timedelta64[ns]]')</pre>
<p>The <code class="docutils literal notranslate"><span class="pre">freq</span></code> parameter can used to specify non-default frequencies, and can utilize a variety
of <a class="reference internal" href="timeseries.html#timeseries-offset-aliases"><span class="std std-ref">frequency aliases</span></a> with datetime-like intervals:</p>
<pre class="literal-block">In [183]: pd.interval_range(start=0, periods=5, freq=1.5)
Out[183]: 
IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0], (6.0, 7.5]],
              closed='right',
              dtype='interval[float64]')

In [184]: pd.interval_range(start=pd.Timestamp('2017-01-01'), periods=4, freq='W')
Out[184]: 
IntervalIndex([(2017-01-01, 2017-01-08], (2017-01-08, 2017-01-15], (2017-01-15, 2017-01-22], (2017-01-22, 2017-01-29]],
              closed='right',
              dtype='interval[datetime64[ns]]')

In [185]: pd.interval_range(start=pd.Timedelta('0 days'), periods=3, freq='9H')
Out[185]: 
IntervalIndex([(0 days 00:00:00, 0 days 09:00:00], (0 days 09:00:00, 0 days 18:00:00], (0 days 18:00:00, 1 days 03:00:00]],
              closed='right',
              dtype='interval[timedelta64[ns]]')</pre>
<p>Additionally, the <code class="docutils literal notranslate"><span class="pre">closed</span></code> parameter can be used to specify which side(s) the intervals
are closed on.  Intervals are closed on the right side by default.</p>
<pre class="literal-block">In [186]: pd.interval_range(start=0, end=4, closed='both')
Out[186]: 
IntervalIndex([[0, 1], [1, 2], [2, 3], [3, 4]],
              closed='both',
              dtype='interval[int64]')

In [187]: pd.interval_range(start=0, end=4, closed='neither')
Out[187]: 
IntervalIndex([(0, 1), (1, 2), (2, 3), (3, 4)],
              closed='neither',
              dtype='interval[int64]')</pre>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.23.0.</span></p>
</div>
<p>Specifying <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>, and <code class="docutils literal notranslate"><span class="pre">periods</span></code> will generate a range of evenly spaced
intervals from <code class="docutils literal notranslate"><span class="pre">start</span></code> to <code class="docutils literal notranslate"><span class="pre">end</span></code> inclusively, with <code class="docutils literal notranslate"><span class="pre">periods</span></code> number of elements
in the resulting <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code>:</p>
<pre class="literal-block">In [188]: pd.interval_range(start=0, end=6, periods=4)
Out[188]: 
IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],
              closed='right',
              dtype='interval[float64]')

In [189]: pd.interval_range(pd.Timestamp('2018-01-01'),
   .....:                   pd.Timestamp('2018-02-28'), periods=3)
   .....: 
Out[189]: 
IntervalIndex([(2018-01-01, 2018-01-20 08:00:00], (2018-01-20 08:00:00, 2018-02-08 16:00:00], (2018-02-08 16:00:00, 2018-02-28]],
              closed='right',
              dtype='interval[datetime64[ns]]')</pre>
</div>
</div>
</div>
<div class="section" id="miscellaneous-indexing-faq">
<h2>Miscellaneous indexing FAQ<a class="headerlink" href="#miscellaneous-indexing-faq" title="Permalink to this headline">¶</a></h2>
<div class="section" id="integer-indexing">
<h3>Integer indexing<a class="headerlink" href="#integer-indexing" title="Permalink to this headline">¶</a></h3>
<p>Label-based indexing with integer axis labels is a thorny topic. It has been
discussed heavily on mailing lists and among various members of the scientific
Python community. In pandas, our general viewpoint is that labels matter more
than integer locations. Therefore, with an integer axis index <em>only</em>
label-based indexing is possible with the standard tools like <code class="docutils literal notranslate"><span class="pre">.loc</span></code>. The
following code will generate exceptions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">df</span>
<span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
</pre></div>
</div>
<p>This deliberate decision was made to prevent ambiguities and subtle bugs (many
users reported finding bugs when the API change was made to stop “falling back”
on position-based indexing).</p>
</div>
<div class="section" id="non-monotonic-indexes-require-exact-matches">
<h3>Non-monotonic indexes require exact matches<a class="headerlink" href="#non-monotonic-indexes-require-exact-matches" title="Permalink to this headline">¶</a></h3>
<p>If the index of a <code class="docutils literal notranslate"><span class="pre">Series</span></code> or <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> is monotonically increasing or decreasing, then the bounds
of a label-based slice can be outside the range of the index, much like slice indexing a
normal Python <code class="docutils literal notranslate"><span class="pre">list</span></code>. Monotonicity of an index can be tested with the <a class="reference internal" href="../generated/pandas.Index.is_monotonic_increasing.html#pandas.Index.is_monotonic_increasing" title="pandas.Index.is_monotonic_increasing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_monotonic_increasing()</span></code></a> and
<a class="reference internal" href="../generated/pandas.Index.is_monotonic_decreasing.html#pandas.Index.is_monotonic_decreasing" title="pandas.Index.is_monotonic_decreasing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_monotonic_decreasing()</span></code></a> attributes.</p>
<pre class="literal-block">In [190]: df = pd.DataFrame(index=[2, 3, 3, 4, 5], columns=['data'], data=list(range(5)))

In [191]: df.index.is_monotonic_increasing
Out[191]: True

# no rows 0 or 1, but still returns rows 2, 3 (both of them), and 4:
In [192]: df.loc[0:4, :]
Out[192]: 
   data
2     0
3     1
3     2
4     3

[4 rows x 1 columns]

# slice is are outside the index, so empty DataFrame is returned
In [193]: df.loc[13:15, :]
Out[193]: 
Empty DataFrame
Columns: [data]
Index: []

[0 rows x 1 columns]</pre>
<p>On the other hand, if the index is not monotonic, then both slice bounds must be
<em>unique</em> members of the index.</p>
<pre class="literal-block">In [194]: df = pd.DataFrame(index=[2, 3, 1, 4, 3, 5],
   .....:                   columns=['data'], data=list(range(6)))
   .....: 

In [195]: df.index.is_monotonic_increasing
Out[195]: False

# OK because 2 and 4 are in the index
In [196]: df.loc[2:4, :]
Out[196]: 
   data
2     0
3     1
1     2
4     3

[4 rows x 1 columns]</pre>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># 0 is not in the index</span>
<span class="gp">In [9]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">KeyError: 0</span>

<span class="go"># 3 is not a unique label</span>
<span class="gp">In [11]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">KeyError: &#39;Cannot get right slice bound for non-unique label: 3&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Index.is_monotonic_increasing</span></code> and <code class="docutils literal notranslate"><span class="pre">Index.is_monotonic_decreasing</span></code> only check that
an index is weakly monotonic. To check for strict monotonicity, you can combine one of those with
the <a class="reference internal" href="../generated/pandas.Index.is_unique.html#pandas.Index.is_unique" title="pandas.Index.is_unique"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_unique()</span></code></a> attribute.</p>
<pre class="literal-block">In [197]: weakly_monotonic = pd.Index(['a', 'b', 'c', 'c'])

In [198]: weakly_monotonic
Out[198]: Index(['a', 'b', 'c', 'c'], dtype='object')

In [199]: weakly_monotonic.is_monotonic_increasing
Out[199]: True

In [200]: weakly_monotonic.is_monotonic_increasing &amp; weakly_monotonic.is_unique
Out[200]: False</pre>
</div>
<div class="section" id="endpoints-are-inclusive">
<h3>Endpoints are inclusive<a class="headerlink" href="#endpoints-are-inclusive" title="Permalink to this headline">¶</a></h3>
<p>Compared with standard Python sequence slicing in which the slice endpoint is
not inclusive, label-based slicing in pandas <strong>is inclusive</strong>. The primary
reason for this is that it is often not possible to easily determine the
“successor” or next element after a particular label in an index. For example,
consider the following <code class="docutils literal notranslate"><span class="pre">Series</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [201]: </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;abcdef&#39;</span><span class="p">))</span>

<span class="gp">In [202]: </span><span class="n">s</span>
<span class="gh">Out[202]: </span><span class="go"></span>
<span class="go">a    0.112246</span>
<span class="go">b    0.871721</span>
<span class="go">c   -0.816064</span>
<span class="go">d   -0.784880</span>
<span class="go">e    1.030659</span>
<span class="go">f    0.187483</span>
<span class="go">Length: 6, dtype: float64</span>
</pre></div>
</div>
<p>Suppose we wished to slice from <code class="docutils literal notranslate"><span class="pre">c</span></code> to <code class="docutils literal notranslate"><span class="pre">e</span></code>, using integers this would be
accomplished as such:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [203]: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="gh">Out[203]: </span><span class="go"></span>
<span class="go">c   -0.816064</span>
<span class="go">d   -0.784880</span>
<span class="go">e    1.030659</span>
<span class="go">Length: 3, dtype: float64</span>
</pre></div>
</div>
<p>However, if you only had <code class="docutils literal notranslate"><span class="pre">c</span></code> and <code class="docutils literal notranslate"><span class="pre">e</span></code>, determining the next element in the
index can be somewhat complicated. For example, the following does not work:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">:</span><span class="s1">&#39;e&#39;</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>A very common use case is to limit a time series to start and end at two
specific dates. To enable this, we made the design to make label-based
slicing include both endpoints:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [204]: </span><span class="n">s</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">:</span><span class="s1">&#39;e&#39;</span><span class="p">]</span>
<span class="gh">Out[204]: </span><span class="go"></span>
<span class="go">c   -0.816064</span>
<span class="go">d   -0.784880</span>
<span class="go">e    1.030659</span>
<span class="go">Length: 3, dtype: float64</span>
</pre></div>
</div>
<p>This is most definitely a “practicality beats purity” sort of thing, but it is
something to watch out for if you expect label-based slicing to behave exactly
in the way that standard Python integer slicing works.</p>
</div>
<div class="section" id="indexing-potentially-changes-underlying-series-dtype">
<h3>Indexing potentially changes underlying Series dtype<a class="headerlink" href="#indexing-potentially-changes-underlying-series-dtype" title="Permalink to this headline">¶</a></h3>
<p>The different indexing operation can potentially change the dtype of a <code class="docutils literal notranslate"><span class="pre">Series</span></code>.</p>
<pre class="literal-block">In [205]: series1 = pd.Series([1, 2, 3])

In [206]: series1.dtype
Out[206]: dtype('int64')

In [207]: res = series1.reindex([0, 4])

In [208]: res.dtype
Out[208]: dtype('float64')

In [209]: res
Out[209]: 
0    1.0
4    NaN
Length: 2, dtype: float64</pre>
<pre class="literal-block">In [210]: series2 = pd.Series([True])

In [211]: series2.dtype
Out[211]: dtype('bool')

In [212]: res = series2.reindex_like(series1)

In [213]: res.dtype
Out[213]: dtype('O')

In [214]: res
Out[214]: 
0    True
1     NaN
2     NaN
Length: 3, dtype: object</pre>
<p>This is because the (re)indexing operations above silently inserts <code class="docutils literal notranslate"><span class="pre">NaNs</span></code> and the <code class="docutils literal notranslate"><span class="pre">dtype</span></code>
changes accordingly.  This can cause some issues when using <code class="docutils literal notranslate"><span class="pre">numpy</span></code> <code class="docutils literal notranslate"><span class="pre">ufuncs</span></code>
such as <code class="docutils literal notranslate"><span class="pre">numpy.logical_and</span></code>.</p>
<p>See the <a class="reference external" href="https://github.com/pydata/pandas/issues/2388">this old issue</a> for a more
detailed discussion.</p>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../_sources/user_guide/advanced.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2008-2014, the pandas development team.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>