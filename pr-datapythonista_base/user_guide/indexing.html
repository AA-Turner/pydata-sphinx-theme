<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Indexing and Selecting Data &#8212; pandas 0.25.0 documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/pandas_styles.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/carousel.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/pandas_logo.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.25.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../install.html">Install</a></li>
                <li><a href="../docs.html">Documentation</a></li>
                <li><a href="../community.html">Community</a></li>
            
            
              
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li><a class="reference internal" href="#">Indexing and Selecting Data</a><ul>
<li><a class="reference internal" href="#different-choices-for-indexing">Different Choices for Indexing</a></li>
<li><a class="reference internal" href="#basics">Basics</a></li>
<li><a class="reference internal" href="#attribute-access">Attribute Access</a></li>
<li><a class="reference internal" href="#slicing-ranges">Slicing ranges</a></li>
<li><a class="reference internal" href="#selection-by-label">Selection By Label</a></li>
<li><a class="reference internal" href="#selection-by-position">Selection By Position</a></li>
<li><a class="reference internal" href="#selection-by-callable">Selection By Callable</a></li>
<li><a class="reference internal" href="#ix-indexer-is-deprecated">IX Indexer is Deprecated</a></li>
<li><a class="reference internal" href="#indexing-with-list-with-missing-labels-is-deprecated">Indexing with list with missing labels is Deprecated</a></li>
<li><a class="reference internal" href="#selecting-random-samples">Selecting Random Samples</a></li>
<li><a class="reference internal" href="#setting-with-enlargement">Setting With Enlargement</a></li>
<li><a class="reference internal" href="#fast-scalar-value-getting-and-setting">Fast scalar value getting and setting</a></li>
<li><a class="reference internal" href="#boolean-indexing">Boolean indexing</a></li>
<li><a class="reference internal" href="#indexing-with-isin">Indexing with isin</a></li>
<li><a class="reference internal" href="#the-where-method-and-masking">The <code class="xref py py-meth docutils literal notranslate"><span class="pre">where()</span></code> Method and Masking</a></li>
<li><a class="reference internal" href="#the-query-method">The <code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code> Method</a></li>
<li><a class="reference internal" href="#duplicate-data">Duplicate Data</a></li>
<li><a class="reference internal" href="#dictionary-like-get-method">Dictionary-like <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code> method</a></li>
<li><a class="reference internal" href="#the-lookup-method">The <code class="xref py py-meth docutils literal notranslate"><span class="pre">lookup()</span></code> Method</a></li>
<li><a class="reference internal" href="#index-objects">Index objects</a></li>
<li><a class="reference internal" href="#set-reset-index">Set / Reset Index</a></li>
<li><a class="reference internal" href="#returning-a-view-versus-a-copy">Returning a view versus a copy</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    <div class="col-md-9 content">
      
  <div class="section" id="indexing-and-selecting-data">
<h1>Indexing and Selecting Data<a class="headerlink" href="#indexing-and-selecting-data" title="Permalink to this headline">¶</a></h1>
<p>The axis labeling information in pandas objects serves many purposes:</p>
<ul class="simple">
<li><p>Identifies data (i.e. provides <em>metadata</em>) using known indicators,
important for analysis, visualization, and interactive console display.</p></li>
<li><p>Enables automatic and explicit data alignment.</p></li>
<li><p>Allows intuitive getting and setting of subsets of the data set.</p></li>
</ul>
<p>In this section, we will focus on the final point: namely, how to slice, dice,
and generally get and set subsets of pandas objects. The primary focus will be
on Series and DataFrame as they have received more development attention in
this area.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Python and NumPy indexing operators <code class="docutils literal notranslate"><span class="pre">[]</span></code> and attribute operator <code class="docutils literal notranslate"><span class="pre">.</span></code>
provide quick and easy access to pandas data structures across a wide range
of use cases. This makes interactive work intuitive, as there’s little new
to learn if you already know how to deal with Python dictionaries and NumPy
arrays. However, since the type of the data to be accessed isn’t known in
advance, directly using standard operators has some optimization limits. For
production code, we recommended that you take advantage of the optimized
pandas data access methods exposed in this chapter.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Whether a copy or a reference is returned for a setting operation, may
depend on the context. This is sometimes called <code class="docutils literal notranslate"><span class="pre">chained</span> <span class="pre">assignment</span></code> and
should be avoided. See <a class="reference internal" href="#indexing-view-versus-copy"><span class="std std-ref">Returning a View versus Copy</span></a>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Indexing on an integer-based Index with floats has been clarified in 0.18.0, for a summary of the changes, see <a class="reference internal" href="../release/whatsnew/v0.18.0.html#whatsnew-0180-float-indexers"><span class="std std-ref">here</span></a>.</p>
</div>
<p>See the <a class="reference internal" href="advanced.html#advanced"><span class="std std-ref">MultiIndex / Advanced Indexing</span></a> for <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> and more advanced indexing documentation.</p>
<p>See the <a class="reference internal" href="../getting_started/cookbook.html#cookbook-selection"><span class="std std-ref">cookbook</span></a> for some advanced strategies.</p>
<div class="section" id="different-choices-for-indexing">
<span id="indexing-choice"></span><h2>Different Choices for Indexing<a class="headerlink" href="#different-choices-for-indexing" title="Permalink to this headline">¶</a></h2>
<p>Object selection has had a number of user-requested additions in order to
support more explicit location based indexing. Pandas now supports three types
of multi-axis indexing.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">.loc</span></code> is primarily label based, but may also be used with a boolean array. <code class="docutils literal notranslate"><span class="pre">.loc</span></code> will raise <code class="docutils literal notranslate"><span class="pre">KeyError</span></code> when the items are not found. Allowed inputs are:</p>
<blockquote>
<div><ul>
<li><p>A single label, e.g. <code class="docutils literal notranslate"><span class="pre">5</span></code> or <code class="docutils literal notranslate"><span class="pre">'a'</span></code> (Note that <code class="docutils literal notranslate"><span class="pre">5</span></code> is interpreted as a
<em>label</em> of the index. This use is <strong>not</strong> an integer position along the
index.).</p></li>
<li><p>A list or array of labels <code class="docutils literal notranslate"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c']</span></code>.</p></li>
<li><p>A slice object with labels <code class="docutils literal notranslate"><span class="pre">'a':'f'</span></code> (Note that contrary to usual python
slices, <strong>both</strong> the start and the stop are included, when present in the
index! See <a class="reference internal" href="#indexing-slicing-with-labels"><span class="std std-ref">Slicing with labels</span></a>.).</p></li>
<li><p>A boolean array</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">callable</span></code> function with one argument (the calling Series, DataFrame or Panel) and
that returns valid output for indexing (one of the above).</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.1.</span></p>
</div>
</li>
</ul>
</div></blockquote>
<p>See more at <a class="reference internal" href="#indexing-label"><span class="std std-ref">Selection by Label</span></a>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">.iloc</span></code> is primarily integer position based (from <code class="docutils literal notranslate"><span class="pre">0</span></code> to
<code class="docutils literal notranslate"><span class="pre">length-1</span></code> of the axis), but may also be used with a boolean
array.  <code class="docutils literal notranslate"><span class="pre">.iloc</span></code> will raise <code class="docutils literal notranslate"><span class="pre">IndexError</span></code> if a requested
indexer is out-of-bounds, except <em>slice</em> indexers which allow
out-of-bounds indexing.  (this conforms with Python/NumPy <em>slice</em>
semantics).  Allowed inputs are:</p>
<blockquote>
<div><ul>
<li><p>An integer e.g. <code class="docutils literal notranslate"><span class="pre">5</span></code>.</p></li>
<li><p>A list or array of integers <code class="docutils literal notranslate"><span class="pre">[4,</span> <span class="pre">3,</span> <span class="pre">0]</span></code>.</p></li>
<li><p>A slice object with ints <code class="docutils literal notranslate"><span class="pre">1:7</span></code>.</p></li>
<li><p>A boolean array.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">callable</span></code> function with one argument (the calling Series, DataFrame or Panel) and
that returns valid output for indexing (one of the above).</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.1.</span></p>
</div>
</li>
</ul>
</div></blockquote>
<p>See more at <a class="reference internal" href="#indexing-integer"><span class="std std-ref">Selection by Position</span></a>,
<a class="reference internal" href="advanced.html#advanced"><span class="std std-ref">Advanced Indexing</span></a> and <a class="reference internal" href="advanced.html#advanced-advanced-hierarchical"><span class="std std-ref">Advanced
Hierarchical</span></a>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">.loc</span></code>, <code class="docutils literal notranslate"><span class="pre">.iloc</span></code>, and also <code class="docutils literal notranslate"><span class="pre">[]</span></code> indexing can accept a <code class="docutils literal notranslate"><span class="pre">callable</span></code> as indexer. See more at <a class="reference internal" href="#indexing-callable"><span class="std std-ref">Selection By Callable</span></a>.</p></li>
</ul>
<p>Getting values from an object with multi-axes selection uses the following
notation (using <code class="docutils literal notranslate"><span class="pre">.loc</span></code> as an example, but the following applies to <code class="docutils literal notranslate"><span class="pre">.iloc</span></code> as
well). Any of the axes accessors may be the null slice <code class="docutils literal notranslate"><span class="pre">:</span></code>. Axes left out of
the specification are assumed to be <code class="docutils literal notranslate"><span class="pre">:</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">p.loc['a']</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">p.loc['a',</span> <span class="pre">:,</span> <span class="pre">:]</span></code>.</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 38%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Object Type</p></th>
<th class="head"><p>Indexers</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Series</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">s.loc[indexer]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>DataFrame</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">df.loc[row_indexer,column_indexer]</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Panel</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">p.loc[item_indexer,major_indexer,minor_indexer]</span></code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="basics">
<span id="indexing-basics"></span><h2>Basics<a class="headerlink" href="#basics" title="Permalink to this headline">¶</a></h2>
<p>As mentioned when introducing the data structures in the <a class="reference internal" href="../getting_started/basics.html#basics"><span class="std std-ref">last section</span></a>, the primary function of indexing with <code class="docutils literal notranslate"><span class="pre">[]</span></code> (a.k.a. <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>
for those familiar with implementing class behavior in Python) is selecting out
lower-dimensional slices. The following table shows return type values when
indexing pandas objects with <code class="docutils literal notranslate"><span class="pre">[]</span></code>:</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Object Type</p></th>
<th class="head"><p>Selection</p></th>
<th class="head"><p>Return Value Type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Series</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">series[label]</span></code></p></td>
<td><p>scalar value</p></td>
</tr>
<tr class="row-odd"><td><p>DataFrame</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">frame[colname]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Series</span></code> corresponding to colname</p></td>
</tr>
<tr class="row-even"><td><p>Panel</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">panel[itemname]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> corresponding to the itemname</p></td>
</tr>
</tbody>
</table>
<p>Here we construct a simple time series data set to use for illustrating the
indexing functionality:</p>
<pre class="literal-block">In [1]: dates = pd.date_range('1/1/2000', periods=8)

In [2]: df = pd.DataFrame(np.random.randn(8, 4), index=dates, columns=['A', 'B', 'C', 'D'])

In [3]: df
Out[3]: 
                   A         B         C         D
2000-01-01  0.469112 -0.282863 -1.509059 -1.135632
2000-01-02  1.212112 -0.173215  0.119209 -1.044236
2000-01-03 -0.861849 -2.104569 -0.494929  1.071804
2000-01-04  0.721555 -0.706771 -1.039575  0.271860
2000-01-05 -0.424972  0.567020  0.276232 -1.087401
2000-01-06 -0.673690  0.113648 -1.478427  0.524988
2000-01-07  0.404705  0.577046 -1.715002 -1.039268
2000-01-08 -0.370647 -1.157892 -1.344312  0.844885

[8 rows x 4 columns]

In [4]: panel = pd.Panel({'one' : df, 'two' : df - df.mean()})
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-4-f010da802b28&gt; in &lt;module&gt;
----&gt; 1 panel = pd.Panel({'one' : df, 'two' : df - df.mean()})

TypeError: Panel() takes no arguments

In [5]: panel
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-5-2129849e742b&gt; in &lt;module&gt;
----&gt; 1 panel

NameError: name 'panel' is not defined</pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>None of the indexing functionality is time series specific unless
specifically stated.</p>
</div>
<p>Thus, as per above, we have the most basic indexing using <code class="docutils literal notranslate"><span class="pre">[]</span></code>:</p>
<pre class="literal-block">In [6]: s = df['A']

In [7]: s[dates[5]]
Out[7]: -0.6736897080883706

In [8]: panel['two']
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-8-77b6a8473e7f&gt; in &lt;module&gt;
----&gt; 1 panel['two']

NameError: name 'panel' is not defined</pre>
<p>You can pass a list of columns to <code class="docutils literal notranslate"><span class="pre">[]</span></code> to select columns in that order.
If a column is not contained in the DataFrame, an exception will be
raised. Multiple columns can also be set in this manner:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [9]: </span><span class="n">df</span>
<span class="gh">Out[9]: </span><span class="go"></span>
<span class="go">                   A         B         C         D</span>
<span class="go">2000-01-01  0.469112 -0.282863 -1.509059 -1.135632</span>
<span class="go">2000-01-02  1.212112 -0.173215  0.119209 -1.044236</span>
<span class="go">2000-01-03 -0.861849 -2.104569 -0.494929  1.071804</span>
<span class="go">2000-01-04  0.721555 -0.706771 -1.039575  0.271860</span>
<span class="go">2000-01-05 -0.424972  0.567020  0.276232 -1.087401</span>
<span class="go">2000-01-06 -0.673690  0.113648 -1.478427  0.524988</span>
<span class="go">2000-01-07  0.404705  0.577046 -1.715002 -1.039268</span>
<span class="go">2000-01-08 -0.370647 -1.157892 -1.344312  0.844885</span>

<span class="go">[8 rows x 4 columns]</span>

<span class="gp">In [10]: </span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">]]</span>

<span class="gp">In [11]: </span><span class="n">df</span>
<span class="gh">Out[11]: </span><span class="go"></span>
<span class="go">                   A         B         C         D</span>
<span class="go">2000-01-01 -0.282863  0.469112 -1.509059 -1.135632</span>
<span class="go">2000-01-02 -0.173215  1.212112  0.119209 -1.044236</span>
<span class="go">2000-01-03 -2.104569 -0.861849 -0.494929  1.071804</span>
<span class="go">2000-01-04 -0.706771  0.721555 -1.039575  0.271860</span>
<span class="go">2000-01-05  0.567020 -0.424972  0.276232 -1.087401</span>
<span class="go">2000-01-06  0.113648 -0.673690 -1.478427  0.524988</span>
<span class="go">2000-01-07  0.577046  0.404705 -1.715002 -1.039268</span>
<span class="go">2000-01-08 -1.157892 -0.370647 -1.344312  0.844885</span>

<span class="go">[8 rows x 4 columns]</span>
</pre></div>
</div>
<p>You may find this useful for applying a transform (in-place) to a subset of the
columns.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>pandas aligns all AXES when setting <code class="docutils literal notranslate"><span class="pre">Series</span></code> and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> from <code class="docutils literal notranslate"><span class="pre">.loc</span></code>, and <code class="docutils literal notranslate"><span class="pre">.iloc</span></code>.</p>
<p>This will <strong>not</strong> modify <code class="docutils literal notranslate"><span class="pre">df</span></code> because the column alignment is before value assignment.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [12]: </span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">]]</span>
<span class="gh">Out[12]: </span><span class="go"></span>
<span class="go">                   A         B</span>
<span class="go">2000-01-01 -0.282863  0.469112</span>
<span class="go">2000-01-02 -0.173215  1.212112</span>
<span class="go">2000-01-03 -2.104569 -0.861849</span>
<span class="go">2000-01-04 -0.706771  0.721555</span>
<span class="go">2000-01-05  0.567020 -0.424972</span>
<span class="go">2000-01-06  0.113648 -0.673690</span>
<span class="go">2000-01-07  0.577046  0.404705</span>
<span class="go">2000-01-08 -1.157892 -0.370647</span>

<span class="go">[8 rows x 2 columns]</span>

<span class="gp">In [13]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">]]</span>

<span class="gp">In [14]: </span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">]]</span>
<span class="gh">Out[14]: </span><span class="go"></span>
<span class="go">                   A         B</span>
<span class="go">2000-01-01 -0.282863  0.469112</span>
<span class="go">2000-01-02 -0.173215  1.212112</span>
<span class="go">2000-01-03 -2.104569 -0.861849</span>
<span class="go">2000-01-04 -0.706771  0.721555</span>
<span class="go">2000-01-05  0.567020 -0.424972</span>
<span class="go">2000-01-06  0.113648 -0.673690</span>
<span class="go">2000-01-07  0.577046  0.404705</span>
<span class="go">2000-01-08 -1.157892 -0.370647</span>

<span class="go">[8 rows x 2 columns]</span>
</pre></div>
</div>
<p>The correct way to swap column values is by using raw values:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [15]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

<span class="gp">In [16]: </span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">]]</span>
<span class="gh">Out[16]: </span><span class="go"></span>
<span class="go">                   A         B</span>
<span class="go">2000-01-01  0.469112 -0.282863</span>
<span class="go">2000-01-02  1.212112 -0.173215</span>
<span class="go">2000-01-03 -0.861849 -2.104569</span>
<span class="go">2000-01-04  0.721555 -0.706771</span>
<span class="go">2000-01-05 -0.424972  0.567020</span>
<span class="go">2000-01-06 -0.673690  0.113648</span>
<span class="go">2000-01-07  0.404705  0.577046</span>
<span class="go">2000-01-08 -0.370647 -1.157892</span>

<span class="go">[8 rows x 2 columns]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="attribute-access">
<h2>Attribute Access<a class="headerlink" href="#attribute-access" title="Permalink to this headline">¶</a></h2>
<p id="indexing-attribute-access"><span id="indexing-df-cols"></span><span id="indexing-columns-multiple"></span>You may access an index on a <code class="docutils literal notranslate"><span class="pre">Series</span></code>, column on a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>, and an item on a <code class="docutils literal notranslate"><span class="pre">Panel</span></code> directly
as an attribute:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [17]: </span><span class="n">sa</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="n">index</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">))</span>

<span class="gp">In [18]: </span><span class="n">dfa</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
<pre class="literal-block">In [19]: sa.b
Out[19]: 2

In [20]: dfa.A
Out[20]: 
2000-01-01    0.469112
2000-01-02    1.212112
2000-01-03   -0.861849
2000-01-04    0.721555
2000-01-05   -0.424972
2000-01-06   -0.673690
2000-01-07    0.404705
2000-01-08   -0.370647
Freq: D, Name: A, Length: 8, dtype: float64

In [21]: panel.one
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-21-84b0e8d18050&gt; in &lt;module&gt;
----&gt; 1 panel.one

NameError: name 'panel' is not defined</pre>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [22]: </span><span class="n">sa</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">5</span>

<span class="gp">In [23]: </span><span class="n">sa</span>
<span class="gh">Out[23]: </span><span class="go"></span>
<span class="go">a    5</span>
<span class="go">b    2</span>
<span class="go">c    3</span>
<span class="go">Length: 3, dtype: int64</span>

<span class="gp">In [24]: </span><span class="n">dfa</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dfa</span><span class="o">.</span><span class="n">index</span><span class="p">)))</span>  <span class="c1"># ok if A already exists</span>

<span class="gp">In [25]: </span><span class="n">dfa</span>
<span class="gh">Out[25]: </span><span class="go"></span>
<span class="go">            A         B         C         D</span>
<span class="go">2000-01-01  0 -0.282863 -1.509059 -1.135632</span>
<span class="go">2000-01-02  1 -0.173215  0.119209 -1.044236</span>
<span class="go">2000-01-03  2 -2.104569 -0.494929  1.071804</span>
<span class="go">2000-01-04  3 -0.706771 -1.039575  0.271860</span>
<span class="go">2000-01-05  4  0.567020  0.276232 -1.087401</span>
<span class="go">2000-01-06  5  0.113648 -1.478427  0.524988</span>
<span class="go">2000-01-07  6  0.577046 -1.715002 -1.039268</span>
<span class="go">2000-01-08  7 -1.157892 -1.344312  0.844885</span>

<span class="go">[8 rows x 4 columns]</span>

<span class="gp">In [26]: </span><span class="n">dfa</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dfa</span><span class="o">.</span><span class="n">index</span><span class="p">)))</span>  <span class="c1"># use this form to create a new column</span>

<span class="gp">In [27]: </span><span class="n">dfa</span>
<span class="gh">Out[27]: </span><span class="go"></span>
<span class="go">            A         B         C         D</span>
<span class="go">2000-01-01  0 -0.282863 -1.509059 -1.135632</span>
<span class="go">2000-01-02  1 -0.173215  0.119209 -1.044236</span>
<span class="go">2000-01-03  2 -2.104569 -0.494929  1.071804</span>
<span class="go">2000-01-04  3 -0.706771 -1.039575  0.271860</span>
<span class="go">2000-01-05  4  0.567020  0.276232 -1.087401</span>
<span class="go">2000-01-06  5  0.113648 -1.478427  0.524988</span>
<span class="go">2000-01-07  6  0.577046 -1.715002 -1.039268</span>
<span class="go">2000-01-08  7 -1.157892 -1.344312  0.844885</span>

<span class="go">[8 rows x 4 columns]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<ul class="simple">
<li><p>You can use this access only if the index element is a valid Python identifier, e.g. <code class="docutils literal notranslate"><span class="pre">s.1</span></code> is not allowed.
See <a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#identifiers">here for an explanation of valid identifiers</a>.</p></li>
<li><p>The attribute will not be available if it conflicts with an existing method name, e.g. <code class="docutils literal notranslate"><span class="pre">s.min</span></code> is not allowed.</p></li>
<li><p>Similarly, the attribute will not be available if it conflicts with any of the following list: <code class="docutils literal notranslate"><span class="pre">index</span></code>,
<code class="docutils literal notranslate"><span class="pre">major_axis</span></code>, <code class="docutils literal notranslate"><span class="pre">minor_axis</span></code>, <code class="docutils literal notranslate"><span class="pre">items</span></code>.</p></li>
<li><p>In any of these cases, standard indexing will still work, e.g. <code class="docutils literal notranslate"><span class="pre">s['1']</span></code>, <code class="docutils literal notranslate"><span class="pre">s['min']</span></code>, and <code class="docutils literal notranslate"><span class="pre">s['index']</span></code> will
access the corresponding element or column.</p></li>
</ul>
</div>
<p>If you are using the IPython environment, you may also use tab-completion to
see these accessible attributes.</p>
<p>You can also assign a <code class="docutils literal notranslate"><span class="pre">dict</span></code> to a row of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [28]: </span><span class="n">x</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span>

<span class="gp">In [29]: </span><span class="n">x</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">99</span><span class="p">)</span>

<span class="gp">In [30]: </span><span class="n">x</span>
<span class="gh">Out[30]: </span><span class="go"></span>
<span class="go">   x   y</span>
<span class="go">0  1   3</span>
<span class="go">1  9  99</span>
<span class="go">2  3   5</span>

<span class="go">[3 rows x 2 columns]</span>
</pre></div>
</div>
<p>You can use attribute access to modify an existing element of a Series or column of a DataFrame, but be careful;
if you try to use attribute access to create a new column, it creates a new attribute rather than a
new column. In 0.21.0 and later, this will raise a <code class="docutils literal notranslate"><span class="pre">UserWarning</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="n">In</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]})</span>
<span class="n">In</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">df</span><span class="o">.</span><span class="n">two</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="ne">UserWarning</span><span class="p">:</span> <span class="n">Pandas</span> <span class="n">doesn</span><span class="s1">&#39;t allow Series to be assigned into nonexistent columns - see https://pandas.pydata.org/pandas-docs/stable/indexing.html#attribute_access</span>
<span class="n">In</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="n">df</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
   <span class="n">one</span>
<span class="mi">0</span>  <span class="mf">1.0</span>
<span class="mi">1</span>  <span class="mf">2.0</span>
<span class="mi">2</span>  <span class="mf">3.0</span>
</pre></div>
</div>
</div>
<div class="section" id="slicing-ranges">
<h2>Slicing ranges<a class="headerlink" href="#slicing-ranges" title="Permalink to this headline">¶</a></h2>
<p>The most robust and consistent way of slicing ranges along arbitrary axes is
described in the <a class="reference internal" href="#indexing-integer"><span class="std std-ref">Selection by Position</span></a> section
detailing the <code class="docutils literal notranslate"><span class="pre">.iloc</span></code> method. For now, we explain the semantics of slicing using the <code class="docutils literal notranslate"><span class="pre">[]</span></code> operator.</p>
<p>With Series, the syntax works exactly as with an ndarray, returning a slice of
the values and the corresponding labels:</p>
<pre class="literal-block">In [31]: s[:5]
Out[31]: 
2000-01-01    0.469112
2000-01-02    1.212112
2000-01-03   -0.861849
2000-01-04    0.721555
2000-01-05   -0.424972
Freq: D, Name: A, Length: 5, dtype: float64

In [32]: s[::2]
Out[32]: 
2000-01-01    0.469112
2000-01-03   -0.861849
2000-01-05   -0.424972
2000-01-07    0.404705
Freq: 2D, Name: A, Length: 4, dtype: float64

In [33]: s[::-1]
Out[33]: 
2000-01-08   -0.370647
2000-01-07    0.404705
2000-01-06   -0.673690
2000-01-05   -0.424972
2000-01-04    0.721555
2000-01-03   -0.861849
2000-01-02    1.212112
2000-01-01    0.469112
Freq: -1D, Name: A, Length: 8, dtype: float64</pre>
<p>Note that setting works as well:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [34]: </span><span class="n">s2</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="gp">In [35]: </span><span class="n">s2</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="gp">In [36]: </span><span class="n">s2</span>
<span class="gh">Out[36]: </span><span class="go"></span>
<span class="go">2000-01-01    0.000000</span>
<span class="go">2000-01-02    0.000000</span>
<span class="go">2000-01-03    0.000000</span>
<span class="go">2000-01-04    0.000000</span>
<span class="go">2000-01-05    0.000000</span>
<span class="go">2000-01-06   -0.673690</span>
<span class="go">2000-01-07    0.404705</span>
<span class="go">2000-01-08   -0.370647</span>
<span class="go">Freq: D, Name: A, Length: 8, dtype: float64</span>
</pre></div>
</div>
<p>With DataFrame, slicing inside of <code class="docutils literal notranslate"><span class="pre">[]</span></code> <strong>slices the rows</strong>. This is provided
largely as a convenience since it is such a common operation.</p>
<pre class="literal-block">In [37]: df[:3]
Out[37]: 
                   A         B         C         D
2000-01-01  0.469112 -0.282863 -1.509059 -1.135632
2000-01-02  1.212112 -0.173215  0.119209 -1.044236
2000-01-03 -0.861849 -2.104569 -0.494929  1.071804

[3 rows x 4 columns]

In [38]: df[::-1]
Out[38]: 
                   A         B         C         D
2000-01-08 -0.370647 -1.157892 -1.344312  0.844885
2000-01-07  0.404705  0.577046 -1.715002 -1.039268
2000-01-06 -0.673690  0.113648 -1.478427  0.524988
2000-01-05 -0.424972  0.567020  0.276232 -1.087401
2000-01-04  0.721555 -0.706771 -1.039575  0.271860
2000-01-03 -0.861849 -2.104569 -0.494929  1.071804
2000-01-02  1.212112 -0.173215  0.119209 -1.044236
2000-01-01  0.469112 -0.282863 -1.509059 -1.135632

[8 rows x 4 columns]</pre>
</div>
<div class="section" id="selection-by-label">
<span id="indexing-label"></span><h2>Selection By Label<a class="headerlink" href="#selection-by-label" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Whether a copy or a reference is returned for a setting operation, may depend on the context.
This is sometimes called <code class="docutils literal notranslate"><span class="pre">chained</span> <span class="pre">assignment</span></code> and should be avoided.
See <a class="reference internal" href="#indexing-view-versus-copy"><span class="std std-ref">Returning a View versus Copy</span></a>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">.loc</span></code> is strict when you present slicers that are not compatible (or convertible) with the index type. For example
using integers in a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>. These will raise a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>.</p>
</div></blockquote>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [39]: </span><span class="n">dfl</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;ABCD&#39;</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;20130101&#39;</span><span class="p">,</span><span class="n">periods</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span>

<span class="gp">In [40]: </span><span class="n">dfl</span>
<span class="gh">Out[40]: </span><span class="go"></span>
<span class="go">                   A         B         C         D</span>
<span class="go">2013-01-01  1.075770 -0.109050  1.643563 -1.469388</span>
<span class="go">2013-01-02  0.357021 -0.674600 -1.776904 -0.968914</span>
<span class="go">2013-01-03 -1.294524  0.413738  0.276662 -0.472035</span>
<span class="go">2013-01-04 -0.013960 -0.362543 -0.006154 -0.923061</span>
<span class="go">2013-01-05  0.895717  0.805244 -1.206412  2.565646</span>

<span class="go">[5 rows x 4 columns]</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">dfl</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">TypeError: cannot do slice indexing on &lt;class &#39;pandas.tseries.index.DatetimeIndex&#39;&gt; with these indexers [2] of &lt;type &#39;int&#39;&gt;</span>
</pre></div>
</div>
<p>String likes in slicing <em>can</em> be convertible to the type of the index and lead to natural slicing.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [41]: </span><span class="n">dfl</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;20130102&#39;</span><span class="p">:</span><span class="s1">&#39;20130104&#39;</span><span class="p">]</span>
<span class="gh">Out[41]: </span><span class="go"></span>
<span class="go">                   A         B         C         D</span>
<span class="go">2013-01-02  0.357021 -0.674600 -1.776904 -0.968914</span>
<span class="go">2013-01-03 -1.294524  0.413738  0.276662 -0.472035</span>
<span class="go">2013-01-04 -0.013960 -0.362543 -0.006154 -0.923061</span>

<span class="go">[3 rows x 4 columns]</span>
</pre></div>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Starting in 0.21.0, pandas will show a <code class="docutils literal notranslate"><span class="pre">FutureWarning</span></code> if indexing with a list with missing labels. In the future
this will raise a <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>. See <a class="reference internal" href="#indexing-deprecate-loc-reindex-listlike"><span class="std std-ref">list-like Using loc with missing keys in a list is Deprecated</span></a>.</p>
</div>
<p>pandas provides a suite of methods in order to have <strong>purely label based indexing</strong>. This is a strict inclusion based protocol.
Every label asked for must be in the index, or a <code class="docutils literal notranslate"><span class="pre">KeyError</span></code> will be raised.
When slicing, both the start bound <strong>AND</strong> the stop bound are <em>included</em>, if present in the index.
Integers are valid labels, but they refer to the label <strong>and not the position</strong>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">.loc</span></code> attribute is the primary access method. The following are valid inputs:</p>
<ul class="simple">
<li><p>A single label, e.g. <code class="docutils literal notranslate"><span class="pre">5</span></code> or <code class="docutils literal notranslate"><span class="pre">'a'</span></code> (Note that <code class="docutils literal notranslate"><span class="pre">5</span></code> is interpreted as a <em>label</em> of the index. This use is <strong>not</strong> an integer position along the index.).</p></li>
<li><p>A list or array of labels <code class="docutils literal notranslate"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c']</span></code>.</p></li>
<li><p>A slice object with labels <code class="docutils literal notranslate"><span class="pre">'a':'f'</span></code> (Note that contrary to usual python
slices, <strong>both</strong> the start and the stop are included, when present in the
index! See <a class="reference internal" href="#indexing-slicing-with-labels"><span class="std std-ref">Slicing with labels</span></a>.).</p></li>
<li><p>A boolean array.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">callable</span></code>, see <a class="reference internal" href="#indexing-callable"><span class="std std-ref">Selection By Callable</span></a>.</p></li>
</ul>
<pre class="literal-block">In [42]: s1 = pd.Series(np.random.randn(6),index=list('abcdef'))

In [43]: s1
Out[43]: 
a    1.431256
b    1.340309
c   -1.170299
d   -0.226169
e    0.410835
f    0.813850
Length: 6, dtype: float64

In [44]: s1.loc['c':]
Out[44]: 
c   -1.170299
d   -0.226169
e    0.410835
f    0.813850
Length: 4, dtype: float64

In [45]: s1.loc['b']
Out[45]: 1.3403088497993827</pre>
<p>Note that setting works as well:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [46]: </span><span class="n">s1</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="gp">In [47]: </span><span class="n">s1</span>
<span class="gh">Out[47]: </span><span class="go"></span>
<span class="go">a    1.431256</span>
<span class="go">b    1.340309</span>
<span class="go">c    0.000000</span>
<span class="go">d    0.000000</span>
<span class="go">e    0.000000</span>
<span class="go">f    0.000000</span>
<span class="go">Length: 6, dtype: float64</span>
</pre></div>
</div>
<p>With a DataFrame:</p>
<pre class="literal-block">In [48]: df1 = pd.DataFrame(np.random.randn(6,4),
   ....:                    index=list('abcdef'),
   ....:                    columns=list('ABCD'))
   ....: 

In [49]: df1
Out[49]: 
          A         B         C         D
a  0.132003 -0.827317 -0.076467 -1.187678
b  1.130127 -1.436737 -1.413681  1.607920
c  1.024180  0.569605  0.875906 -2.211372
d  0.974466 -2.006747 -0.410001 -0.078638
e  0.545952 -1.219217 -1.226825  0.769804
f -1.281247 -0.727707 -0.121306 -0.097883

[6 rows x 4 columns]

In [50]: df1.loc[['a', 'b', 'd'], :]
Out[50]: 
          A         B         C         D
a  0.132003 -0.827317 -0.076467 -1.187678
b  1.130127 -1.436737 -1.413681  1.607920
d  0.974466 -2.006747 -0.410001 -0.078638

[3 rows x 4 columns]</pre>
<p>Accessing via label slices:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [51]: </span><span class="n">df1</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">:,</span> <span class="s1">&#39;A&#39;</span><span class="p">:</span><span class="s1">&#39;C&#39;</span><span class="p">]</span>
<span class="gh">Out[51]: </span><span class="go"></span>
<span class="go">          A         B         C</span>
<span class="go">d  0.974466 -2.006747 -0.410001</span>
<span class="go">e  0.545952 -1.219217 -1.226825</span>
<span class="go">f -1.281247 -0.727707 -0.121306</span>

<span class="go">[3 rows x 3 columns]</span>
</pre></div>
</div>
<p>For getting a cross section using a label (equivalent to <code class="docutils literal notranslate"><span class="pre">df.xs('a')</span></code>):</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [52]: </span><span class="n">df1</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="gh">Out[52]: </span><span class="go"></span>
<span class="go">A    0.132003</span>
<span class="go">B   -0.827317</span>
<span class="go">C   -0.076467</span>
<span class="go">D   -1.187678</span>
<span class="go">Name: a, Length: 4, dtype: float64</span>
</pre></div>
</div>
<p>For getting values with a boolean array:</p>
<pre class="literal-block">In [53]: df1.loc['a'] &gt; 0
Out[53]: 
A     True
B    False
C    False
D    False
Name: a, Length: 4, dtype: bool

In [54]: df1.loc[:, df1.loc['a'] &gt; 0]
Out[54]: 
          A
a  0.132003
b  1.130127
c  1.024180
d  0.974466
e  0.545952
f -1.281247

[6 rows x 1 columns]</pre>
<p>For getting a value explicitly (equivalent to deprecated <code class="docutils literal notranslate"><span class="pre">df.get_value('a','A')</span></code>):</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># this is also equivalent to ``df1.at[&#39;a&#39;,&#39;A&#39;]``</span>
<span class="gp">In [55]: </span><span class="n">df1</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">]</span>
<span class="gh">Out[55]: </span><span class="go">0.13200317033032932</span>
</pre></div>
</div>
<div class="section" id="slicing-with-labels">
<span id="indexing-slicing-with-labels"></span><h3>Slicing with labels<a class="headerlink" href="#slicing-with-labels" title="Permalink to this headline">¶</a></h3>
<p>When using <code class="docutils literal notranslate"><span class="pre">.loc</span></code> with slices, if both the start and the stop labels are
present in the index, then elements <em>located</em> between the two (including them)
are returned:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [56]: </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;abcde&#39;</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>

<span class="gp">In [57]: </span><span class="n">s</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="gh">Out[57]: </span><span class="go"></span>
<span class="go">3    b</span>
<span class="go">2    c</span>
<span class="go">5    d</span>
<span class="go">Length: 3, dtype: object</span>
</pre></div>
</div>
<p>If at least one of the two is absent, but the index is sorted, and can be
compared against start and stop labels, then slicing will still work as
expected, by selecting labels which <em>rank</em> between the two:</p>
<pre class="literal-block">In [58]: s.sort_index()
Out[58]: 
0    a
2    c
3    b
4    e
5    d
Length: 5, dtype: object

In [59]: s.sort_index().loc[1:6]
Out[59]: 
2    c
3    b
4    e
5    d
Length: 4, dtype: object</pre>
<p>However, if at least one of the two is absent <em>and</em> the index is not sorted, an
error will be raised (since doing otherwise would be computationally expensive,
as well as potentially ambiguous for mixed type indexes). For instance, in the
above example, <code class="docutils literal notranslate"><span class="pre">s.loc[1:6]</span></code> would raise <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>.</p>
</div>
</div>
<div class="section" id="selection-by-position">
<span id="indexing-integer"></span><h2>Selection By Position<a class="headerlink" href="#selection-by-position" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Whether a copy or a reference is returned for a setting operation, may depend on the context.
This is sometimes called <code class="docutils literal notranslate"><span class="pre">chained</span> <span class="pre">assignment</span></code> and should be avoided.
See <a class="reference internal" href="#indexing-view-versus-copy"><span class="std std-ref">Returning a View versus Copy</span></a>.</p>
</div>
<p>Pandas provides a suite of methods in order to get <strong>purely integer based indexing</strong>. The semantics follow closely Python and NumPy slicing. These are <code class="docutils literal notranslate"><span class="pre">0-based</span></code> indexing. When slicing, the start bounds is <em>included</em>, while the upper bound is <em>excluded</em>. Trying to use a non-integer, even a <strong>valid</strong> label will raise an <code class="docutils literal notranslate"><span class="pre">IndexError</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">.iloc</span></code> attribute is the primary access method. The following are valid inputs:</p>
<ul class="simple">
<li><p>An integer e.g. <code class="docutils literal notranslate"><span class="pre">5</span></code>.</p></li>
<li><p>A list or array of integers <code class="docutils literal notranslate"><span class="pre">[4,</span> <span class="pre">3,</span> <span class="pre">0]</span></code>.</p></li>
<li><p>A slice object with ints <code class="docutils literal notranslate"><span class="pre">1:7</span></code>.</p></li>
<li><p>A boolean array.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">callable</span></code>, see <a class="reference internal" href="#indexing-callable"><span class="std std-ref">Selection By Callable</span></a>.</p></li>
</ul>
<pre class="literal-block">In [60]: s1 = pd.Series(np.random.randn(5), index=list(range(0,10,2)))

In [61]: s1
Out[61]: 
0    0.695775
2    0.341734
4    0.959726
6   -1.110336
8   -0.619976
Length: 5, dtype: float64

In [62]: s1.iloc[:3]
Out[62]: 
0    0.695775
2    0.341734
4    0.959726
Length: 3, dtype: float64

In [63]: s1.iloc[3]
Out[63]: -1.110336102891167</pre>
<p>Note that setting works as well:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [64]: </span><span class="n">s1</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="gp">In [65]: </span><span class="n">s1</span>
<span class="gh">Out[65]: </span><span class="go"></span>
<span class="go">0    0.000000</span>
<span class="go">2    0.000000</span>
<span class="go">4    0.000000</span>
<span class="go">6   -1.110336</span>
<span class="go">8   -0.619976</span>
<span class="go">Length: 5, dtype: float64</span>
</pre></div>
</div>
<p>With a DataFrame:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [66]: </span><span class="n">df1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span>
<span class="gp">   ....: </span>                   <span class="n">index</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span>
<span class="gp">   ....: </span>                   <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
<span class="gp">   ....: </span>

<span class="gp">In [67]: </span><span class="n">df1</span>
<span class="gh">Out[67]: </span><span class="go"></span>
<span class="go">           0         2         4         6</span>
<span class="go">0   0.149748 -0.732339  0.687738  0.176444</span>
<span class="go">2   0.403310 -0.154951  0.301624 -2.179861</span>
<span class="go">4  -1.369849 -0.954208  1.462696 -1.743161</span>
<span class="go">6  -0.826591 -0.345352  1.314232  0.690579</span>
<span class="go">8   0.995761  2.396780  0.014871  3.357427</span>
<span class="go">10 -0.317441 -1.236269  0.896171 -0.487602</span>

<span class="go">[6 rows x 4 columns]</span>
</pre></div>
</div>
<p>Select via integer slicing:</p>
<pre class="literal-block">In [68]: df1.iloc[:3]
Out[68]: 
          0         2         4         6
0  0.149748 -0.732339  0.687738  0.176444
2  0.403310 -0.154951  0.301624 -2.179861
4 -1.369849 -0.954208  1.462696 -1.743161

[3 rows x 4 columns]

In [69]: df1.iloc[1:5, 2:4]
Out[69]: 
          4         6
2  0.301624 -2.179861
4  1.462696 -1.743161
6  1.314232  0.690579
8  0.014871  3.357427

[4 rows x 2 columns]</pre>
<p>Select via integer list:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [70]: </span><span class="n">df1</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="gh">Out[70]: </span><span class="go"></span>
<span class="go">           2         6</span>
<span class="go">2  -0.154951 -2.179861</span>
<span class="go">6  -0.345352  0.690579</span>
<span class="go">10 -1.236269 -0.487602</span>

<span class="go">[3 rows x 2 columns]</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [71]: </span><span class="n">df1</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>
<span class="gh">Out[71]: </span><span class="go"></span>
<span class="go">          0         2         4         6</span>
<span class="go">2  0.403310 -0.154951  0.301624 -2.179861</span>
<span class="go">4 -1.369849 -0.954208  1.462696 -1.743161</span>

<span class="go">[2 rows x 4 columns]</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [72]: </span><span class="n">df1</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="gh">Out[72]: </span><span class="go"></span>
<span class="go">           2         4</span>
<span class="go">0  -0.732339  0.687738</span>
<span class="go">2  -0.154951  0.301624</span>
<span class="go">4  -0.954208  1.462696</span>
<span class="go">6  -0.345352  1.314232</span>
<span class="go">8   2.396780  0.014871</span>
<span class="go">10 -1.236269  0.896171</span>

<span class="go">[6 rows x 2 columns]</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># this is also equivalent to ``df1.iat[1,1]``</span>
<span class="gp">In [73]: </span><span class="n">df1</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gh">Out[73]: </span><span class="go">-0.1549507744249032</span>
</pre></div>
</div>
<p>For getting a cross section using an integer position (equiv to <code class="docutils literal notranslate"><span class="pre">df.xs(1)</span></code>):</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [74]: </span><span class="n">df1</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gh">Out[74]: </span><span class="go"></span>
<span class="go">0    0.403310</span>
<span class="go">2   -0.154951</span>
<span class="go">4    0.301624</span>
<span class="go">6   -2.179861</span>
<span class="go">Name: 2, Length: 4, dtype: float64</span>
</pre></div>
</div>
<p>Out of range slice indexes are handled gracefully just as in Python/Numpy.</p>
<pre class="literal-block"># these are allowed in python/numpy.
In [75]: x = list('abcdef')

In [76]: x
Out[76]: ['a', 'b', 'c', 'd', 'e', 'f']

In [77]: x[4:10]
Out[77]: ['e', 'f']

In [78]: x[8:10]
Out[78]: []

In [79]: s = pd.Series(x)

In [80]: s
Out[80]: 
0    a
1    b
2    c
3    d
4    e
5    f
Length: 6, dtype: object

In [81]: s.iloc[4:10]
Out[81]: 
4    e
5    f
Length: 2, dtype: object

In [82]: s.iloc[8:10]
Out[82]: Series([], Length: 0, dtype: object)</pre>
<p>Note that using slices that go out of bounds can result in
an empty axis (e.g. an empty DataFrame being returned).</p>
<pre class="literal-block">In [83]: dfl = pd.DataFrame(np.random.randn(5,2), columns=list('AB'))

In [84]: dfl
Out[84]: 
          A         B
0 -0.082240 -2.182937
1  0.380396  0.084844
2  0.432390  1.519970
3 -0.493662  0.600178
4  0.274230  0.132885

[5 rows x 2 columns]

In [85]: dfl.iloc[:, 2:3]
Out[85]: 
Empty DataFrame
Columns: []
Index: [0, 1, 2, 3, 4]

[5 rows x 0 columns]

In [86]: dfl.iloc[:, 1:3]
Out[86]: 
          B
0 -2.182937
1  0.084844
2  1.519970
3  0.600178
4  0.132885

[5 rows x 1 columns]

In [87]: dfl.iloc[4:6]
Out[87]: 
         A         B
4  0.27423  0.132885

[1 rows x 2 columns]</pre>
<p>A single indexer that is out of bounds will raise an <code class="docutils literal notranslate"><span class="pre">IndexError</span></code>.
A list of indexers where any element is out of bounds will raise an
<code class="docutils literal notranslate"><span class="pre">IndexError</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dfl</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]</span>
<span class="go">IndexError: positional indexers are out-of-bounds</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">dfl</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span>
<span class="go">IndexError: single positional indexer is out-of-bounds</span>
</pre></div>
</div>
</div>
<div class="section" id="selection-by-callable">
<span id="indexing-callable"></span><h2>Selection By Callable<a class="headerlink" href="#selection-by-callable" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.1.</span></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">.loc</span></code>, <code class="docutils literal notranslate"><span class="pre">.iloc</span></code>, and also <code class="docutils literal notranslate"><span class="pre">[]</span></code> indexing can accept a <code class="docutils literal notranslate"><span class="pre">callable</span></code> as indexer.
The <code class="docutils literal notranslate"><span class="pre">callable</span></code> must be a function with one argument (the calling Series, DataFrame or Panel) and that returns valid output for indexing.</p>
<pre class="literal-block">In [88]: df1 = pd.DataFrame(np.random.randn(6, 4),
   ....:                    index=list('abcdef'),
   ....:                    columns=list('ABCD'))
   ....: 

In [89]: df1
Out[89]: 
          A         B         C         D
a -0.023688  2.410179  1.450520  0.206053
b -0.251905 -2.213588  1.063327  1.266143
c  0.299368 -0.863838  0.408204 -1.048089
d -0.025747 -0.988387  0.094055  1.262731
e  1.289997  0.082423 -0.055758  0.536580
f -0.489682  0.369374 -0.034571 -2.484478

[6 rows x 4 columns]

In [90]: df1.loc[lambda df: df.A &gt; 0, :]
Out[90]: 
          A         B         C         D
c  0.299368 -0.863838  0.408204 -1.048089
e  1.289997  0.082423 -0.055758  0.536580

[2 rows x 4 columns]

In [91]: df1.loc[:, lambda df: ['A', 'B']]
Out[91]: 
          A         B
a -0.023688  2.410179
b -0.251905 -2.213588
c  0.299368 -0.863838
d -0.025747 -0.988387
e  1.289997  0.082423
f -0.489682  0.369374

[6 rows x 2 columns]

In [92]: df1.iloc[:, lambda df: [0, 1]]
Out[92]: 
          A         B
a -0.023688  2.410179
b -0.251905 -2.213588
c  0.299368 -0.863838
d -0.025747 -0.988387
e  1.289997  0.082423
f -0.489682  0.369374

[6 rows x 2 columns]

In [93]: df1[lambda df: df.columns[0]]
Out[93]: 
a   -0.023688
b   -0.251905
c    0.299368
d   -0.025747
e    1.289997
f   -0.489682
Name: A, Length: 6, dtype: float64</pre>
<p>You can use callable indexing in <code class="docutils literal notranslate"><span class="pre">Series</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [94]: </span><span class="n">df1</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
<span class="gh">Out[94]: </span><span class="go"></span>
<span class="go">c    0.299368</span>
<span class="go">e    1.289997</span>
<span class="go">Name: A, Length: 2, dtype: float64</span>
</pre></div>
</div>
<p>Using these methods / indexers, you can chain data selection operations
without using temporary variable.</p>
<pre class="literal-block">In [95]: bb = pd.read_csv('data/baseball.csv', index_col='id')
---------------------------------------------------------------------------
FileNotFoundError                         Traceback (most recent call last)
&lt;ipython-input-95-5a1f3f1f95d6&gt; in &lt;module&gt;
----&gt; 1 bb = pd.read_csv('data/baseball.csv', index_col='id')

~/miniconda/lib/python3.7/site-packages/pandas/io/parsers.py in parser_f(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, squeeze, prefix, mangle_dupe_cols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, dialect, error_bad_lines, warn_bad_lines, delim_whitespace, low_memory, memory_map, float_precision)
    683         )
    684 
--&gt; 685         return _read(filepath_or_buffer, kwds)
    686 
    687     parser_f.__name__ = name

~/miniconda/lib/python3.7/site-packages/pandas/io/parsers.py in _read(filepath_or_buffer, kwds)
    455 
    456     # Create the parser.
--&gt; 457     parser = TextFileReader(fp_or_buf, **kwds)
    458 
    459     if chunksize or iterator:

~/miniconda/lib/python3.7/site-packages/pandas/io/parsers.py in __init__(self, f, engine, **kwds)
    893             self.options[&quot;has_index_names&quot;] = kwds[&quot;has_index_names&quot;]
    894 
--&gt; 895         self._make_engine(self.engine)
    896 
    897     def close(self):

~/miniconda/lib/python3.7/site-packages/pandas/io/parsers.py in _make_engine(self, engine)
   1133     def _make_engine(self, engine=&quot;c&quot;):
   1134         if engine == &quot;c&quot;:
-&gt; 1135             self._engine = CParserWrapper(self.f, **self.options)
   1136         else:
   1137             if engine == &quot;python&quot;:

~/miniconda/lib/python3.7/site-packages/pandas/io/parsers.py in __init__(self, src, **kwds)
   1904         kwds[&quot;usecols&quot;] = self.usecols
   1905 
-&gt; 1906         self._reader = parsers.TextReader(src, **kwds)
   1907         self.unnamed_cols = self._reader.unnamed_cols
   1908 

pandas/_libs/parsers.pyx in pandas._libs.parsers.TextReader.__cinit__()

pandas/_libs/parsers.pyx in pandas._libs.parsers.TextReader._setup_parser_source()

FileNotFoundError: [Errno 2] File b'data/baseball.csv' does not exist: b'data/baseball.csv'

In [96]: (bb.groupby(['year', 'team']).sum()
   ....:    .loc[lambda df: df.r &gt; 100])
   ....: 
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
&lt;ipython-input-96-967f40e9d154&gt; in &lt;module&gt;
----&gt; 1 (bb.groupby(['year', 'team']).sum()
      2    .loc[lambda df: df.r &gt; 100])

NameError: name 'bb' is not defined</pre>
</div>
<div class="section" id="ix-indexer-is-deprecated">
<span id="indexing-deprecate-ix"></span><h2>IX Indexer is Deprecated<a class="headerlink" href="#ix-indexer-is-deprecated" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Starting in 0.20.0, the <code class="docutils literal notranslate"><span class="pre">.ix</span></code> indexer is deprecated, in favor of the more strict <code class="docutils literal notranslate"><span class="pre">.iloc</span></code>
and <code class="docutils literal notranslate"><span class="pre">.loc</span></code> indexers.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">.ix</span></code> offers a lot of magic on the inference of what the user wants to do. To wit, <code class="docutils literal notranslate"><span class="pre">.ix</span></code> can decide
to index <em>positionally</em> OR via <em>labels</em> depending on the data type of the index. This has caused quite a
bit of user confusion over the years.</p>
<p>The recommended methods of indexing are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.loc</span></code> if you want to <em>label</em> index.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.iloc</span></code> if you want to <em>positionally</em> index.</p></li>
</ul>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [97]: </span><span class="n">dfd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">   ....: </span>                    <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]},</span>
<span class="gp">   ....: </span>                   <span class="n">index</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">))</span>
<span class="gp">   ....: </span>

<span class="gp">In [98]: </span><span class="n">dfd</span>
<span class="gh">Out[98]: </span><span class="go"></span>
<span class="go">   A  B</span>
<span class="go">a  1  4</span>
<span class="go">b  2  5</span>
<span class="go">c  3  6</span>

<span class="go">[3 rows x 2 columns]</span>
</pre></div>
</div>
<p>Previous behavior, where you wish to get the 0th and the 2nd elements from the index in the ‘A’ column.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [3]: </span><span class="n">dfd</span><span class="o">.</span><span class="n">ix</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;A&#39;</span><span class="p">]</span>
<span class="gh">Out[3]:</span>
<span class="go">a    1</span>
<span class="go">c    3</span>
<span class="go">Name: A, dtype: int64</span>
</pre></div>
</div>
<p>Using <code class="docutils literal notranslate"><span class="pre">.loc</span></code>. Here we will select the appropriate indexes from the index, then use <em>label</em> indexing.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [99]: </span><span class="n">dfd</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dfd</span><span class="o">.</span><span class="n">index</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="s1">&#39;A&#39;</span><span class="p">]</span>
<span class="gh">Out[99]: </span><span class="go"></span>
<span class="go">a    1</span>
<span class="go">c    3</span>
<span class="go">Name: A, Length: 2, dtype: int64</span>
</pre></div>
</div>
<p>This can also be expressed using <code class="docutils literal notranslate"><span class="pre">.iloc</span></code>, by explicitly getting locations on the indexers, and using
<em>positional</em> indexing to select things.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [100]: </span><span class="n">dfd</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dfd</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)]</span>
<span class="gh">Out[100]: </span><span class="go"></span>
<span class="go">a    1</span>
<span class="go">c    3</span>
<span class="go">Name: A, Length: 2, dtype: int64</span>
</pre></div>
</div>
<p>For getting <em>multiple</em> indexers, using <code class="docutils literal notranslate"><span class="pre">.get_indexer</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [101]: </span><span class="n">dfd</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dfd</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">])]</span>
<span class="gh">Out[101]: </span><span class="go"></span>
<span class="go">   A  B</span>
<span class="go">a  1  4</span>
<span class="go">c  3  6</span>

<span class="go">[2 rows x 2 columns]</span>
</pre></div>
</div>
</div>
<div class="section" id="indexing-with-list-with-missing-labels-is-deprecated">
<span id="indexing-deprecate-loc-reindex-listlike"></span><span id="deprecate-loc-reindex-listlike"></span><h2>Indexing with list with missing labels is Deprecated<a class="headerlink" href="#indexing-with-list-with-missing-labels-is-deprecated" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Starting in 0.21.0, using <code class="docutils literal notranslate"><span class="pre">.loc</span></code> or <code class="docutils literal notranslate"><span class="pre">[]</span></code> with a list with one or more missing labels, is deprecated, in favor of <code class="docutils literal notranslate"><span class="pre">.reindex</span></code>.</p>
</div>
<p>In prior versions, using <code class="docutils literal notranslate"><span class="pre">.loc[list-of-labels]</span></code> would work as long as <em>at least 1</em> of the keys was found (otherwise it
would raise a <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>). This behavior is deprecated and will show a warning message pointing to this section. The
recommended alternative is to use <code class="docutils literal notranslate"><span class="pre">.reindex()</span></code>.</p>
<p>For example.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [102]: </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

<span class="gp">In [103]: </span><span class="n">s</span>
<span class="gh">Out[103]: </span><span class="go"></span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">Length: 3, dtype: int64</span>
</pre></div>
</div>
<p>Selection with all keys found is unchanged.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [104]: </span><span class="n">s</span><span class="o">.</span><span class="n">loc</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="gh">Out[104]: </span><span class="go"></span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">Length: 2, dtype: int64</span>
</pre></div>
</div>
<p>Previous Behavior</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">s</span><span class="o">.</span><span class="n">loc</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="gh">Out[4]:</span>
<span class="go">1    2.0</span>
<span class="go">2    3.0</span>
<span class="go">3    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>Current Behavior</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">s</span><span class="o">.</span><span class="n">loc</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="go">Passing list-likes to .loc with any non-matching elements will raise</span>
<span class="go">KeyError in the future, you can use .reindex() as an alternative.</span>

<span class="go">See the documentation here:</span>
<span class="go">http://pandas.pydata.org/pandas-docs/stable/indexing.html#deprecate-loc-reindex-listlike</span>

<span class="gh">Out[4]:</span>
<span class="go">1    2.0</span>
<span class="go">2    3.0</span>
<span class="go">3    NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<div class="section" id="reindexing">
<h3>Reindexing<a class="headerlink" href="#reindexing" title="Permalink to this headline">¶</a></h3>
<p>The idiomatic way to achieve selecting potentially not-found elements is via <code class="docutils literal notranslate"><span class="pre">.reindex()</span></code>. See also the section on <a class="reference internal" href="../getting_started/basics.html#basics-reindexing"><span class="std std-ref">reindexing</span></a>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [105]: </span><span class="n">s</span><span class="o">.</span><span class="n">reindex</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gh">Out[105]: </span><span class="go"></span>
<span class="go">1    2.0</span>
<span class="go">2    3.0</span>
<span class="go">3    NaN</span>
<span class="go">Length: 3, dtype: float64</span>
</pre></div>
</div>
<p>Alternatively, if you want to select only <em>valid</em> keys, the following is idiomatic and efficient; it is guaranteed to preserve the dtype of the selection.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [106]: </span><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="gp">In [107]: </span><span class="n">s</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">labels</span><span class="p">)]</span>
<span class="gh">Out[107]: </span><span class="go"></span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">Length: 2, dtype: int64</span>
</pre></div>
</div>
<p>Having a duplicated index will raise for a <code class="docutils literal notranslate"><span class="pre">.reindex()</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [108]: </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">])</span>

<span class="gp">In [109]: </span><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [17]: </span><span class="n">s</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span class="go">ValueError: cannot reindex from a duplicate axis</span>
</pre></div>
</div>
<p>Generally, you can intersect the desired labels with the current
axis, and then reindex.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [110]: </span><span class="n">s</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">labels</span><span class="p">)]</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span class="gh">Out[110]: </span><span class="go"></span>
<span class="go">c    3.0</span>
<span class="go">d    NaN</span>
<span class="go">Length: 2, dtype: float64</span>
</pre></div>
</div>
<p>However, this would <em>still</em> raise if your resulting index is duplicated.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [41]: </span><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">]</span>

<span class="gp">In [42]: </span><span class="n">s</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">labels</span><span class="p">)]</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span class="go">ValueError: cannot reindex from a duplicate axis</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="selecting-random-samples">
<span id="indexing-basics-partial-setting"></span><h2>Selecting Random Samples<a class="headerlink" href="#selecting-random-samples" title="Permalink to this headline">¶</a></h2>
<p>A random selection of rows or columns from a Series, DataFrame, or Panel with the <a class="reference internal" href="../generated/pandas.DataFrame.sample.html#pandas.DataFrame.sample" title="pandas.DataFrame.sample"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sample()</span></code></a> method. The method will sample rows by default, and accepts a specific number of rows/columns to return, or a fraction of rows.</p>
<pre class="literal-block">In [111]: s = pd.Series([0,1,2,3,4,5])

# When no arguments are passed, returns 1 row.
In [112]: s.sample()
Out[112]: 
4    4
Length: 1, dtype: int64

# One may specify either a number of rows:
In [113]: s.sample(n=3)
Out[113]: 
0    0
4    4
1    1
Length: 3, dtype: int64

# Or a fraction of the rows:
In [114]: s.sample(frac=0.5)
Out[114]: 
5    5
3    3
1    1
Length: 3, dtype: int64</pre>
<p>By default, <code class="docutils literal notranslate"><span class="pre">sample</span></code> will return each row at most once, but one can also sample with replacement
using the <code class="docutils literal notranslate"><span class="pre">replace</span></code> option:</p>
<pre class="literal-block">In [115]: s = pd.Series([0,1,2,3,4,5])

 # Without replacement (default):
In [116]: s.sample(n=6, replace=False)
Out[116]: 
0    0
1    1
5    5
3    3
2    2
4    4
Length: 6, dtype: int64

 # With replacement:
In [117]: s.sample(n=6, replace=True)
Out[117]: 
0    0
4    4
3    3
2    2
4    4
4    4
Length: 6, dtype: int64</pre>
<p>By default, each row has an equal probability of being selected, but if you want rows
to have different probabilities, you can pass the <code class="docutils literal notranslate"><span class="pre">sample</span></code> function sampling weights as
<code class="docutils literal notranslate"><span class="pre">weights</span></code>. These weights can be a list, a NumPy array, or a Series, but they must be of the same length as the object you are sampling. Missing values will be treated as a weight of zero, and inf values are not allowed. If weights do not sum to 1, they will be re-normalized by dividing all weights by the sum of the weights. For example:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [118]: </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>

<span class="gp">In [119]: </span><span class="n">example_weights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">]</span>

<span class="gp">In [120]: </span><span class="n">s</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">example_weights</span><span class="p">)</span>
<span class="gh">Out[120]: </span><span class="go"></span>
<span class="go">5    5</span>
<span class="go">4    4</span>
<span class="go">3    3</span>
<span class="go">Length: 3, dtype: int64</span>

<span class="go"># Weights will be re-normalized automatically</span>
<span class="gp">In [121]: </span><span class="n">example_weights2</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="gp">In [122]: </span><span class="n">s</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">example_weights2</span><span class="p">)</span>
<span class="gh">Out[122]: </span><span class="go"></span>
<span class="go">0    0</span>
<span class="go">Length: 1, dtype: int64</span>
</pre></div>
</div>
<p>When applied to a DataFrame, you can use a column of the DataFrame as sampling weights
(provided you are sampling rows and not columns) by simply passing the name of the column
as a string.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [123]: </span><span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;col1&#39;</span><span class="p">:[</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="s1">&#39;weight_column&#39;</span><span class="p">:[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]})</span>

<span class="gp">In [124]: </span><span class="n">df2</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="s1">&#39;weight_column&#39;</span><span class="p">)</span>
<span class="gh">Out[124]: </span><span class="go"></span>
<span class="go">   col1  weight_column</span>
<span class="go">1     8            0.4</span>
<span class="go">0     9            0.5</span>
<span class="go">2     7            0.1</span>

<span class="go">[3 rows x 2 columns]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">sample</span></code> also allows users to sample columns instead of rows using the <code class="docutils literal notranslate"><span class="pre">axis</span></code> argument.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [125]: </span><span class="n">df3</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;col1&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;col2&#39;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]})</span>

<span class="gp">In [126]: </span><span class="n">df3</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gh">Out[126]: </span><span class="go"></span>
<span class="go">   col1</span>
<span class="go">0     1</span>
<span class="go">1     2</span>
<span class="go">2     3</span>

<span class="go">[3 rows x 1 columns]</span>
</pre></div>
</div>
<p>Finally, one can also set a seed for <code class="docutils literal notranslate"><span class="pre">sample</span></code>’s random number generator using the <code class="docutils literal notranslate"><span class="pre">random_state</span></code> argument, which will accept either an integer (as a seed) or a NumPy RandomState object.</p>
<pre class="literal-block">In [127]: df4 = pd.DataFrame({'col1':[1,2,3], 'col2':[2,3,4]})

# With a given seed, the sample will always draw the same rows.
In [128]: df4.sample(n=2, random_state=2)
Out[128]: 
   col1  col2
2     3     4
1     2     3

[2 rows x 2 columns]

In [129]: df4.sample(n=2, random_state=2)
Out[129]: 
   col1  col2
2     3     4
1     2     3

[2 rows x 2 columns]</pre>
</div>
<div class="section" id="setting-with-enlargement">
<h2>Setting With Enlargement<a class="headerlink" href="#setting-with-enlargement" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">.loc/[]</span></code> operations can perform enlargement when setting a non-existent key for that axis.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">Series</span></code> case this is effectively an appending operation.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [130]: </span><span class="n">se</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>

<span class="gp">In [131]: </span><span class="n">se</span>
<span class="gh">Out[131]: </span><span class="go"></span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">Length: 3, dtype: int64</span>

<span class="gp">In [132]: </span><span class="n">se</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mf">5.</span>

<span class="gp">In [133]: </span><span class="n">se</span>
<span class="gh">Out[133]: </span><span class="go"></span>
<span class="go">0    1.0</span>
<span class="go">1    2.0</span>
<span class="go">2    3.0</span>
<span class="go">5    5.0</span>
<span class="go">Length: 4, dtype: float64</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> can be enlarged on either axis via <code class="docutils literal notranslate"><span class="pre">.loc</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [134]: </span><span class="n">dfi</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
<span class="gp">   .....: </span>                <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">])</span>
<span class="gp">   .....: </span>

<span class="gp">In [135]: </span><span class="n">dfi</span>
<span class="gh">Out[135]: </span><span class="go"></span>
<span class="go">   A  B</span>
<span class="go">0  0  1</span>
<span class="go">1  2  3</span>
<span class="go">2  4  5</span>

<span class="go">[3 rows x 2 columns]</span>

<span class="gp">In [136]: </span><span class="n">dfi</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s1">&#39;C&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfi</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>

<span class="gp">In [137]: </span><span class="n">dfi</span>
<span class="gh">Out[137]: </span><span class="go"></span>
<span class="go">   A  B  C</span>
<span class="go">0  0  1  0</span>
<span class="go">1  2  3  2</span>
<span class="go">2  4  5  4</span>

<span class="go">[3 rows x 3 columns]</span>
</pre></div>
</div>
<p>This is like an <code class="docutils literal notranslate"><span class="pre">append</span></code> operation on the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [138]: </span><span class="n">dfi</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>

<span class="gp">In [139]: </span><span class="n">dfi</span>
<span class="gh">Out[139]: </span><span class="go"></span>
<span class="go">   A  B  C</span>
<span class="go">0  0  1  0</span>
<span class="go">1  2  3  2</span>
<span class="go">2  4  5  4</span>
<span class="go">3  5  5  5</span>

<span class="go">[4 rows x 3 columns]</span>
</pre></div>
</div>
</div>
<div class="section" id="fast-scalar-value-getting-and-setting">
<span id="indexing-basics-get-value"></span><h2>Fast scalar value getting and setting<a class="headerlink" href="#fast-scalar-value-getting-and-setting" title="Permalink to this headline">¶</a></h2>
<p>Since indexing with <code class="docutils literal notranslate"><span class="pre">[]</span></code> must handle a lot of cases (single-label access,
slicing, boolean indexing, etc.), it has a bit of overhead in order to figure
out what you’re asking for. If you only want to access a scalar value, the
fastest way is to use the <code class="docutils literal notranslate"><span class="pre">at</span></code> and <code class="docutils literal notranslate"><span class="pre">iat</span></code> methods, which are implemented on
all of the data structures.</p>
<p>Similarly to <code class="docutils literal notranslate"><span class="pre">loc</span></code>, <code class="docutils literal notranslate"><span class="pre">at</span></code> provides <strong>label</strong> based scalar lookups, while, <code class="docutils literal notranslate"><span class="pre">iat</span></code> provides <strong>integer</strong> based lookups analogously to <code class="docutils literal notranslate"><span class="pre">iloc</span></code></p>
<pre class="literal-block">In [140]: s.iat[5]
Out[140]: 5

In [141]: df.at[dates[5], 'A']
Out[141]: -0.6736897080883706

In [142]: df.iat[3, 0]
Out[142]: 0.7215551622443669</pre>
<p>You can also set using these same indexers.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [143]: </span><span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">dates</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span>

<span class="gp">In [144]: </span><span class="n">df</span><span class="o">.</span><span class="n">iat</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">at</span></code> may enlarge the object in-place as above if the indexer is missing.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [145]: </span><span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">dates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span>

<span class="gp">In [146]: </span><span class="n">df</span>
<span class="gh">Out[146]: </span><span class="go"></span>
<span class="go">                   A         B         C         D    E    0</span>
<span class="go">2000-01-01  0.469112 -0.282863 -1.509059 -1.135632  NaN  NaN</span>
<span class="go">2000-01-02  1.212112 -0.173215  0.119209 -1.044236  NaN  NaN</span>
<span class="go">2000-01-03 -0.861849 -2.104569 -0.494929  1.071804  NaN  NaN</span>
<span class="go">2000-01-04  7.000000 -0.706771 -1.039575  0.271860  NaN  NaN</span>
<span class="go">2000-01-05 -0.424972  0.567020  0.276232 -1.087401  NaN  NaN</span>
<span class="go">2000-01-06 -0.673690  0.113648 -1.478427  0.524988  7.0  NaN</span>
<span class="go">2000-01-07  0.404705  0.577046 -1.715002 -1.039268  NaN  NaN</span>
<span class="go">2000-01-08 -0.370647 -1.157892 -1.344312  0.844885  NaN  NaN</span>
<span class="go">2000-01-09       NaN       NaN       NaN       NaN  NaN  7.0</span>

<span class="go">[9 rows x 6 columns]</span>
</pre></div>
</div>
</div>
<div class="section" id="boolean-indexing">
<h2>Boolean indexing<a class="headerlink" href="#boolean-indexing" title="Permalink to this headline">¶</a></h2>
<p id="indexing-boolean">Another common operation is the use of boolean vectors to filter the data.
The operators are: <code class="docutils literal notranslate"><span class="pre">|</span></code> for <code class="docutils literal notranslate"><span class="pre">or</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> for <code class="docutils literal notranslate"><span class="pre">and</span></code>, and <code class="docutils literal notranslate"><span class="pre">~</span></code> for <code class="docutils literal notranslate"><span class="pre">not</span></code>.
These <strong>must</strong> be grouped by using parentheses, since by default Python will
evaluate an expression such as <code class="docutils literal notranslate"><span class="pre">df.A</span> <span class="pre">&gt;</span> <span class="pre">2</span> <span class="pre">&amp;</span> <span class="pre">df.B</span> <span class="pre">&lt;</span> <span class="pre">3</span></code> as
<code class="docutils literal notranslate"><span class="pre">df.A</span> <span class="pre">&gt;</span> <span class="pre">(2</span> <span class="pre">&amp;</span> <span class="pre">df.B)</span> <span class="pre">&lt;</span> <span class="pre">3</span></code>, while the desired evaluation order is
<code class="docutils literal notranslate"><span class="pre">(df.A</span> <span class="pre">&gt;</span> <span class="pre">2)</span> <span class="pre">&amp;</span> <span class="pre">(df.B</span> <span class="pre">&lt;</span> <span class="pre">3)</span></code>.</p>
<p>Using a boolean vector to index a Series works exactly as in a NumPy ndarray:</p>
<pre class="literal-block">In [147]: s = pd.Series(range(-3, 4))

In [148]: s
Out[148]: 
0   -3
1   -2
2   -1
3    0
4    1
5    2
6    3
Length: 7, dtype: int64

In [149]: s[s &gt; 0]
Out[149]: 
4    1
5    2
6    3
Length: 3, dtype: int64

In [150]: s[(s &lt; -1) | (s &gt; 0.5)]
Out[150]: 
0   -3
1   -2
4    1
5    2
6    3
Length: 5, dtype: int64

In [151]: s[~(s &lt; 0)]
Out[151]: 
3    0
4    1
5    2
6    3
Length: 4, dtype: int64</pre>
<p>You may select rows from a DataFrame using a boolean vector the same length as
the DataFrame’s index (for example, something derived from one of the columns
of the DataFrame):</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [152]: </span><span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
<span class="gh">Out[152]: </span><span class="go"></span>
<span class="go">                   A         B         C         D   E   0</span>
<span class="go">2000-01-01  0.469112 -0.282863 -1.509059 -1.135632 NaN NaN</span>
<span class="go">2000-01-02  1.212112 -0.173215  0.119209 -1.044236 NaN NaN</span>
<span class="go">2000-01-04  7.000000 -0.706771 -1.039575  0.271860 NaN NaN</span>
<span class="go">2000-01-07  0.404705  0.577046 -1.715002 -1.039268 NaN NaN</span>

<span class="go">[4 rows x 6 columns]</span>
</pre></div>
</div>
<p>List comprehensions and <code class="docutils literal notranslate"><span class="pre">map</span></code> method of Series can also be used to produce
more complex criteria:</p>
<pre class="literal-block">In [153]: df2 = pd.DataFrame({'a' : ['one', 'one', 'two', 'three', 'two', 'one', 'six'],
   .....:                     'b' : ['x', 'y', 'y', 'x', 'y', 'x', 'x'],
   .....:                     'c' : np.random.randn(7)})
   .....: 

# only want 'two' or 'three'
In [154]: criterion = df2['a'].map(lambda x: x.startswith('t'))

In [155]: df2[criterion]
Out[155]: 
       a  b         c
2    two  y  0.041290
3  three  x  0.361719
4    two  y -0.238075

[3 rows x 3 columns]

# equivalent but slower
In [156]: df2[[x.startswith('t') for x in df2['a']]]
Out[156]: 
       a  b         c
2    two  y  0.041290
3  three  x  0.361719
4    two  y -0.238075

[3 rows x 3 columns]

# Multiple criteria
In [157]: df2[criterion &amp; (df2['b'] == 'x')]
Out[157]: 
       a  b         c
3  three  x  0.361719

[1 rows x 3 columns]</pre>
<p>With the choice methods <a class="reference internal" href="#indexing-label"><span class="std std-ref">Selection by Label</span></a>, <a class="reference internal" href="#indexing-integer"><span class="std std-ref">Selection by Position</span></a>,
and <a class="reference internal" href="advanced.html#advanced"><span class="std std-ref">Advanced Indexing</span></a> you may select along more than one axis using boolean vectors combined with other indexing expressions.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [158]: </span><span class="n">df2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">criterion</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df2</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">),</span><span class="s1">&#39;b&#39;</span><span class="p">:</span><span class="s1">&#39;c&#39;</span><span class="p">]</span>
<span class="gh">Out[158]: </span><span class="go"></span>
<span class="go">   b         c</span>
<span class="go">3  x  0.361719</span>

<span class="go">[1 rows x 2 columns]</span>
</pre></div>
</div>
</div>
<div class="section" id="indexing-with-isin">
<span id="indexing-basics-indexing-isin"></span><h2>Indexing with isin<a class="headerlink" href="#indexing-with-isin" title="Permalink to this headline">¶</a></h2>
<p>Consider the <a class="reference internal" href="../generated/pandas.Series.isin.html#pandas.Series.isin" title="pandas.Series.isin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isin()</span></code></a> method of <code class="docutils literal notranslate"><span class="pre">Series</span></code>, which returns a boolean
vector that is true wherever the <code class="docutils literal notranslate"><span class="pre">Series</span></code> elements exist in the passed list.
This allows you to select rows where one or more columns have values you want:</p>
<pre class="literal-block">In [159]: s = pd.Series(np.arange(5), index=np.arange(5)[::-1], dtype='int64')

In [160]: s
Out[160]: 
4    0
3    1
2    2
1    3
0    4
Length: 5, dtype: int64

In [161]: s.isin([2, 4, 6])
Out[161]: 
4    False
3    False
2     True
1    False
0     True
Length: 5, dtype: bool

In [162]: s[s.isin([2, 4, 6])]
Out[162]: 
2    2
0    4
Length: 2, dtype: int64</pre>
<p>The same method is available for <code class="docutils literal notranslate"><span class="pre">Index</span></code> objects and is useful for the cases
when you don’t know which of the sought labels are in fact present:</p>
<pre class="literal-block">In [163]: s[s.index.isin([2, 4, 6])]
Out[163]: 
4    0
2    2
Length: 2, dtype: int64

# compare it to the following
In [164]: s.reindex([2, 4, 6])
Out[164]: 
2    2.0
4    0.0
6    NaN
Length: 3, dtype: float64</pre>
<p>In addition to that, <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> allows selecting a separate level to use
in the membership check:</p>
<pre class="literal-block">In [165]: s_mi = pd.Series(np.arange(6),
   .....:                  index=pd.MultiIndex.from_product([[0, 1], ['a', 'b', 'c']]))
   .....: 

In [166]: s_mi
Out[166]: 
0  a    0
   b    1
   c    2
1  a    3
   b    4
   c    5
Length: 6, dtype: int64

In [167]: s_mi.iloc[s_mi.index.isin([(1, 'a'), (2, 'b'), (0, 'c')])]
Out[167]: 
0  c    2
1  a    3
Length: 2, dtype: int64

In [168]: s_mi.iloc[s_mi.index.isin(['a', 'c', 'e'], level=1)]
Out[168]: 
0  a    0
   c    2
1  a    3
   c    5
Length: 4, dtype: int64</pre>
<p>DataFrame also has an <a class="reference internal" href="../generated/pandas.DataFrame.isin.html#pandas.DataFrame.isin" title="pandas.DataFrame.isin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isin()</span></code></a> method.  When calling <code class="docutils literal notranslate"><span class="pre">isin</span></code>, pass a set of
values as either an array or dict.  If values is an array, <code class="docutils literal notranslate"><span class="pre">isin</span></code> returns
a DataFrame of booleans that is the same shape as the original DataFrame, with True
wherever the element is in the sequence of values.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [169]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;vals&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">&#39;ids&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">],</span>
<span class="gp">   .....: </span>                   <span class="s1">&#39;ids2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">]})</span>
<span class="gp">   .....: </span>

<span class="gp">In [170]: </span><span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="gp">In [171]: </span><span class="n">df</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="gh">Out[171]: </span><span class="go"></span>
<span class="go">    vals    ids   ids2</span>
<span class="go">0   True   True   True</span>
<span class="go">1  False   True  False</span>
<span class="go">2   True  False  False</span>
<span class="go">3  False  False  False</span>

<span class="go">[4 rows x 3 columns]</span>
</pre></div>
</div>
<p>Oftentimes you’ll want to match certain values with certain columns.
Just make values a <code class="docutils literal notranslate"><span class="pre">dict</span></code> where the key is the column, and the value is
a list of items you want to check for.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [172]: </span><span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ids&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;vals&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}</span>

<span class="gp">In [173]: </span><span class="n">df</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="gh">Out[173]: </span><span class="go"></span>
<span class="go">    vals    ids   ids2</span>
<span class="go">0   True   True  False</span>
<span class="go">1  False   True  False</span>
<span class="go">2   True  False  False</span>
<span class="go">3  False  False  False</span>

<span class="go">[4 rows x 3 columns]</span>
</pre></div>
</div>
<p>Combine DataFrame’s <code class="docutils literal notranslate"><span class="pre">isin</span></code> with the <code class="docutils literal notranslate"><span class="pre">any()</span></code> and <code class="docutils literal notranslate"><span class="pre">all()</span></code> methods to
quickly select subsets of your data that meet a given criteria.
To select a row where each column meets its own criterion:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [174]: </span><span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ids&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;ids2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="s1">&#39;vals&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}</span>

<span class="gp">In [175]: </span><span class="n">row_mask</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="gp">In [176]: </span><span class="n">df</span><span class="p">[</span><span class="n">row_mask</span><span class="p">]</span>
<span class="gh">Out[176]: </span><span class="go"></span>
<span class="go">   vals ids ids2</span>
<span class="go">0     1   a    a</span>

<span class="go">[1 rows x 3 columns]</span>
</pre></div>
</div>
</div>
<div class="section" id="the-where-method-and-masking">
<span id="indexing-where-mask"></span><h2>The <a class="reference internal" href="../generated/pandas.DataFrame.where.html#pandas.DataFrame.where" title="pandas.DataFrame.where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">where()</span></code></a> Method and Masking<a class="headerlink" href="#the-where-method-and-masking" title="Permalink to this headline">¶</a></h2>
<p>Selecting values from a Series with a boolean vector generally returns a
subset of the data. To guarantee that selection output has the same shape as
the original data, you can use the <code class="docutils literal notranslate"><span class="pre">where</span></code> method in <code class="docutils literal notranslate"><span class="pre">Series</span></code> and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p>
<p>To return only the selected rows:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [177]: </span><span class="n">s</span><span class="p">[</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
<span class="gh">Out[177]: </span><span class="go"></span>
<span class="go">3    1</span>
<span class="go">2    2</span>
<span class="go">1    3</span>
<span class="go">0    4</span>
<span class="go">Length: 4, dtype: int64</span>
</pre></div>
</div>
<p>To return a Series of the same shape as the original:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [178]: </span><span class="n">s</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="gh">Out[178]: </span><span class="go"></span>
<span class="go">4    NaN</span>
<span class="go">3    1.0</span>
<span class="go">2    2.0</span>
<span class="go">1    3.0</span>
<span class="go">0    4.0</span>
<span class="go">Length: 5, dtype: float64</span>
</pre></div>
</div>
<p>Selecting values from a DataFrame with a boolean criterion now also preserves
input data shape. <code class="docutils literal notranslate"><span class="pre">where</span></code> is used under the hood as the implementation.
The code below is equivalent to <code class="docutils literal notranslate"><span class="pre">df.where(df</span> <span class="pre">&lt;</span> <span class="pre">0)</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [179]: </span><span class="n">df</span><span class="p">[</span><span class="n">df</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>
<span class="gh">Out[179]: </span><span class="go"></span>
<span class="go">                   A         B         C         D</span>
<span class="go">2000-01-01 -2.104139 -1.309525       NaN       NaN</span>
<span class="go">2000-01-02 -0.352480       NaN -1.192319       NaN</span>
<span class="go">2000-01-03 -0.864883       NaN -0.227870       NaN</span>
<span class="go">2000-01-04       NaN -1.222082       NaN -1.233203</span>
<span class="go">2000-01-05       NaN -0.605656 -1.169184       NaN</span>
<span class="go">2000-01-06       NaN -0.948458       NaN -0.684718</span>
<span class="go">2000-01-07 -2.670153 -0.114722       NaN -0.048048</span>
<span class="go">2000-01-08       NaN       NaN -0.048788 -0.808838</span>

<span class="go">[8 rows x 4 columns]</span>
</pre></div>
</div>
<p>In addition, <code class="docutils literal notranslate"><span class="pre">where</span></code> takes an optional <code class="docutils literal notranslate"><span class="pre">other</span></code> argument for replacement of
values where the condition is False, in the returned copy.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [180]: </span><span class="n">df</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">df</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span>
<span class="gh">Out[180]: </span><span class="go"></span>
<span class="go">                   A         B         C         D</span>
<span class="go">2000-01-01 -2.104139 -1.309525 -0.485855 -0.245166</span>
<span class="go">2000-01-02 -0.352480 -0.390389 -1.192319 -1.655824</span>
<span class="go">2000-01-03 -0.864883 -0.299674 -0.227870 -0.281059</span>
<span class="go">2000-01-04 -0.846958 -1.222082 -0.600705 -1.233203</span>
<span class="go">2000-01-05 -0.669692 -0.605656 -1.169184 -0.342416</span>
<span class="go">2000-01-06 -0.868584 -0.948458 -2.297780 -0.684718</span>
<span class="go">2000-01-07 -2.670153 -0.114722 -0.168904 -0.048048</span>
<span class="go">2000-01-08 -0.801196 -1.392071 -0.048788 -0.808838</span>

<span class="go">[8 rows x 4 columns]</span>
</pre></div>
</div>
<p>You may wish to set values based on some boolean criteria.
This can be done intuitively like so:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [181]: </span><span class="n">s2</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="gp">In [182]: </span><span class="n">s2</span><span class="p">[</span><span class="n">s2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="gp">In [183]: </span><span class="n">s2</span>
<span class="gh">Out[183]: </span><span class="go"></span>
<span class="go">4    0</span>
<span class="go">3    1</span>
<span class="go">2    2</span>
<span class="go">1    3</span>
<span class="go">0    4</span>
<span class="go">Length: 5, dtype: int64</span>

<span class="gp">In [184]: </span><span class="n">df2</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="gp">In [185]: </span><span class="n">df2</span><span class="p">[</span><span class="n">df2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="gp">In [186]: </span><span class="n">df2</span>
<span class="gh">Out[186]: </span><span class="go"></span>
<span class="go">                   A         B         C         D</span>
<span class="go">2000-01-01  0.000000  0.000000  0.485855  0.245166</span>
<span class="go">2000-01-02  0.000000  0.390389  0.000000  1.655824</span>
<span class="go">2000-01-03  0.000000  0.299674  0.000000  0.281059</span>
<span class="go">2000-01-04  0.846958  0.000000  0.600705  0.000000</span>
<span class="go">2000-01-05  0.669692  0.000000  0.000000  0.342416</span>
<span class="go">2000-01-06  0.868584  0.000000  2.297780  0.000000</span>
<span class="go">2000-01-07  0.000000  0.000000  0.168904  0.000000</span>
<span class="go">2000-01-08  0.801196  1.392071  0.000000  0.000000</span>

<span class="go">[8 rows x 4 columns]</span>
</pre></div>
</div>
<p>By default, <code class="docutils literal notranslate"><span class="pre">where</span></code> returns a modified copy of the data. There is an
optional parameter <code class="docutils literal notranslate"><span class="pre">inplace</span></code> so that the original data can be modified
without creating a copy:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [187]: </span><span class="n">df_orig</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="gp">In [188]: </span><span class="n">df_orig</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">df</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span>

<span class="gp">In [189]: </span><span class="n">df_orig</span>
<span class="gh">Out[189]: </span><span class="go"></span>
<span class="go">                   A         B         C         D</span>
<span class="go">2000-01-01  2.104139  1.309525  0.485855  0.245166</span>
<span class="go">2000-01-02  0.352480  0.390389  1.192319  1.655824</span>
<span class="go">2000-01-03  0.864883  0.299674  0.227870  0.281059</span>
<span class="go">2000-01-04  0.846958  1.222082  0.600705  1.233203</span>
<span class="go">2000-01-05  0.669692  0.605656  1.169184  0.342416</span>
<span class="go">2000-01-06  0.868584  0.948458  2.297780  0.684718</span>
<span class="go">2000-01-07  2.670153  0.114722  0.168904  0.048048</span>
<span class="go">2000-01-08  0.801196  1.392071  0.048788  0.808838</span>

<span class="go">[8 rows x 4 columns]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The signature for <a class="reference internal" href="../generated/pandas.DataFrame.where.html#pandas.DataFrame.where" title="pandas.DataFrame.where"><code class="xref py py-func docutils literal notranslate"><span class="pre">DataFrame.where()</span></code></a> differs from <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html#numpy.where" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.where()</span></code></a>.
Roughly <code class="docutils literal notranslate"><span class="pre">df1.where(m,</span> <span class="pre">df2)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">np.where(m,</span> <span class="pre">df1,</span> <span class="pre">df2)</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [190]: </span><span class="n">df</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">df</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">df</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="o">-</span><span class="n">df</span><span class="p">)</span>
<span class="gh">Out[190]: </span><span class="go"></span>
<span class="go">               A     B     C     D</span>
<span class="go">2000-01-01  True  True  True  True</span>
<span class="go">2000-01-02  True  True  True  True</span>
<span class="go">2000-01-03  True  True  True  True</span>
<span class="go">2000-01-04  True  True  True  True</span>
<span class="go">2000-01-05  True  True  True  True</span>
<span class="go">2000-01-06  True  True  True  True</span>
<span class="go">2000-01-07  True  True  True  True</span>
<span class="go">2000-01-08  True  True  True  True</span>

<span class="go">[8 rows x 4 columns]</span>
</pre></div>
</div>
</div>
<p><strong>alignment</strong></p>
<p>Furthermore, <code class="docutils literal notranslate"><span class="pre">where</span></code> aligns the input boolean condition (ndarray or DataFrame),
such that partial selection with setting is possible. This is analogous to
partial setting via <code class="docutils literal notranslate"><span class="pre">.loc</span></code> (but on the contents rather than the axis labels).</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [191]: </span><span class="n">df2</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="gp">In [192]: </span><span class="n">df2</span><span class="p">[</span> <span class="n">df2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>

<span class="gp">In [193]: </span><span class="n">df2</span>
<span class="gh">Out[193]: </span><span class="go"></span>
<span class="go">                   A         B         C         D</span>
<span class="go">2000-01-01 -2.104139 -1.309525  0.485855  0.245166</span>
<span class="go">2000-01-02 -0.352480  3.000000 -1.192319  3.000000</span>
<span class="go">2000-01-03 -0.864883  3.000000 -0.227870  3.000000</span>
<span class="go">2000-01-04  3.000000 -1.222082  3.000000 -1.233203</span>
<span class="go">2000-01-05  0.669692 -0.605656 -1.169184  0.342416</span>
<span class="go">2000-01-06  0.868584 -0.948458  2.297780 -0.684718</span>
<span class="go">2000-01-07 -2.670153 -0.114722  0.168904 -0.048048</span>
<span class="go">2000-01-08  0.801196  1.392071 -0.048788 -0.808838</span>

<span class="go">[8 rows x 4 columns]</span>
</pre></div>
</div>
<p>Where can also accept <code class="docutils literal notranslate"><span class="pre">axis</span></code> and <code class="docutils literal notranslate"><span class="pre">level</span></code> parameters to align the input when
performing the <code class="docutils literal notranslate"><span class="pre">where</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [194]: </span><span class="n">df2</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="gp">In [195]: </span><span class="n">df2</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">df2</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span><span class="n">df2</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="gh">Out[195]: </span><span class="go"></span>
<span class="go">                   A         B         C         D</span>
<span class="go">2000-01-01 -2.104139 -2.104139  0.485855  0.245166</span>
<span class="go">2000-01-02 -0.352480  0.390389 -0.352480  1.655824</span>
<span class="go">2000-01-03 -0.864883  0.299674 -0.864883  0.281059</span>
<span class="go">2000-01-04  0.846958  0.846958  0.600705  0.846958</span>
<span class="go">2000-01-05  0.669692  0.669692  0.669692  0.342416</span>
<span class="go">2000-01-06  0.868584  0.868584  2.297780  0.868584</span>
<span class="go">2000-01-07 -2.670153 -2.670153  0.168904 -2.670153</span>
<span class="go">2000-01-08  0.801196  1.392071  0.801196  0.801196</span>

<span class="go">[8 rows x 4 columns]</span>
</pre></div>
</div>
<p>This is equivalent to (but faster than) the following.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [196]: </span><span class="n">df2</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="gp">In [197]: </span><span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>
<span class="gh">Out[197]: </span><span class="go"></span>
<span class="go">                   A         B         C         D</span>
<span class="go">2000-01-01 -2.104139 -2.104139  0.485855  0.245166</span>
<span class="go">2000-01-02 -0.352480  0.390389 -0.352480  1.655824</span>
<span class="go">2000-01-03 -0.864883  0.299674 -0.864883  0.281059</span>
<span class="go">2000-01-04  0.846958  0.846958  0.600705  0.846958</span>
<span class="go">2000-01-05  0.669692  0.669692  0.669692  0.342416</span>
<span class="go">2000-01-06  0.868584  0.868584  2.297780  0.868584</span>
<span class="go">2000-01-07 -2.670153 -2.670153  0.168904 -2.670153</span>
<span class="go">2000-01-08  0.801196  1.392071  0.801196  0.801196</span>

<span class="go">[8 rows x 4 columns]</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.1.</span></p>
</div>
<p>Where can accept a callable as condition and <code class="docutils literal notranslate"><span class="pre">other</span></code> arguments. The function must
be with one argument (the calling Series or DataFrame) and that returns valid output
as condition and <code class="docutils literal notranslate"><span class="pre">other</span></code> argument.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [198]: </span><span class="n">df3</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">   .....: </span>                    <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">   .....: </span>                    <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]})</span>
<span class="gp">   .....: </span>

<span class="gp">In [199]: </span><span class="n">df3</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span>
<span class="gh">Out[199]: </span><span class="go"></span>
<span class="go">    A   B  C</span>
<span class="go">0  11  14  7</span>
<span class="go">1  12   5  8</span>
<span class="go">2  13   6  9</span>

<span class="go">[3 rows x 3 columns]</span>
</pre></div>
</div>
<div class="section" id="mask">
<h3>Mask<a class="headerlink" href="#mask" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../generated/pandas.DataFrame.mask.html#pandas.DataFrame.mask" title="pandas.DataFrame.mask"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mask()</span></code></a> is the inverse boolean operation of <code class="docutils literal notranslate"><span class="pre">where</span></code>.</p>
<pre class="literal-block">In [200]: s.mask(s &gt;= 0)
Out[200]: 
4   NaN
3   NaN
2   NaN
1   NaN
0   NaN
Length: 5, dtype: float64

In [201]: df.mask(df &gt;= 0)
Out[201]: 
                   A         B         C         D
2000-01-01 -2.104139 -1.309525       NaN       NaN
2000-01-02 -0.352480       NaN -1.192319       NaN
2000-01-03 -0.864883       NaN -0.227870       NaN
2000-01-04       NaN -1.222082       NaN -1.233203
2000-01-05       NaN -0.605656 -1.169184       NaN
2000-01-06       NaN -0.948458       NaN -0.684718
2000-01-07 -2.670153 -0.114722       NaN -0.048048
2000-01-08       NaN       NaN -0.048788 -0.808838

[8 rows x 4 columns]</pre>
</div>
</div>
<div class="section" id="the-query-method">
<span id="indexing-query"></span><h2>The <a class="reference internal" href="../generated/pandas.DataFrame.query.html#pandas.DataFrame.query" title="pandas.DataFrame.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a> Method<a class="headerlink" href="#the-query-method" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="../generated/pandas.DataFrame.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> objects have a <a class="reference internal" href="../generated/pandas.DataFrame.query.html#pandas.DataFrame.query" title="pandas.DataFrame.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a>
method that allows selection using an expression.</p>
<p>You can get the value of the frame where column <code class="docutils literal notranslate"><span class="pre">b</span></code> has values
between the values of columns <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code>. For example:</p>
<pre class="literal-block">In [202]: n = 10

In [203]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))

In [204]: df
Out[204]: 
          a         b         c
0  0.438921  0.118680  0.863670
1  0.138138  0.577363  0.686602
2  0.595307  0.564592  0.520630
3  0.913052  0.926075  0.616184
4  0.078718  0.854477  0.898725
5  0.076404  0.523211  0.591538
6  0.792342  0.216974  0.564056
7  0.397890  0.454131  0.915716
8  0.074315  0.437913  0.019794
9  0.559209  0.502065  0.026437

[10 rows x 3 columns]

# pure python
In [205]: df[(df.a &lt; df.b) &amp; (df.b &lt; df.c)]
Out[205]: 
          a         b         c
1  0.138138  0.577363  0.686602
4  0.078718  0.854477  0.898725
5  0.076404  0.523211  0.591538
7  0.397890  0.454131  0.915716

[4 rows x 3 columns]

# query
In [206]: df.query('(a &lt; b) &amp; (b &lt; c)')
Out[206]: 
          a         b         c
1  0.138138  0.577363  0.686602
4  0.078718  0.854477  0.898725
5  0.076404  0.523211  0.591538
7  0.397890  0.454131  0.915716

[4 rows x 3 columns]</pre>
<p>Do the same thing but fall back on a named index if there is no column
with the name <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<pre class="literal-block">In [207]: df = pd.DataFrame(np.random.randint(n / 2, size=(n, 2)), columns=list('bc'))

In [208]: df.index.name = 'a'

In [209]: df
Out[209]: 
   b  c
a      
0  0  4
1  0  1
2  3  4
3  4  3
4  1  4
5  0  3
6  0  1
7  3  4
8  2  3
9  1  1

[10 rows x 2 columns]

In [210]: df.query('a &lt; b and b &lt; c')
Out[210]: 
   b  c
a      
2  3  4

[1 rows x 2 columns]</pre>
<p>If instead you don’t want to or cannot name your index, you can use the name
<code class="docutils literal notranslate"><span class="pre">index</span></code> in your query expression:</p>
<pre class="literal-block">In [211]: df = pd.DataFrame(np.random.randint(n, size=(n, 2)), columns=list('bc'))

In [212]: df
Out[212]: 
   b  c
0  3  1
1  3  0
2  5  6
3  5  2
4  7  4
5  0  1
6  2  5
7  0  1
8  6  0
9  7  9

[10 rows x 2 columns]

In [213]: df.query('index &lt; b &lt; c')
Out[213]: 
   b  c
2  5  6

[1 rows x 2 columns]</pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the name of your index overlaps with a column name, the column name is
given precedence. For example,</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [214]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">5</span><span class="p">)})</span>

<span class="gp">In [215]: </span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>

<span class="gp">In [216]: </span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;a &gt; 2&#39;</span><span class="p">)</span> <span class="c1"># uses the column &#39;a&#39;, not the index</span>
<span class="gh">Out[216]: </span><span class="go"></span>
<span class="go">   a</span>
<span class="go">a   </span>
<span class="go">1  3</span>
<span class="go">3  3</span>

<span class="go">[2 rows x 1 columns]</span>
</pre></div>
</div>
<p>You can still use the index in a query expression by using the special
identifier ‘index’:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [217]: </span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;index &gt; 2&#39;</span><span class="p">)</span>
<span class="gh">Out[217]: </span><span class="go"></span>
<span class="go">   a</span>
<span class="go">a   </span>
<span class="go">3  3</span>
<span class="go">4  2</span>

<span class="go">[2 rows x 1 columns]</span>
</pre></div>
</div>
<p>If for some reason you have a column named <code class="docutils literal notranslate"><span class="pre">index</span></code>, then you can refer to
the index as <code class="docutils literal notranslate"><span class="pre">ilevel_0</span></code> as well, but at this point you should consider
renaming your columns to something less ambiguous.</p>
</div>
<div class="section" id="multiindex-query-syntax">
<h3><a class="reference internal" href="../generated/pandas.MultiIndex.html#pandas.MultiIndex" title="pandas.MultiIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiIndex</span></code></a> <a class="reference internal" href="../generated/pandas.DataFrame.query.html#pandas.DataFrame.query" title="pandas.DataFrame.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a> Syntax<a class="headerlink" href="#multiindex-query-syntax" title="Permalink to this headline">¶</a></h3>
<p>You can also use the levels of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> with a
<a class="reference internal" href="../generated/pandas.MultiIndex.html#pandas.MultiIndex" title="pandas.MultiIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiIndex</span></code></a> as if they were columns in the frame:</p>
<pre class="literal-block">In [218]: n = 10

In [219]: colors = np.random.choice(['red', 'green'], size=n)

In [220]: foods = np.random.choice(['eggs', 'ham'], size=n)

In [221]: colors
Out[221]: 
array(['red', 'red', 'red', 'green', 'green', 'green', 'green', 'green',
       'green', 'green'], dtype='&lt;U5')

In [222]: foods
Out[222]: 
array(['ham', 'ham', 'eggs', 'eggs', 'eggs', 'ham', 'ham', 'eggs', 'eggs',
       'eggs'], dtype='&lt;U4')

In [223]: index = pd.MultiIndex.from_arrays([colors, foods], names=['color', 'food'])

In [224]: df = pd.DataFrame(np.random.randn(n, 2), index=index)

In [225]: df
Out[225]: 
                   0         1
color food                    
red   ham   0.194889 -0.381994
      ham   0.318587  2.089075
      eggs -0.728293 -0.090255
green eggs -0.748199  1.318931
      eggs -2.029766  0.792652
      ham   0.461007 -0.542749
      ham  -0.305384 -0.479195
      eggs  0.095031 -0.270099
      eggs -0.707140 -0.773882
      eggs  0.229453  0.304418

[10 rows x 2 columns]

In [226]: df.query('color == &quot;red&quot;')
Out[226]: 
                   0         1
color food                    
red   ham   0.194889 -0.381994
      ham   0.318587  2.089075
      eggs -0.728293 -0.090255

[3 rows x 2 columns]</pre>
<p>If the levels of the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> are unnamed, you can refer to them using
special names:</p>
<pre class="literal-block">In [227]: df.index.names = [None, None]

In [228]: df
Out[228]: 
                   0         1
red   ham   0.194889 -0.381994
      ham   0.318587  2.089075
      eggs -0.728293 -0.090255
green eggs -0.748199  1.318931
      eggs -2.029766  0.792652
      ham   0.461007 -0.542749
      ham  -0.305384 -0.479195
      eggs  0.095031 -0.270099
      eggs -0.707140 -0.773882
      eggs  0.229453  0.304418

[10 rows x 2 columns]

In [229]: df.query('ilevel_0 == &quot;red&quot;')
Out[229]: 
                 0         1
red ham   0.194889 -0.381994
    ham   0.318587  2.089075
    eggs -0.728293 -0.090255

[3 rows x 2 columns]</pre>
<p>The convention is <code class="docutils literal notranslate"><span class="pre">ilevel_0</span></code>, which means “index level 0” for the 0th level
of the <code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
</div>
<div class="section" id="query-use-cases">
<h3><a class="reference internal" href="../generated/pandas.DataFrame.query.html#pandas.DataFrame.query" title="pandas.DataFrame.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a> Use Cases<a class="headerlink" href="#query-use-cases" title="Permalink to this headline">¶</a></h3>
<p>A use case for <a class="reference internal" href="../generated/pandas.DataFrame.query.html#pandas.DataFrame.query" title="pandas.DataFrame.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a> is when you have a collection of
<a class="reference internal" href="../generated/pandas.DataFrame.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> objects that have a subset of column names (or index
levels/names) in common. You can pass the same query to both frames <em>without</em>
having to specify which frame you’re interested in querying</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [230]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">))</span>

<span class="gp">In [231]: </span><span class="n">df</span>
<span class="gh">Out[231]: </span><span class="go"></span>
<span class="go">          a         b         c</span>
<span class="go">0  0.224283  0.736107  0.139168</span>
<span class="go">1  0.302827  0.657803  0.713897</span>
<span class="go">2  0.611185  0.136624  0.984960</span>
<span class="go">3  0.195246  0.123436  0.627712</span>
<span class="go">4  0.618673  0.371660  0.047902</span>
<span class="go">5  0.480088  0.062993  0.185760</span>
<span class="go">6  0.568018  0.483467  0.445289</span>
<span class="go">7  0.309040  0.274580  0.587101</span>
<span class="go">8  0.258993  0.477769  0.370255</span>
<span class="go">9  0.550459  0.840870  0.304611</span>

<span class="go">[10 rows x 3 columns]</span>

<span class="gp">In [232]: </span><span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

<span class="gp">In [233]: </span><span class="n">df2</span>
<span class="gh">Out[233]: </span><span class="go"></span>
<span class="go">           a         b         c</span>
<span class="go">0   0.357579  0.229800  0.596001</span>
<span class="go">1   0.309059  0.957923  0.965663</span>
<span class="go">2   0.123102  0.336914  0.318616</span>
<span class="go">3   0.526506  0.323321  0.860813</span>
<span class="go">4   0.518736  0.486514  0.384724</span>
<span class="go">5   0.190804  0.505723  0.614533</span>
<span class="go">6   0.891939  0.623977  0.676639</span>
<span class="go">7   0.480559  0.378528  0.460858</span>
<span class="go">8   0.420223  0.136404  0.141295</span>
<span class="go">9   0.732206  0.419540  0.604675</span>
<span class="go">10  0.604466  0.848974  0.896165</span>
<span class="go">11  0.589168  0.920046  0.732716</span>

<span class="go">[12 rows x 3 columns]</span>

<span class="gp">In [234]: </span><span class="n">expr</span> <span class="o">=</span> <span class="s1">&#39;0.0 &lt;= a &lt;= c &lt;= 0.5&#39;</span>

<span class="gp">In [235]: </span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">frame</span><span class="p">:</span> <span class="n">frame</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="p">[</span><span class="n">df</span><span class="p">,</span> <span class="n">df2</span><span class="p">])</span>
<span class="gh">Out[235]: </span><span class="go">&lt;map at 0x7f6ff19dfe48&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="query-python-versus-pandas-syntax-comparison">
<h3><a class="reference internal" href="../generated/pandas.DataFrame.query.html#pandas.DataFrame.query" title="pandas.DataFrame.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a> Python versus pandas Syntax Comparison<a class="headerlink" href="#query-python-versus-pandas-syntax-comparison" title="Permalink to this headline">¶</a></h3>
<p>Full numpy-like syntax:</p>
<pre class="literal-block">In [236]: df = pd.DataFrame(np.random.randint(n, size=(n, 3)), columns=list('abc'))

In [237]: df
Out[237]: 
   a  b  c
0  7  8  9
1  1  0  7
2  2  7  2
3  6  2  2
4  2  6  3
5  3  8  2
6  1  7  2
7  5  1  5
8  9  8  0
9  1  5  0

[10 rows x 3 columns]

In [238]: df.query('(a &lt; b) &amp; (b &lt; c)')
Out[238]: 
   a  b  c
0  7  8  9

[1 rows x 3 columns]

In [239]: df[(df.a &lt; df.b) &amp; (df.b &lt; df.c)]
Out[239]: 
   a  b  c
0  7  8  9

[1 rows x 3 columns]</pre>
<p>Slightly nicer by removing the parentheses (by binding making comparison
operators bind tighter than <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> and <code class="docutils literal notranslate"><span class="pre">|</span></code>).</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [240]: </span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;a &lt; b &amp; b &lt; c&#39;</span><span class="p">)</span>
<span class="gh">Out[240]: </span><span class="go"></span>
<span class="go">   a  b  c</span>
<span class="go">0  7  8  9</span>

<span class="go">[1 rows x 3 columns]</span>
</pre></div>
</div>
<p>Use English instead of symbols:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [241]: </span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;a &lt; b and b &lt; c&#39;</span><span class="p">)</span>
<span class="gh">Out[241]: </span><span class="go"></span>
<span class="go">   a  b  c</span>
<span class="go">0  7  8  9</span>

<span class="go">[1 rows x 3 columns]</span>
</pre></div>
</div>
<p>Pretty close to how you might write it on paper:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [242]: </span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;a &lt; b &lt; c&#39;</span><span class="p">)</span>
<span class="gh">Out[242]: </span><span class="go"></span>
<span class="go">   a  b  c</span>
<span class="go">0  7  8  9</span>

<span class="go">[1 rows x 3 columns]</span>
</pre></div>
</div>
</div>
<div class="section" id="the-in-and-not-in-operators">
<h3>The <code class="docutils literal notranslate"><span class="pre">in</span></code> and <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code> operators<a class="headerlink" href="#the-in-and-not-in-operators" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../generated/pandas.DataFrame.query.html#pandas.DataFrame.query" title="pandas.DataFrame.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a> also supports special use of Python’s <code class="docutils literal notranslate"><span class="pre">in</span></code> and
<code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code> comparison operators, providing a succinct syntax for calling the
<code class="docutils literal notranslate"><span class="pre">isin</span></code> method of a <code class="docutils literal notranslate"><span class="pre">Series</span></code> or <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p>
<pre class="literal-block"># get all rows where columns &quot;a&quot; and &quot;b&quot; have overlapping values
In [243]: df = pd.DataFrame({'a': list('aabbccddeeff'), 'b': list('aaaabbbbcccc'),
   .....:                    'c': np.random.randint(5, size=12),
   .....:                    'd': np.random.randint(9, size=12)})
   .....: 

In [244]: df
Out[244]: 
    a  b  c  d
0   a  a  2  6
1   a  a  4  7
2   b  a  1  6
3   b  a  2  1
4   c  b  3  6
5   c  b  0  2
6   d  b  3  3
7   d  b  2  1
8   e  c  4  3
9   e  c  2  0
10  f  c  0  6
11  f  c  1  2

[12 rows x 4 columns]

In [245]: df.query('a in b')
Out[245]: 
   a  b  c  d
0  a  a  2  6
1  a  a  4  7
2  b  a  1  6
3  b  a  2  1
4  c  b  3  6
5  c  b  0  2

[6 rows x 4 columns]

# How you'd do it in pure Python
In [246]: df[df.a.isin(df.b)]
Out[246]: 
   a  b  c  d
0  a  a  2  6
1  a  a  4  7
2  b  a  1  6
3  b  a  2  1
4  c  b  3  6
5  c  b  0  2

[6 rows x 4 columns]

In [247]: df.query('a not in b')
Out[247]: 
    a  b  c  d
6   d  b  3  3
7   d  b  2  1
8   e  c  4  3
9   e  c  2  0
10  f  c  0  6
11  f  c  1  2

[6 rows x 4 columns]

# pure Python
In [248]: df[~df.a.isin(df.b)]
Out[248]: 
    a  b  c  d
6   d  b  3  3
7   d  b  2  1
8   e  c  4  3
9   e  c  2  0
10  f  c  0  6
11  f  c  1  2

[6 rows x 4 columns]</pre>
<p>You can combine this with other expressions for very succinct queries:</p>
<pre class="literal-block"># rows where cols a and b have overlapping values and col c's values are less than col d's
In [249]: df.query('a in b and c &lt; d')
Out[249]: 
   a  b  c  d
0  a  a  2  6
1  a  a  4  7
2  b  a  1  6
4  c  b  3  6
5  c  b  0  2

[5 rows x 4 columns]

# pure Python
In [250]: df[df.b.isin(df.a) &amp; (df.c &lt; df.d)]
Out[250]: 
    a  b  c  d
0   a  a  2  6
1   a  a  4  7
2   b  a  1  6
4   c  b  3  6
5   c  b  0  2
10  f  c  0  6
11  f  c  1  2

[7 rows x 4 columns]</pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">in</span></code> and <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code> are evaluated in Python, since <code class="docutils literal notranslate"><span class="pre">numexpr</span></code>
has no equivalent of this operation. However, <strong>only the</strong> <code class="docutils literal notranslate"><span class="pre">in</span></code>/<code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code>
<strong>expression itself</strong> is evaluated in vanilla Python. For example, in the
expression</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;a in b + c + d&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">+</span> <span class="pre">c</span> <span class="pre">+</span> <span class="pre">d)</span></code> is evaluated by <code class="docutils literal notranslate"><span class="pre">numexpr</span></code> and <em>then</em> the <code class="docutils literal notranslate"><span class="pre">in</span></code>
operation is evaluated in plain Python. In general, any operations that can
be evaluated using <code class="docutils literal notranslate"><span class="pre">numexpr</span></code> will be.</p>
</div>
</div>
<div class="section" id="special-use-of-the-operator-with-list-objects">
<h3>Special use of the <code class="docutils literal notranslate"><span class="pre">==</span></code> operator with <code class="docutils literal notranslate"><span class="pre">list</span></code> objects<a class="headerlink" href="#special-use-of-the-operator-with-list-objects" title="Permalink to this headline">¶</a></h3>
<p>Comparing a <code class="docutils literal notranslate"><span class="pre">list</span></code> of values to a column using <code class="docutils literal notranslate"><span class="pre">==</span></code>/<code class="docutils literal notranslate"><span class="pre">!=</span></code> works similarly
to <code class="docutils literal notranslate"><span class="pre">in</span></code>/<code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code>.</p>
<pre class="literal-block">In [251]: df.query('b == [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]')
Out[251]: 
    a  b  c  d
0   a  a  2  6
1   a  a  4  7
2   b  a  1  6
3   b  a  2  1
4   c  b  3  6
5   c  b  0  2
6   d  b  3  3
7   d  b  2  1
8   e  c  4  3
9   e  c  2  0
10  f  c  0  6
11  f  c  1  2

[12 rows x 4 columns]

# pure Python
In [252]: df[df.b.isin([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])]
Out[252]: 
    a  b  c  d
0   a  a  2  6
1   a  a  4  7
2   b  a  1  6
3   b  a  2  1
4   c  b  3  6
5   c  b  0  2
6   d  b  3  3
7   d  b  2  1
8   e  c  4  3
9   e  c  2  0
10  f  c  0  6
11  f  c  1  2

[12 rows x 4 columns]

In [253]: df.query('c == [1, 2]')
Out[253]: 
    a  b  c  d
0   a  a  2  6
2   b  a  1  6
3   b  a  2  1
7   d  b  2  1
9   e  c  2  0
11  f  c  1  2

[6 rows x 4 columns]

In [254]: df.query('c != [1, 2]')
Out[254]: 
    a  b  c  d
1   a  a  4  7
4   c  b  3  6
5   c  b  0  2
6   d  b  3  3
8   e  c  4  3
10  f  c  0  6

[6 rows x 4 columns]

# using in/not in
In [255]: df.query('[1, 2] in c')
Out[255]: 
    a  b  c  d
0   a  a  2  6
2   b  a  1  6
3   b  a  2  1
7   d  b  2  1
9   e  c  2  0
11  f  c  1  2

[6 rows x 4 columns]

In [256]: df.query('[1, 2] not in c')
Out[256]: 
    a  b  c  d
1   a  a  4  7
4   c  b  3  6
5   c  b  0  2
6   d  b  3  3
8   e  c  4  3
10  f  c  0  6

[6 rows x 4 columns]

# pure Python
In [257]: df[df.c.isin([1, 2])]
Out[257]: 
    a  b  c  d
0   a  a  2  6
2   b  a  1  6
3   b  a  2  1
7   d  b  2  1
9   e  c  2  0
11  f  c  1  2

[6 rows x 4 columns]</pre>
</div>
<div class="section" id="boolean-operators">
<h3>Boolean Operators<a class="headerlink" href="#boolean-operators" title="Permalink to this headline">¶</a></h3>
<p>You can negate boolean expressions with the word <code class="docutils literal notranslate"><span class="pre">not</span></code> or the <code class="docutils literal notranslate"><span class="pre">~</span></code> operator.</p>
<pre class="literal-block">In [258]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))

In [259]: df['bools'] = np.random.rand(len(df)) &gt; 0.5

In [260]: df.query('~bools')
Out[260]: 
          a         b         c  bools
2  0.697753  0.212799  0.329209  False
7  0.275396  0.691034  0.826619  False
8  0.190649  0.558748  0.262467  False

[3 rows x 4 columns]

In [261]: df.query('not bools')
Out[261]: 
          a         b         c  bools
2  0.697753  0.212799  0.329209  False
7  0.275396  0.691034  0.826619  False
8  0.190649  0.558748  0.262467  False

[3 rows x 4 columns]

In [262]: df.query('not bools') == df[~df.bools]
Out[262]: 
      a     b     c  bools
2  True  True  True   True
7  True  True  True   True
8  True  True  True   True

[3 rows x 4 columns]</pre>
<p>Of course, expressions can be arbitrarily complex too:</p>
<pre class="literal-block"># short query syntax
In [263]: shorter = df.query('a &lt; b &lt; c and (not bools) or bools &gt; 2')

# equivalent in pure Python
In [264]: longer = df[(df.a &lt; df.b) &amp; (df.b &lt; df.c) &amp; (~df.bools) | (df.bools &gt; 2)]

In [265]: shorter
Out[265]: 
          a         b         c  bools
7  0.275396  0.691034  0.826619  False

[1 rows x 4 columns]

In [266]: longer
Out[266]: 
          a         b         c  bools
7  0.275396  0.691034  0.826619  False

[1 rows x 4 columns]

In [267]: shorter == longer
Out[267]: 
      a     b     c  bools
7  True  True  True   True

[1 rows x 4 columns]</pre>
</div>
<div class="section" id="performance-of-query">
<h3>Performance of <a class="reference internal" href="../generated/pandas.DataFrame.query.html#pandas.DataFrame.query" title="pandas.DataFrame.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a><a class="headerlink" href="#performance-of-query" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">DataFrame.query()</span></code> using <code class="docutils literal notranslate"><span class="pre">numexpr</span></code> is slightly faster than Python for
large frames.</p>
<img alt="user_guide/_static/query-perf.png" src="user_guide/_static/query-perf.png" />
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You will only see the performance benefits of using the <code class="docutils literal notranslate"><span class="pre">numexpr</span></code> engine
with <code class="docutils literal notranslate"><span class="pre">DataFrame.query()</span></code> if your frame has more than approximately 200,000
rows.</p>
<blockquote>
<div><img alt="user_guide/_static/query-perf-small.png" src="user_guide/_static/query-perf-small.png" />
</div></blockquote>
</div>
<p>This plot was created using a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> with 3 columns each containing
floating point values generated using <code class="docutils literal notranslate"><span class="pre">numpy.random.randn()</span></code>.</p>
</div>
</div>
<div class="section" id="duplicate-data">
<h2>Duplicate Data<a class="headerlink" href="#duplicate-data" title="Permalink to this headline">¶</a></h2>
<p id="indexing-duplicate">If you want to identify and remove duplicate rows in a DataFrame,  there are
two methods that will help: <code class="docutils literal notranslate"><span class="pre">duplicated</span></code> and <code class="docutils literal notranslate"><span class="pre">drop_duplicates</span></code>. Each
takes as an argument the columns to use to identify duplicated rows.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">duplicated</span></code> returns a boolean vector whose length is the number of rows, and which indicates whether a row is duplicated.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">drop_duplicates</span></code> removes duplicate rows.</p></li>
</ul>
<p>By default, the first observed row of a duplicate set is considered unique, but
each method has a <code class="docutils literal notranslate"><span class="pre">keep</span></code> parameter to specify targets to be kept.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">keep='first'</span></code> (default): mark / drop duplicates except for the first occurrence.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">keep='last'</span></code>: mark / drop duplicates except for the last occurrence.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">keep=False</span></code>: mark  / drop all duplicates.</p></li>
</ul>
<pre class="literal-block">In [268]: df2 = pd.DataFrame({'a': ['one', 'one', 'two', 'two', 'two', 'three', 'four'],
   .....:                     'b': ['x', 'y', 'x', 'y', 'x', 'x', 'x'],
   .....:                     'c': np.random.randn(7)})
   .....: 

In [269]: df2
Out[269]: 
       a  b         c
0    one  x -1.067137
1    one  y  0.309500
2    two  x -0.211056
3    two  y -1.842023
4    two  x -0.390820
5  three  x -1.964475
6   four  x  1.298329

[7 rows x 3 columns]

In [270]: df2.duplicated('a')
Out[270]: 
0    False
1     True
2    False
3     True
4     True
5    False
6    False
Length: 7, dtype: bool

In [271]: df2.duplicated('a', keep='last')
Out[271]: 
0     True
1    False
2     True
3     True
4    False
5    False
6    False
Length: 7, dtype: bool

In [272]: df2.duplicated('a', keep=False)
Out[272]: 
0     True
1     True
2     True
3     True
4     True
5    False
6    False
Length: 7, dtype: bool

In [273]: df2.drop_duplicates('a')
Out[273]: 
       a  b         c
0    one  x -1.067137
2    two  x -0.211056
5  three  x -1.964475
6   four  x  1.298329

[4 rows x 3 columns]

In [274]: df2.drop_duplicates('a', keep='last')
Out[274]: 
       a  b         c
1    one  y  0.309500
4    two  x -0.390820
5  three  x -1.964475
6   four  x  1.298329

[4 rows x 3 columns]

In [275]: df2.drop_duplicates('a', keep=False)
Out[275]: 
       a  b         c
5  three  x -1.964475
6   four  x  1.298329

[2 rows x 3 columns]</pre>
<p>Also, you can pass a list of columns to identify duplications.</p>
<pre class="literal-block">In [276]: df2.duplicated(['a', 'b'])
Out[276]: 
0    False
1    False
2    False
3    False
4     True
5    False
6    False
Length: 7, dtype: bool

In [277]: df2.drop_duplicates(['a', 'b'])
Out[277]: 
       a  b         c
0    one  x -1.067137
1    one  y  0.309500
2    two  x -0.211056
3    two  y -1.842023
5  three  x -1.964475
6   four  x  1.298329

[6 rows x 3 columns]</pre>
<p>To drop duplicates by index value, use <code class="docutils literal notranslate"><span class="pre">Index.duplicated</span></code> then perform slicing.
The same set of options are available for the <code class="docutils literal notranslate"><span class="pre">keep</span></code> parameter.</p>
<pre class="literal-block">In [278]: df3 = pd.DataFrame({'a': np.arange(6),
   .....:                     'b': np.random.randn(6)},
   .....:                    index=['a', 'a', 'b', 'c', 'b', 'a'])
   .....: 

In [279]: df3
Out[279]: 
   a         b
a  0  1.440455
a  1  2.456086
b  2  1.038402
c  3 -0.894409
b  4  0.683536
a  5  3.082764

[6 rows x 2 columns]

In [280]: df3.index.duplicated()
Out[280]: array([False,  True, False, False,  True,  True])

In [281]: df3[~df3.index.duplicated()]
Out[281]: 
   a         b
a  0  1.440455
b  2  1.038402
c  3 -0.894409

[3 rows x 2 columns]

In [282]: df3[~df3.index.duplicated(keep='last')]
Out[282]: 
   a         b
c  3 -0.894409
b  4  0.683536
a  5  3.082764

[3 rows x 2 columns]

In [283]: df3[~df3.index.duplicated(keep=False)]
Out[283]: 
   a         b
c  3 -0.894409

[1 rows x 2 columns]</pre>
</div>
<div class="section" id="dictionary-like-get-method">
<span id="indexing-dictionarylike"></span><h2>Dictionary-like <a class="reference internal" href="../generated/pandas.DataFrame.get.html#pandas.DataFrame.get" title="pandas.DataFrame.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> method<a class="headerlink" href="#dictionary-like-get-method" title="Permalink to this headline">¶</a></h2>
<p>Each of Series, DataFrame, and Panel have a <code class="docutils literal notranslate"><span class="pre">get</span></code> method which can return a
default value.</p>
<pre class="literal-block">In [284]: s = pd.Series([1,2,3], index=['a','b','c'])

In [285]: s.get('a')               # equivalent to s['a']
Out[285]: 1

In [286]: s.get('x', default=-1)
Out[286]: -1</pre>
</div>
<div class="section" id="the-lookup-method">
<h2>The <a class="reference internal" href="../generated/pandas.DataFrame.lookup.html#pandas.DataFrame.lookup" title="pandas.DataFrame.lookup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lookup()</span></code></a> Method<a class="headerlink" href="#the-lookup-method" title="Permalink to this headline">¶</a></h2>
<p>Sometimes you want to extract a set of values given a sequence of row labels
and column labels, and the <code class="docutils literal notranslate"><span class="pre">lookup</span></code> method allows for this and returns a
NumPy array.  For instance:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [287]: </span><span class="n">dflookup</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="s1">&#39;C&#39;</span><span class="p">,</span><span class="s1">&#39;D&#39;</span><span class="p">])</span>

<span class="gp">In [288]: </span><span class="n">dflookup</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="s1">&#39;C&#39;</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="s1">&#39;D&#39;</span><span class="p">])</span>
<span class="gh">Out[288]: </span><span class="go">array([0.3506, 0.4779, 0.4825, 0.9197, 0.5019])</span>
</pre></div>
</div>
</div>
<div class="section" id="index-objects">
<span id="indexing-class"></span><h2>Index objects<a class="headerlink" href="#index-objects" title="Permalink to this headline">¶</a></h2>
<p>The pandas <a class="reference internal" href="../generated/pandas.Index.html#pandas.Index" title="pandas.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a> class and its subclasses can be viewed as
implementing an <em>ordered multiset</em>. Duplicates are allowed. However, if you try
to convert an <a class="reference internal" href="../generated/pandas.Index.html#pandas.Index" title="pandas.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a> object with duplicate entries into a
<code class="docutils literal notranslate"><span class="pre">set</span></code>, an exception will be raised.</p>
<p><a class="reference internal" href="../generated/pandas.Index.html#pandas.Index" title="pandas.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a> also provides the infrastructure necessary for
lookups, data alignment, and reindexing. The easiest way to create an
<a class="reference internal" href="../generated/pandas.Index.html#pandas.Index" title="pandas.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a> directly is to pass a <code class="docutils literal notranslate"><span class="pre">list</span></code> or other sequence to
<a class="reference internal" href="../generated/pandas.Index.html#pandas.Index" title="pandas.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a>:</p>
<pre class="literal-block">In [289]: index = pd.Index(['e', 'd', 'a', 'b'])

In [290]: index
Out[290]: Index(['e', 'd', 'a', 'b'], dtype='object')

In [291]: 'd' in index
Out[291]: True</pre>
<p>You can also pass a <code class="docutils literal notranslate"><span class="pre">name</span></code> to be stored in the index:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [292]: </span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;something&#39;</span><span class="p">)</span>

<span class="gp">In [293]: </span><span class="n">index</span><span class="o">.</span><span class="n">name</span>
<span class="gh">Out[293]: </span><span class="go">&#39;something&#39;</span>
</pre></div>
</div>
<p>The name, if set, will be shown in the console display:</p>
<pre class="literal-block">In [294]: index = pd.Index(list(range(5)), name='rows')

In [295]: columns = pd.Index(['A', 'B', 'C'], name='cols')

In [296]: df = pd.DataFrame(np.random.randn(5, 3), index=index, columns=columns)

In [297]: df
Out[297]: 
cols         A         B         C
rows                              
0     1.295989  0.185778  0.436259
1     0.678101  0.311369 -0.528378
2    -0.674808 -1.103529 -0.656157
3     1.889957  2.076651 -1.102192
4    -1.211795 -0.791746  0.634724

[5 rows x 3 columns]

In [298]: df['A']
Out[298]: 
rows
0    1.295989
1    0.678101
2   -0.674808
3    1.889957
4   -1.211795
Name: A, Length: 5, dtype: float64</pre>
<div class="section" id="setting-metadata">
<span id="indexing-set-metadata"></span><h3>Setting metadata<a class="headerlink" href="#setting-metadata" title="Permalink to this headline">¶</a></h3>
<p>Indexes are “mostly immutable”, but it is possible to set and change their
metadata, like the index <code class="docutils literal notranslate"><span class="pre">name</span></code> (or, for <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>, <code class="docutils literal notranslate"><span class="pre">levels</span></code> and
<code class="docutils literal notranslate"><span class="pre">codes</span></code>).</p>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">rename</span></code>, <code class="docutils literal notranslate"><span class="pre">set_names</span></code>, <code class="docutils literal notranslate"><span class="pre">set_levels</span></code>, and <code class="docutils literal notranslate"><span class="pre">set_codes</span></code>
to set these attributes directly. They default to returning a copy; however,
you can specify <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code> to have the data change in place.</p>
<p>See <a class="reference internal" href="advanced.html#advanced"><span class="std std-ref">Advanced Indexing</span></a> for usage of MultiIndexes.</p>
<pre class="literal-block">In [299]: ind = pd.Index([1, 2, 3])

In [300]: ind.rename(&quot;apple&quot;)
Out[300]: Int64Index([1, 2, 3], dtype='int64', name='apple')

In [301]: ind
Out[301]: Int64Index([1, 2, 3], dtype='int64')

In [302]: ind.set_names([&quot;apple&quot;], inplace=True)

In [303]: ind.name = &quot;bob&quot;

In [304]: ind
Out[304]: Int64Index([1, 2, 3], dtype='int64', name='bob')</pre>
<p><code class="docutils literal notranslate"><span class="pre">set_names</span></code>, <code class="docutils literal notranslate"><span class="pre">set_levels</span></code>, and <code class="docutils literal notranslate"><span class="pre">set_codes</span></code> also take an optional
<cite>level`</cite> argument</p>
<pre class="literal-block">In [305]: index = pd.MultiIndex.from_product([range(3), ['one', 'two']], names=['first', 'second'])

In [306]: index
Out[306]: 
MultiIndex([(0, 'one'),
            (0, 'two'),
            (1, 'one'),
            (1, 'two'),
            (2, 'one'),
            (2, 'two')],
           names=['first', 'second'])

In [307]: index.levels[1]
Out[307]: Index(['one', 'two'], dtype='object', name='second')

In [308]: index.set_levels([&quot;a&quot;, &quot;b&quot;], level=1)
Out[308]: 
MultiIndex([(0, 'a'),
            (0, 'b'),
            (1, 'a'),
            (1, 'b'),
            (2, 'a'),
            (2, 'b')],
           names=['first', 'second'])</pre>
</div>
<div class="section" id="set-operations-on-index-objects">
<h3>Set operations on Index objects<a class="headerlink" href="#set-operations-on-index-objects" title="Permalink to this headline">¶</a></h3>
<p id="indexing-set-ops">The two main operations are <code class="docutils literal notranslate"><span class="pre">union</span> <span class="pre">(|)</span></code> and <code class="docutils literal notranslate"><span class="pre">intersection</span> <span class="pre">(&amp;)</span></code>.
These can be directly called as instance methods or used via overloaded
operators. Difference is provided via the <code class="docutils literal notranslate"><span class="pre">.difference()</span></code> method.</p>
<pre class="literal-block">In [309]: a = pd.Index(['c', 'b', 'a'])

In [310]: b = pd.Index(['c', 'e', 'd'])

In [311]: a | b
Out[311]: Index(['a', 'b', 'c', 'd', 'e'], dtype='object')

In [312]: a &amp; b
Out[312]: Index(['c'], dtype='object')

In [313]: a.difference(b)
Out[313]: Index(['a', 'b'], dtype='object')</pre>
<p>Also available is the <code class="docutils literal notranslate"><span class="pre">symmetric_difference</span> <span class="pre">(^)</span></code> operation, which returns elements
that appear in either <code class="docutils literal notranslate"><span class="pre">idx1</span></code> or <code class="docutils literal notranslate"><span class="pre">idx2</span></code>, but not in both. This is
equivalent to the Index created by <code class="docutils literal notranslate"><span class="pre">idx1.difference(idx2).union(idx2.difference(idx1))</span></code>,
with duplicates dropped.</p>
<pre class="literal-block">In [314]: idx1 = pd.Index([1, 2, 3, 4])

In [315]: idx2 = pd.Index([2, 3, 4, 5])

In [316]: idx1.symmetric_difference(idx2)
Out[316]: Int64Index([1, 5], dtype='int64')

In [317]: idx1 ^ idx2
Out[317]: Int64Index([1, 5], dtype='int64')</pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The resulting index from a set operation will be sorted in ascending order.</p>
</div>
</div>
<div class="section" id="missing-values">
<h3>Missing values<a class="headerlink" href="#missing-values" title="Permalink to this headline">¶</a></h3>
<div class="admonition important" id="indexing-missing">
<p class="admonition-title">Important</p>
<p>Even though <code class="docutils literal notranslate"><span class="pre">Index</span></code> can hold missing values (<code class="docutils literal notranslate"><span class="pre">NaN</span></code>), it should be avoided
if you do not want any unexpected results. For example, some operations
exclude missing values implicitly.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Index.fillna</span></code> fills missing values with specified scalar value.</p>
<pre class="literal-block">In [318]: idx1 = pd.Index([1, np.nan, 3, 4])

In [319]: idx1
Out[319]: Float64Index([1.0, nan, 3.0, 4.0], dtype='float64')

In [320]: idx1.fillna(2)
Out[320]: Float64Index([1.0, 2.0, 3.0, 4.0], dtype='float64')

In [321]: idx2 = pd.DatetimeIndex([pd.Timestamp('2011-01-01'), pd.NaT, pd.Timestamp('2011-01-03')])

In [322]: idx2
Out[322]: DatetimeIndex(['2011-01-01', 'NaT', '2011-01-03'], dtype='datetime64[ns]', freq=None)

In [323]: idx2.fillna(pd.Timestamp('2011-01-02'))
Out[323]: DatetimeIndex(['2011-01-01', '2011-01-02', '2011-01-03'], dtype='datetime64[ns]', freq=None)</pre>
</div>
</div>
<div class="section" id="set-reset-index">
<h2>Set / Reset Index<a class="headerlink" href="#set-reset-index" title="Permalink to this headline">¶</a></h2>
<p>Occasionally you will load or create a data set into a DataFrame and want to
add an index after you’ve already done so. There are a couple of different
ways.</p>
<div class="section" id="set-an-index">
<h3>Set an index<a class="headerlink" href="#set-an-index" title="Permalink to this headline">¶</a></h3>
<p id="indexing-set-index">DataFrame has a <a class="reference internal" href="../generated/pandas.DataFrame.set_index.html#pandas.DataFrame.set_index" title="pandas.DataFrame.set_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_index()</span></code></a> method which takes a column name
(for a regular <code class="docutils literal notranslate"><span class="pre">Index</span></code>) or a list of column names (for a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>).
To create a new, re-indexed DataFrame:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [324]: </span><span class="n">data</span>
<span class="gh">Out[324]: </span><span class="go"></span>
<span class="go">     a    b  c    d</span>
<span class="go">0  bar  one  z  1.0</span>
<span class="go">1  bar  two  y  2.0</span>
<span class="go">2  foo  one  x  3.0</span>
<span class="go">3  foo  two  w  4.0</span>

<span class="go">[4 rows x 4 columns]</span>

<span class="gp">In [325]: </span><span class="n">indexed1</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>

<span class="gp">In [326]: </span><span class="n">indexed1</span>
<span class="gh">Out[326]: </span><span class="go"></span>
<span class="go">     a    b    d</span>
<span class="go">c               </span>
<span class="go">z  bar  one  1.0</span>
<span class="go">y  bar  two  2.0</span>
<span class="go">x  foo  one  3.0</span>
<span class="go">w  foo  two  4.0</span>

<span class="go">[4 rows x 3 columns]</span>

<span class="gp">In [327]: </span><span class="n">indexed2</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">])</span>

<span class="gp">In [328]: </span><span class="n">indexed2</span>
<span class="gh">Out[328]: </span><span class="go"></span>
<span class="go">         c    d</span>
<span class="go">a   b          </span>
<span class="go">bar one  z  1.0</span>
<span class="go">    two  y  2.0</span>
<span class="go">foo one  x  3.0</span>
<span class="go">    two  w  4.0</span>

<span class="go">[4 rows x 2 columns]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">append</span></code> keyword option allow you to keep the existing index and append
the given columns to a MultiIndex:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [329]: </span><span class="n">frame</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="gp">In [330]: </span><span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="gp">In [331]: </span><span class="n">frame</span>
<span class="gh">Out[331]: </span><span class="go"></span>
<span class="go">           c    d</span>
<span class="go">c a   b          </span>
<span class="go">z bar one  z  1.0</span>
<span class="go">y bar two  y  2.0</span>
<span class="go">x foo one  x  3.0</span>
<span class="go">w foo two  w  4.0</span>

<span class="go">[4 rows x 2 columns]</span>
</pre></div>
</div>
<p>Other options in <code class="docutils literal notranslate"><span class="pre">set_index</span></code> allow you not drop the index columns or to add
the index in-place (without creating a new object):</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [332]: </span><span class="n">data</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gh">Out[332]: </span><span class="go"></span>
<span class="go">     a    b  c    d</span>
<span class="go">c                  </span>
<span class="go">z  bar  one  z  1.0</span>
<span class="go">y  bar  two  y  2.0</span>
<span class="go">x  foo  one  x  3.0</span>
<span class="go">w  foo  two  w  4.0</span>

<span class="go">[4 rows x 4 columns]</span>

<span class="gp">In [333]: </span><span class="n">data</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="gp">In [334]: </span><span class="n">data</span>
<span class="gh">Out[334]: </span><span class="go"></span>
<span class="go">         c    d</span>
<span class="go">a   b          </span>
<span class="go">bar one  z  1.0</span>
<span class="go">    two  y  2.0</span>
<span class="go">foo one  x  3.0</span>
<span class="go">    two  w  4.0</span>

<span class="go">[4 rows x 2 columns]</span>
</pre></div>
</div>
</div>
<div class="section" id="reset-the-index">
<h3>Reset the index<a class="headerlink" href="#reset-the-index" title="Permalink to this headline">¶</a></h3>
<p>As a convenience, there is a new function on DataFrame called
<a class="reference internal" href="../generated/pandas.DataFrame.reset_index.html#pandas.DataFrame.reset_index" title="pandas.DataFrame.reset_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset_index()</span></code></a> which transfers the index values into the
DataFrame’s columns and sets a simple integer index.
This is the inverse operation of <a class="reference internal" href="../generated/pandas.DataFrame.set_index.html#pandas.DataFrame.set_index" title="pandas.DataFrame.set_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_index()</span></code></a>.</p>
<pre class="literal-block">In [335]: data
Out[335]: 
         c    d
a   b          
bar one  z  1.0
    two  y  2.0
foo one  x  3.0
    two  w  4.0

[4 rows x 2 columns]

In [336]: data.reset_index()
Out[336]: 
     a    b  c    d
0  bar  one  z  1.0
1  bar  two  y  2.0
2  foo  one  x  3.0
3  foo  two  w  4.0

[4 rows x 4 columns]</pre>
<p>The output is more similar to a SQL table or a record array. The names for the
columns derived from the index are the ones stored in the <code class="docutils literal notranslate"><span class="pre">names</span></code> attribute.</p>
<p>You can use the <code class="docutils literal notranslate"><span class="pre">level</span></code> keyword to remove only a portion of the index:</p>
<pre class="literal-block">In [337]: frame
Out[337]: 
           c    d
c a   b          
z bar one  z  1.0
y bar two  y  2.0
x foo one  x  3.0
w foo two  w  4.0

[4 rows x 2 columns]

In [338]: frame.reset_index(level=1)
Out[338]: 
         a  c    d
c b               
z one  bar  z  1.0
y two  bar  y  2.0
x one  foo  x  3.0
w two  foo  w  4.0

[4 rows x 3 columns]</pre>
<p><code class="docutils literal notranslate"><span class="pre">reset_index</span></code> takes an optional parameter <code class="docutils literal notranslate"><span class="pre">drop</span></code> which if true simply
discards the index, instead of putting index values in the DataFrame’s columns.</p>
</div>
<div class="section" id="adding-an-ad-hoc-index">
<h3>Adding an ad hoc index<a class="headerlink" href="#adding-an-ad-hoc-index" title="Permalink to this headline">¶</a></h3>
<p>If you create an index yourself, you can just assign it to the <code class="docutils literal notranslate"><span class="pre">index</span></code> field:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="returning-a-view-versus-a-copy">
<span id="indexing-view-versus-copy"></span><h2>Returning a view versus a copy<a class="headerlink" href="#returning-a-view-versus-a-copy" title="Permalink to this headline">¶</a></h2>
<p>When setting values in a pandas object, care must be taken to avoid what is called
<code class="docutils literal notranslate"><span class="pre">chained</span> <span class="pre">indexing</span></code>. Here is an example.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [339]: </span><span class="n">dfmi</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;abcd&#39;</span><span class="p">),</span>
<span class="gp">   .....: </span>                     <span class="nb">list</span><span class="p">(</span><span class="s1">&#39;efgh&#39;</span><span class="p">),</span>
<span class="gp">   .....: </span>                     <span class="nb">list</span><span class="p">(</span><span class="s1">&#39;ijkl&#39;</span><span class="p">),</span>
<span class="gp">   .....: </span>                     <span class="nb">list</span><span class="p">(</span><span class="s1">&#39;mnop&#39;</span><span class="p">)],</span>
<span class="gp">   .....: </span>                    <span class="n">columns</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span><span class="s1">&#39;two&#39;</span><span class="p">],</span>
<span class="gp">   .....: </span>                                                        <span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">,</span><span class="s1">&#39;second&#39;</span><span class="p">]]))</span>
<span class="gp">   .....: </span>

<span class="gp">In [340]: </span><span class="n">dfmi</span>
<span class="gh">Out[340]: </span><span class="go"></span>
<span class="go">    one          two       </span>
<span class="go">  first second first second</span>
<span class="go">0     a      b     c      d</span>
<span class="go">1     e      f     g      h</span>
<span class="go">2     i      j     k      l</span>
<span class="go">3     m      n     o      p</span>

<span class="go">[4 rows x 4 columns]</span>
</pre></div>
</div>
<p>Compare these two access methods:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [341]: </span><span class="n">dfmi</span><span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">][</span><span class="s1">&#39;second&#39;</span><span class="p">]</span>
<span class="gh">Out[341]: </span><span class="go"></span>
<span class="go">0    b</span>
<span class="go">1    f</span>
<span class="go">2    j</span>
<span class="go">3    n</span>
<span class="go">Name: second, Length: 4, dtype: object</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [342]: </span><span class="n">dfmi</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span><span class="s1">&#39;second&#39;</span><span class="p">)]</span>
<span class="gh">Out[342]: </span><span class="go"></span>
<span class="go">0    b</span>
<span class="go">1    f</span>
<span class="go">2    j</span>
<span class="go">3    n</span>
<span class="go">Name: (one, second), Length: 4, dtype: object</span>
</pre></div>
</div>
<p>These both yield the same results, so which should you use? It is instructive to understand the order
of operations on these and why method 2 (<code class="docutils literal notranslate"><span class="pre">.loc</span></code>) is much preferred over method 1 (chained <code class="docutils literal notranslate"><span class="pre">[]</span></code>).</p>
<p><code class="docutils literal notranslate"><span class="pre">dfmi['one']</span></code> selects the first level of the columns and returns a DataFrame that is singly-indexed.
Then another Python operation <code class="docutils literal notranslate"><span class="pre">dfmi_with_one['second']</span></code> selects the series indexed by <code class="docutils literal notranslate"><span class="pre">'second'</span></code>.
This is indicated by the variable <code class="docutils literal notranslate"><span class="pre">dfmi_with_one</span></code> because pandas sees these operations as separate events.
e.g. separate calls to <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>, so it has to treat them as linear operations, they happen one after another.</p>
<p>Contrast this to <code class="docutils literal notranslate"><span class="pre">df.loc[:,('one','second')]</span></code> which passes a nested tuple of <code class="docutils literal notranslate"><span class="pre">(slice(None),('one','second'))</span></code> to a single call to
<code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>. This allows pandas to deal with this as a single entity. Furthermore this order of operations <em>can</em> be significantly
faster, and allows one to index <em>both</em> axes if so desired.</p>
<div class="section" id="why-does-assignment-fail-when-using-chained-indexing">
<h3>Why does assignment fail when using chained indexing?<a class="headerlink" href="#why-does-assignment-fail-when-using-chained-indexing" title="Permalink to this headline">¶</a></h3>
<p>The problem in the previous section is just a performance issue. What’s up with
the <code class="docutils literal notranslate"><span class="pre">SettingWithCopy</span></code> warning? We don’t <strong>usually</strong> throw warnings around when
you do something that might cost a few extra milliseconds!</p>
<p>But it turns out that assigning to the product of chained indexing has
inherently unpredictable results. To see this, think about how the Python
interpreter executes this code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dfmi</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;second&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>
<span class="c1"># becomes</span>
<span class="n">dfmi</span><span class="o">.</span><span class="n">loc</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">((</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;second&#39;</span><span class="p">)),</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>But this code is handled differently:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dfmi</span><span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">][</span><span class="s1">&#39;second&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
<span class="c1"># becomes</span>
<span class="n">dfmi</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>See that <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> in there? Outside of simple cases, it’s very hard to
predict whether it will return a view or a copy (it depends on the memory layout
of the array, about which pandas makes no guarantees), and therefore whether
the <code class="docutils literal notranslate"><span class="pre">__setitem__</span></code> will modify <code class="docutils literal notranslate"><span class="pre">dfmi</span></code> or a temporary object that gets thrown
out immediately afterward. <strong>That’s</strong> what <code class="docutils literal notranslate"><span class="pre">SettingWithCopy</span></code> is warning you
about!</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You may be wondering whether we should be concerned about the <code class="docutils literal notranslate"><span class="pre">loc</span></code>
property in the first example. But <code class="docutils literal notranslate"><span class="pre">dfmi.loc</span></code> is guaranteed to be <code class="docutils literal notranslate"><span class="pre">dfmi</span></code>
itself with modified indexing behavior, so <code class="docutils literal notranslate"><span class="pre">dfmi.loc.__getitem__</span></code> /
<code class="docutils literal notranslate"><span class="pre">dfmi.loc.__setitem__</span></code> operate on <code class="docutils literal notranslate"><span class="pre">dfmi</span></code> directly. Of course,
<code class="docutils literal notranslate"><span class="pre">dfmi.loc.__getitem__(idx)</span></code> may be a view or a copy of <code class="docutils literal notranslate"><span class="pre">dfmi</span></code>.</p>
</div>
<p>Sometimes a <code class="docutils literal notranslate"><span class="pre">SettingWithCopy</span></code> warning will arise at times when there’s no
obvious chained indexing going on. <strong>These</strong> are the bugs that
<code class="docutils literal notranslate"><span class="pre">SettingWithCopy</span></code> is designed to catch! Pandas is probably trying to warn you
that you’ve done this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">do_something</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">]]</span>  <span class="c1"># Is foo a view? A copy? Nobody knows!</span>
    <span class="c1"># ... many lines here ...</span>
    <span class="n">foo</span><span class="p">[</span><span class="s1">&#39;quux&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>  <span class="c1"># We don&#39;t know whether this will modify df or not!</span>
    <span class="k">return</span> <span class="n">foo</span>
</pre></div>
</div>
<p>Yikes!</p>
</div>
<div class="section" id="evaluation-order-matters">
<span id="indexing-evaluation-order"></span><h3>Evaluation order matters<a class="headerlink" href="#evaluation-order-matters" title="Permalink to this headline">¶</a></h3>
<p>When you use chained indexing, the order and type of the indexing operation
partially determine whether the result is a slice into the original object, or
a copy of the slice.</p>
<p>Pandas has the <code class="docutils literal notranslate"><span class="pre">SettingWithCopyWarning</span></code> because assigning to a copy of a
slice is frequently not intentional, but a mistake caused by chained indexing
returning a copy where a slice was expected.</p>
<p>If you would like pandas to be more or less trusting about assignment to a
chained indexing expression, you can set the <a class="reference internal" href="options.html#options"><span class="std std-ref">option</span></a>
<code class="docutils literal notranslate"><span class="pre">mode.chained_assignment</span></code> to one of these values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'warn'</span></code>, the default, means a <code class="docutils literal notranslate"><span class="pre">SettingWithCopyWarning</span></code> is printed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'raise'</span></code> means pandas will raise a <code class="docutils literal notranslate"><span class="pre">SettingWithCopyException</span></code>
you have to deal with.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> will suppress the warnings entirely.</p></li>
</ul>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [343]: </span><span class="n">dfb</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span>
<span class="gp">   .....: </span>                           <span class="s1">&#39;three&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;six&#39;</span><span class="p">],</span>
<span class="gp">   .....: </span>                    <span class="s1">&#39;c&#39;</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">7</span><span class="p">)})</span>
<span class="gp">   .....: </span>

<span class="go"># This will show the SettingWithCopyWarning</span>
<span class="go"># but the frame values will be set</span>
<span class="gp">In [344]: </span><span class="n">dfb</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">][</span><span class="n">dfb</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;o&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">42</span>
</pre></div>
</div>
<p>This however is operating on a copy and will not work.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s1">&#39;mode.chained_assignment&#39;</span><span class="p">,</span><span class="s1">&#39;warn&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dfb</span><span class="p">[</span><span class="n">dfb</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;o&#39;</span><span class="p">)][</span><span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span>
<span class="go">Traceback (most recent call last)</span>
<span class="go">     ...</span>
<span class="go">SettingWithCopyWarning:</span>
<span class="go">     A value is trying to be set on a copy of a slice from a DataFrame.</span>
<span class="go">     Try using .loc[row_index,col_indexer] = value instead</span>
</pre></div>
</div>
<p>A chained assignment can also crop up in setting in a mixed dtype frame.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These setting rules apply to all of <code class="docutils literal notranslate"><span class="pre">.loc/.iloc</span></code>.</p>
</div>
<p>This is the correct access method:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [345]: </span><span class="n">dfc</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:[</span><span class="s1">&#39;aaa&#39;</span><span class="p">,</span><span class="s1">&#39;bbb&#39;</span><span class="p">,</span><span class="s1">&#39;ccc&#39;</span><span class="p">],</span><span class="s1">&#39;B&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]})</span>

<span class="gp">In [346]: </span><span class="n">dfc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">11</span>

<span class="gp">In [347]: </span><span class="n">dfc</span>
<span class="gh">Out[347]: </span><span class="go"></span>
<span class="go">     A  B</span>
<span class="go">0   11  1</span>
<span class="go">1  bbb  2</span>
<span class="go">2  ccc  3</span>

<span class="go">[3 rows x 2 columns]</span>
</pre></div>
</div>
<p>This <em>can</em> work at times, but it is not guaranteed to, and therefore should be avoided:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [348]: </span><span class="n">dfc</span> <span class="o">=</span> <span class="n">dfc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="gp">In [349]: </span><span class="n">dfc</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">111</span>

<span class="gp">In [350]: </span><span class="n">dfc</span>
<span class="gh">Out[350]: </span><span class="go"></span>
<span class="go">     A  B</span>
<span class="go">0  111  1</span>
<span class="go">1  bbb  2</span>
<span class="go">2  ccc  3</span>

<span class="go">[3 rows x 2 columns]</span>
</pre></div>
</div>
<p>This will <strong>not</strong> work at all, and so should be avoided:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s1">&#39;mode.chained_assignment&#39;</span><span class="p">,</span><span class="s1">&#39;raise&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dfc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1111</span>
<span class="go">Traceback (most recent call last)</span>
<span class="go">     ...</span>
<span class="go">SettingWithCopyException:</span>
<span class="go">     A value is trying to be set on a copy of a slice from a DataFrame.</span>
<span class="go">     Try using .loc[row_index,col_indexer] = value instead</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The chained assignment warnings / exceptions are aiming to inform the user of a possibly invalid
assignment. There may be false positives; situations where a chained assignment is inadvertently
reported.</p>
</div>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../_sources/user_guide/indexing.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2008-2014, the pandas development team.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>