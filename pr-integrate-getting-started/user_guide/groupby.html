

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Group By: split-apply-combine &#8212; pandas 0.25.3 documentation</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="../_static/sphinx-bootstrap.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/getting_started.css" />
    <link href="../_static/css/custom.css" rel="stylesheet">
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Time Series / Date functionality" href="timeseries.html" />
    <link rel="prev" title="Computational tools" href="computation.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main">

<a class="navbar-brand" href="../index.html">
  <img src="../_static/pandas.svg" class="logo" alt="logo">
</a>

<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
</button>

<div id="navbar-menu" class="collapse navbar-collapse">
  <ul id="navbar-main-elements" class="navbar-nav mr-auto">
    <li class="nav-item">
        <a class="nav-link" href="../index.html">Home</a>
    </li>
    
    
    <li class="nav-item ">
        <a class="nav-link" href="../getting_started/index.html">Getting started</a>
    </li>
    
    <li class="nav-item active">
        <a class="nav-link" href="index.html">User Guide</a>
    </li>
    
    <li class="nav-item ">
        <a class="nav-link" href="../reference/index.html">API Reference</a>
    </li>
    
    <li class="nav-item ">
        <a class="nav-link" href="../development/index.html">Development</a>
    </li>
    
    <li class="nav-item ">
        <a class="nav-link" href="../whatsnew/index.html">Release Notes</a>
    </li>
    
    <li class="nav-item ">
        <a class="nav-link" href="../development/index.html">Development</a>
    </li>
    
  </ul>
  <ul class="navbar-nav ml-auto">
    <li class="nav-item">
      <a class="nav-link" href="https://github.com/pandas-dev/pandas" target="_blank" rel="noopener">
        <span><i class="fab fa-github-alt" style="color:#333;font-size:1rem;line-height:1.25"></i></span>
      </a>
    </li>
    <li class="nav-item">
      <a class="nav-link" href="https://twitter.com/pandas_dev" target="_blank" rel="noopener">
        <span><i class="fab fa-twitter" style="color:#55acee;font-size:1rem;line-height:1.25"></i></span>
      </a>
    </li>
  </ul>
</div>
    </nav>

    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
          <div class="col-12 col-md-3 col-xl-2 bd-sidebar">
              

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">

  <div class="bd-toc-item active">
  

  <ul class="nav bd-sidenav">
      
      
      
      
        
          
              <li class="">
                  <a href="io.html">IO Tools (Text, CSV, HDF5, …)</a>
              </li>
          
        
          
              <li class="">
                  <a href="indexing.html">Indexing and Selecting Data</a>
              </li>
          
        
          
              <li class="">
                  <a href="advanced.html">MultiIndex / Advanced Indexing</a>
              </li>
          
        
          
              <li class="">
                  <a href="merging.html">Merge, join, and concatenate</a>
              </li>
          
        
          
              <li class="">
                  <a href="reshaping.html">Reshaping and Pivot Tables</a>
              </li>
          
        
          
              <li class="">
                  <a href="text.html">Working with Text Data</a>
              </li>
          
        
          
              <li class="">
                  <a href="missing_data.html">Working with missing data</a>
              </li>
          
        
          
              <li class="">
                  <a href="categorical.html">Categorical Data</a>
              </li>
          
        
          
              <li class="">
                  <a href="integer_na.html">Nullable Integer Data Type</a>
              </li>
          
        
          
              <li class="">
                  <a href="visualization.html">Visualization</a>
              </li>
          
        
          
              <li class="">
                  <a href="computation.html">Computational tools</a>
              </li>
          
        
          
              <li class="active">
                  <a href="">Group By: split-apply-combine</a>
              </li>
          
        
          
              <li class="">
                  <a href="timeseries.html">Time Series / Date functionality</a>
              </li>
          
        
          
              <li class="">
                  <a href="timedeltas.html">Time Deltas</a>
              </li>
          
        
          
              <li class="">
                  <a href="options.html">Options and Settings</a>
              </li>
          
        
          
              <li class="">
                  <a href="enhancingperf.html">Enhancing Performance</a>
              </li>
          
        
          
              <li class="">
                  <a href="sparse.html">Sparse data structures</a>
              </li>
          
        
          
              <li class="">
                  <a href="gotchas.html">Frequently Asked Questions (FAQ)</a>
              </li>
          
        
          
              <li class="">
                  <a href="cookbook.html">Cookbook</a>
              </li>
          
        
      
      
      
      
      
      
      
      
      
      
    </ul>

</nav>


              
          </div>

          <div class="d-none d-xl-block col-xl-2 bd-toc">
              

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#splitting-an-object-into-groups" class="nav-link">Splitting an object into groups</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#groupby-sorting" class="nav-link">GroupBy sorting</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#groupby-object-attributes" class="nav-link">GroupBy object attributes</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#groupby-with-multiindex" class="nav-link">GroupBy with MultiIndex</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#grouping-dataframe-with-index-levels-and-columns" class="nav-link">Grouping DataFrame with Index Levels and Columns</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#dataframe-column-selection-in-groupby" class="nav-link">DataFrame column selection in GroupBy</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#iterating-through-groups" class="nav-link">Iterating through groups</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#selecting-a-group" class="nav-link">Selecting a group</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#aggregation" class="nav-link">Aggregation</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#applying-multiple-functions-at-once" class="nav-link">Applying multiple functions at once</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#applying-different-functions-to-dataframe-columns" class="nav-link">Applying different functions to DataFrame columns</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#cython-optimized-aggregation-functions" class="nav-link">Cython-optimized aggregation functions</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#transformation" class="nav-link">Transformation</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#new-syntax-to-window-and-resample-operations" class="nav-link">New syntax to window and resample operations</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#filtration" class="nav-link">Filtration</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#dispatching-to-instance-methods" class="nav-link">Dispatching to instance methods</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#flexible-apply" class="nav-link">Flexible apply</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#other-useful-features" class="nav-link">Other useful features</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#automatic-exclusion-of-nuisance-columns" class="nav-link">Automatic exclusion of “nuisance” columns</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#handling-of-un-observed-categorical-values" class="nav-link">Handling of (un)observed Categorical values</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#na-and-nat-group-handling" class="nav-link">NA and NaT group handling</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#grouping-with-ordered-factors" class="nav-link">Grouping with ordered factors</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#grouping-with-a-grouper-specification" class="nav-link">Grouping with a Grouper specification</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#taking-the-first-rows-of-each-group" class="nav-link">Taking the first rows of each group</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#taking-the-nth-row-of-each-group" class="nav-link">Taking the nth row of each group</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#enumerate-group-items" class="nav-link">Enumerate group items</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#enumerate-groups" class="nav-link">Enumerate groups</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#plotting" class="nav-link">Plotting</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#piping-function-calls" class="nav-link">Piping function calls</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#examples" class="nav-link">Examples</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#regrouping-by-factor" class="nav-link">Regrouping by factor</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#multi-column-factorization" class="nav-link">Multi-column factorization</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#groupby-by-indexer-to-resample-data" class="nav-link">Groupby by Indexer to ‘resample’ data</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#returning-a-series-to-propagate-names" class="nav-link">Returning a Series to propagate names</a>
        </li>
    
            </ul>
        </li>
    
    </ul>
</nav>
              
            </div>

          <main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content" role="main">
              <div>
                
  <div class="section" id="group-by-split-apply-combine">
<span id="groupby"></span><h1>Group By: split-apply-combine<a class="headerlink" href="#group-by-split-apply-combine" title="Permalink to this headline">¶</a></h1>
<p>By “group by” we are referring to a process involving one or more of the following
steps:</p>
<ul class="simple">
<li><p><strong>Splitting</strong> the data into groups based on some criteria.</p></li>
<li><p><strong>Applying</strong> a function to each group independently.</p></li>
<li><p><strong>Combining</strong> the results into a data structure.</p></li>
</ul>
<p>Out of these, the split step is the most straightforward. In fact, in many
situations we may wish to split the data set into groups and do something with
those groups. In the apply step, we might wish to do one of the
following:</p>
<ul>
<li><p><strong>Aggregation</strong>: compute a summary statistic (or statistics) for each
group. Some examples:</p>
<blockquote>
<div><ul class="simple">
<li><p>Compute group sums or means.</p></li>
<li><p>Compute group sizes / counts.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>Transformation</strong>: perform some group-specific computations and return a
like-indexed object. Some examples:</p>
<blockquote>
<div><ul class="simple">
<li><p>Standardize data (zscore) within a group.</p></li>
<li><p>Filling NAs within groups with a value derived from each group.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>Filtration</strong>: discard some groups, according to a group-wise computation
that evaluates True or False. Some examples:</p>
<blockquote>
<div><ul class="simple">
<li><p>Discard data that belongs to groups with only a few members.</p></li>
<li><p>Filter out data based on the group sum or mean.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Some combination of the above: GroupBy will examine the results of the apply
step and try to return a sensibly combined result if it doesn’t fit into
either of the above two categories.</p></li>
</ul>
<p>Since the set of object instance methods on pandas data structures are generally
rich and expressive, we often simply want to invoke, say, a DataFrame function
on each group. The name GroupBy should be quite familiar to those who have used
a SQL-based tool (or <code class="docutils literal notranslate"><span class="pre">itertools</span></code>), in which you can write code like:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="n">Column1</span><span class="p">,</span> <span class="n">Column2</span><span class="p">,</span> <span class="n">mean</span><span class="p">(</span><span class="n">Column3</span><span class="p">),</span> <span class="k">sum</span><span class="p">(</span><span class="n">Column4</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">SomeTable</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">Column1</span><span class="p">,</span> <span class="n">Column2</span>
</pre></div>
</div>
<p>We aim to make operations like this natural and easy to express using
pandas. We’ll address each area of GroupBy functionality then provide some
non-trivial examples / use cases.</p>
<p>See the <a class="reference internal" href="cookbook.html#cookbook-grouping"><span class="std std-ref">cookbook</span></a> for some advanced strategies.</p>
<div class="section" id="splitting-an-object-into-groups">
<span id="groupby-split"></span><h2>Splitting an object into groups<a class="headerlink" href="#splitting-an-object-into-groups" title="Permalink to this headline">¶</a></h2>
<p>pandas objects can be split on any of their axes. The abstract definition of
grouping is to provide a mapping of labels to group names. To create a GroupBy
object (more on what the GroupBy object is later), you may do the following:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([(</span><span class="s1">&#39;bird&#39;</span><span class="p">,</span> <span class="s1">&#39;Falconiformes&#39;</span><span class="p">,</span> <span class="mf">389.0</span><span class="p">),</span>
<span class="gp">   ...: </span>                   <span class="p">(</span><span class="s1">&#39;bird&#39;</span><span class="p">,</span> <span class="s1">&#39;Psittaciformes&#39;</span><span class="p">,</span> <span class="mf">24.0</span><span class="p">),</span>
<span class="gp">   ...: </span>                   <span class="p">(</span><span class="s1">&#39;mammal&#39;</span><span class="p">,</span> <span class="s1">&#39;Carnivora&#39;</span><span class="p">,</span> <span class="mf">80.2</span><span class="p">),</span>
<span class="gp">   ...: </span>                   <span class="p">(</span><span class="s1">&#39;mammal&#39;</span><span class="p">,</span> <span class="s1">&#39;Primates&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
<span class="gp">   ...: </span>                   <span class="p">(</span><span class="s1">&#39;mammal&#39;</span><span class="p">,</span> <span class="s1">&#39;Carnivora&#39;</span><span class="p">,</span> <span class="mi">58</span><span class="p">)],</span>
<span class="gp">   ...: </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;falcon&#39;</span><span class="p">,</span> <span class="s1">&#39;parrot&#39;</span><span class="p">,</span> <span class="s1">&#39;lion&#39;</span><span class="p">,</span> <span class="s1">&#39;monkey&#39;</span><span class="p">,</span> <span class="s1">&#39;leopard&#39;</span><span class="p">],</span>
<span class="gp">   ...: </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;class&#39;</span><span class="p">,</span> <span class="s1">&#39;order&#39;</span><span class="p">,</span> <span class="s1">&#39;max_speed&#39;</span><span class="p">))</span>
<span class="gp">   ...: </span>

<span class="gp">In [2]: </span><span class="n">df</span>
<span class="gh">Out[2]: </span><span class="go"></span>
<span class="go">          class           order  max_speed</span>
<span class="go">falcon     bird   Falconiformes      389.0</span>
<span class="go">parrot     bird  Psittaciformes       24.0</span>
<span class="go">lion     mammal       Carnivora       80.2</span>
<span class="go">monkey   mammal        Primates        NaN</span>
<span class="go">leopard  mammal       Carnivora       58.0</span>

<span class="go"># default is axis=0</span>
<span class="gp">In [3]: </span><span class="n">grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;class&#39;</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>

<span class="gp">In [5]: </span><span class="n">grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;class&#39;</span><span class="p">,</span> <span class="s1">&#39;order&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The mapping can be specified many different ways:</p>
<ul class="simple">
<li><p>A Python function, to be called on each of the axis labels.</p></li>
<li><p>A list or NumPy array of the same length as the selected axis.</p></li>
<li><p>A dict or <code class="docutils literal notranslate"><span class="pre">Series</span></code>, providing a <code class="docutils literal notranslate"><span class="pre">label</span> <span class="pre">-&gt;</span> <span class="pre">group</span> <span class="pre">name</span></code> mapping.</p></li>
<li><p>For <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> objects, a string indicating a column to be used to group.
Of course <code class="docutils literal notranslate"><span class="pre">df.groupby('A')</span></code> is just syntactic sugar for
<code class="docutils literal notranslate"><span class="pre">df.groupby(df['A'])</span></code>, but it makes life simpler.</p></li>
<li><p>For <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> objects, a string indicating an index level to be used to
group.</p></li>
<li><p>A list of any of the above things.</p></li>
</ul>
<p>Collectively we refer to the grouping objects as the <strong>keys</strong>. For example,
consider the following <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>:</p>
<div class="alert alert-info">
<p class="admonition-title">Note</p>
<p>A string passed to <code class="docutils literal notranslate"><span class="pre">groupby</span></code> may refer to either a column or an index level.
If a string matches both a column name and an index level name, a
<code class="docutils literal notranslate"><span class="pre">ValueError</span></code> will be raised.</p>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [6]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span>
<span class="gp">   ...: </span>                         <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">],</span>
<span class="gp">   ...: </span>                   <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">,</span>
<span class="gp">   ...: </span>                         <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">],</span>
<span class="gp">   ...: </span>                   <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
<span class="gp">   ...: </span>                   <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">8</span><span class="p">)})</span>
<span class="gp">   ...: </span>

<span class="gp">In [7]: </span><span class="n">df</span>
<span class="gh">Out[7]: </span><span class="go"></span>
<span class="go">     A      B         C         D</span>
<span class="go">0  foo    one  0.469112 -0.861849</span>
<span class="go">1  bar    one -0.282863 -2.104569</span>
<span class="go">2  foo    two -1.509059 -0.494929</span>
<span class="go">3  bar  three -1.135632  1.071804</span>
<span class="go">4  foo    two  1.212112  0.721555</span>
<span class="go">5  bar    two -0.173215 -0.706771</span>
<span class="go">6  foo    one  0.119209 -1.039575</span>
<span class="go">7  foo  three -1.044236  0.271860</span>
</pre></div>
</div>
<p>On a DataFrame, we obtain a GroupBy object by calling <a class="reference internal" href="../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby" title="pandas.DataFrame.groupby"><code class="xref py py-meth docutils literal notranslate"><span class="pre">groupby()</span></code></a>.
We could naturally group by either the <code class="docutils literal notranslate"><span class="pre">A</span></code> or <code class="docutils literal notranslate"><span class="pre">B</span></code> columns, or both:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [8]: </span><span class="n">grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>

<span class="gp">In [9]: </span><span class="n">grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.</span></p>
</div>
<p>If we also have a MultiIndex on columns <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>, we can group by all
but the specified columns</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [10]: </span><span class="n">df2</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">])</span>

<span class="gp">In [11]: </span><span class="n">grouped</span> <span class="o">=</span> <span class="n">df2</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">df2</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">difference</span><span class="p">([</span><span class="s1">&#39;B&#39;</span><span class="p">]))</span>

<span class="gp">In [12]: </span><span class="n">grouped</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gh">Out[12]: </span><span class="go"></span>
<span class="go">            C         D</span>
<span class="go">A                      </span>
<span class="go">bar -1.591710 -1.739537</span>
<span class="go">foo -0.752861 -1.402938</span>
</pre></div>
</div>
<p>These will split the DataFrame on its index (rows). We could also split by the
columns:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [13]: </span><span class="k">def</span> <span class="nf">get_letter_type</span><span class="p">(</span><span class="n">letter</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">if</span> <span class="n">letter</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="s1">&#39;aeiou&#39;</span><span class="p">:</span>
<span class="gp">   ....: </span>        <span class="k">return</span> <span class="s1">&#39;vowel&#39;</span>
<span class="gp">   ....: </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">   ....: </span>        <span class="k">return</span> <span class="s1">&#39;consonant&#39;</span>
<span class="gp">   ....: </span>

<span class="gp">In [14]: </span><span class="n">grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">get_letter_type</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>pandas <code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code> objects support duplicate values. If a
non-unique index is used as the group key in a groupby operation, all values
for the same index value will be considered to be in one group and thus the
output of aggregation functions will only contain unique index values:</p>
<pre class="literal-block">In [15]: lst = [1, 2, 3, 1, 2, 3]

In [16]: s = pd.Series([1, 2, 3, 10, 20, 30], lst)

In [17]: grouped = s.groupby(level=0)

In [18]: grouped.first()
Out[18]: 
1    1
2    2
3    3
dtype: int64

In [19]: grouped.last()
Out[19]: 
1    10
2    20
3    30
dtype: int64

In [20]: grouped.sum()
Out[20]: 
1    11
2    22
3    33
dtype: int64</pre>
<p>Note that <strong>no splitting occurs</strong> until it’s needed. Creating the GroupBy object
only verifies that you’ve passed a valid mapping.</p>
<div class="alert alert-info">
<p class="admonition-title">Note</p>
<p>Many kinds of complicated data manipulations can be expressed in terms of
GroupBy operations (though can’t be guaranteed to be the most
efficient). You can get quite creative with the label mapping functions.</p>
</div>
<div class="section" id="groupby-sorting">
<span id="id1"></span><h3>GroupBy sorting<a class="headerlink" href="#groupby-sorting" title="Permalink to this headline">¶</a></h3>
<p>By default the group keys are sorted during the <code class="docutils literal notranslate"><span class="pre">groupby</span></code> operation. You may however pass <code class="docutils literal notranslate"><span class="pre">sort=False</span></code> for potential speedups:</p>
<pre class="literal-block">In [21]: df2 = pd.DataFrame({'X': ['B', 'B', 'A', 'A'], 'Y': [1, 2, 3, 4]})

In [22]: df2.groupby(['X']).sum()
Out[22]: 
   Y
X   
A  7
B  3

In [23]: df2.groupby(['X'], sort=False).sum()
Out[23]: 
   Y
X   
B  3
A  7</pre>
<p>Note that <code class="docutils literal notranslate"><span class="pre">groupby</span></code> will preserve the order in which <em>observations</em> are sorted <em>within</em> each group.
For example, the groups created by <code class="docutils literal notranslate"><span class="pre">groupby()</span></code> below are in the order they appeared in the original <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>:</p>
<pre class="literal-block">In [24]: df3 = pd.DataFrame({'X': ['A', 'B', 'A', 'B'], 'Y': [1, 4, 3, 2]})

In [25]: df3.groupby(['X']).get_group('A')
Out[25]: 
   X  Y
0  A  1
2  A  3

In [26]: df3.groupby(['X']).get_group('B')
Out[26]: 
   X  Y
1  B  4
3  B  2</pre>
</div>
<div class="section" id="groupby-object-attributes">
<span id="groupby-attributes"></span><h3>GroupBy object attributes<a class="headerlink" href="#groupby-object-attributes" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">groups</span></code> attribute is a dict whose keys are the computed unique groups
and corresponding values being the axis labels belonging to each group. In the
above example we have:</p>
<pre class="literal-block">In [27]: df.groupby('A').groups
Out[27]: 
{'bar': Int64Index([1, 3, 5], dtype='int64'),
 'foo': Int64Index([0, 2, 4, 6, 7], dtype='int64')}

In [28]: df.groupby(get_letter_type, axis=1).groups
Out[28]: 
{'consonant': Index(['B', 'C', 'D'], dtype='object'),
 'vowel': Index(['A'], dtype='object')}</pre>
<p>Calling the standard Python <code class="docutils literal notranslate"><span class="pre">len</span></code> function on the GroupBy object just returns
the length of the <code class="docutils literal notranslate"><span class="pre">groups</span></code> dict, so it is largely just a convenience:</p>
<pre class="literal-block">In [29]: grouped = df.groupby(['A', 'B'])

In [30]: grouped.groups
Out[30]: 
{('bar', 'one'): Int64Index([1], dtype='int64'),
 ('bar', 'three'): Int64Index([3], dtype='int64'),
 ('bar', 'two'): Int64Index([5], dtype='int64'),
 ('foo', 'one'): Int64Index([0, 6], dtype='int64'),
 ('foo', 'three'): Int64Index([7], dtype='int64'),
 ('foo', 'two'): Int64Index([2, 4], dtype='int64')}

In [31]: len(grouped)
Out[31]: 6</pre>
<p id="groupby-tabcompletion"><code class="docutils literal notranslate"><span class="pre">GroupBy</span></code> will tab complete column names (and other attributes):</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [32]: </span><span class="n">df</span>
<span class="gh">Out[32]: </span><span class="go"></span>
<span class="go">               height      weight  gender</span>
<span class="go">2000-01-01  42.849980  157.500553    male</span>
<span class="go">2000-01-02  49.607315  177.340407    male</span>
<span class="go">2000-01-03  56.293531  171.524640    male</span>
<span class="go">2000-01-04  48.421077  144.251986  female</span>
<span class="go">2000-01-05  46.556882  152.526206    male</span>
<span class="go">2000-01-06  68.448851  168.272968  female</span>
<span class="go">2000-01-07  70.757698  136.431469    male</span>
<span class="go">2000-01-08  58.909500  176.499753  female</span>
<span class="go">2000-01-09  76.435631  174.094104  female</span>
<span class="go">2000-01-10  45.306120  177.540920    male</span>

<span class="gp">In [33]: </span><span class="n">gb</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;gender&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [34]: </span><span class="n">gb</span><span class="o">.&lt;</span><span class="n">TAB</span><span class="o">&gt;</span>  <span class="c1"># noqa: E225, E999</span>
<span class="go">gb.agg        gb.boxplot    gb.cummin     gb.describe   gb.filter     gb.get_group  gb.height     gb.last       gb.median     gb.ngroups    gb.plot       gb.rank       gb.std        gb.transform</span>
<span class="go">gb.aggregate  gb.count      gb.cumprod    gb.dtype      gb.first      gb.groups     gb.hist       gb.max        gb.min        gb.nth        gb.prod       gb.resample   gb.sum        gb.var</span>
<span class="go">gb.apply      gb.cummax     gb.cumsum     gb.fillna     gb.gender     gb.head       gb.indices    gb.mean       gb.name       gb.ohlc       gb.quantile   gb.size       gb.tail       gb.weight</span>
</pre></div>
</div>
</div>
<div class="section" id="groupby-with-multiindex">
<span id="groupby-multiindex"></span><h3>GroupBy with MultiIndex<a class="headerlink" href="#groupby-with-multiindex" title="Permalink to this headline">¶</a></h3>
<p>With <a class="reference internal" href="advanced.html#advanced-hierarchical"><span class="std std-ref">hierarchically-indexed data</span></a>, it’s quite
natural to group by one of the levels of the hierarchy.</p>
<p>Let’s create a Series with a two-level <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [35]: </span><span class="n">arrays</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">],</span>
<span class="gp">   ....: </span>          <span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">]]</span>
<span class="gp">   ....: </span>

<span class="gp">In [36]: </span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;second&#39;</span><span class="p">])</span>

<span class="gp">In [37]: </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

<span class="gp">In [38]: </span><span class="n">s</span>
<span class="gh">Out[38]: </span><span class="go"></span>
<span class="go">first  second</span>
<span class="go">bar    one      -0.919854</span>
<span class="go">       two      -0.042379</span>
<span class="go">baz    one       1.247642</span>
<span class="go">       two      -0.009920</span>
<span class="go">foo    one       0.290213</span>
<span class="go">       two       0.495767</span>
<span class="go">qux    one       0.362949</span>
<span class="go">       two       1.548106</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>We can then group by one of the levels in <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [39]: </span><span class="n">grouped</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="gp">In [40]: </span><span class="n">grouped</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gh">Out[40]: </span><span class="go"></span>
<span class="go">first</span>
<span class="go">bar   -0.962232</span>
<span class="go">baz    1.237723</span>
<span class="go">foo    0.785980</span>
<span class="go">qux    1.911055</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>If the MultiIndex has names specified, these can be passed instead of the level
number:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [41]: </span><span class="n">s</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s1">&#39;second&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gh">Out[41]: </span><span class="go"></span>
<span class="go">second</span>
<span class="go">one    0.980950</span>
<span class="go">two    1.991575</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>The aggregation functions such as <code class="docutils literal notranslate"><span class="pre">sum</span></code> will take the level parameter
directly. Additionally, the resulting index will be named according to the
chosen level:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [42]: </span><span class="n">s</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s1">&#39;second&#39;</span><span class="p">)</span>
<span class="gh">Out[42]: </span><span class="go"></span>
<span class="go">second</span>
<span class="go">one    0.980950</span>
<span class="go">two    1.991575</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>Grouping with multiple levels is supported.</p>
<pre class="literal-block">In [43]: s
Out[43]: 
first  second  third
bar    doo     one     -1.131345
               two     -0.089329
baz    bee     one      0.337863
               two     -0.945867
foo    bop     one     -0.932132
               two      1.956030
qux    bop     one      0.017587
               two     -0.016692
dtype: float64

In [44]: s.groupby(level=['first', 'second']).sum()
Out[44]: 
first  second
bar    doo      -1.220674
baz    bee      -0.608004
foo    bop       1.023898
qux    bop       0.000895
dtype: float64</pre>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.</span></p>
</div>
<p>Index level names may be supplied as keys.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [45]: </span><span class="n">s</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;second&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gh">Out[45]: </span><span class="go"></span>
<span class="go">first  second</span>
<span class="go">bar    doo      -1.220674</span>
<span class="go">baz    bee      -0.608004</span>
<span class="go">foo    bop       1.023898</span>
<span class="go">qux    bop       0.000895</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>More on the <code class="docutils literal notranslate"><span class="pre">sum</span></code> function and aggregation later.</p>
</div>
<div class="section" id="grouping-dataframe-with-index-levels-and-columns">
<h3>Grouping DataFrame with Index Levels and Columns<a class="headerlink" href="#grouping-dataframe-with-index-levels-and-columns" title="Permalink to this headline">¶</a></h3>
<p>A DataFrame may be grouped by a combination of columns and index levels by
specifying the column names as strings and the index levels as <code class="docutils literal notranslate"><span class="pre">pd.Grouper</span></code>
objects.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [46]: </span><span class="n">arrays</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">],</span>
<span class="gp">   ....: </span>          <span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">]]</span>
<span class="gp">   ....: </span>

<span class="gp">In [47]: </span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;second&#39;</span><span class="p">])</span>

<span class="gp">In [48]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">   ....: </span>                   <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)},</span>
<span class="gp">   ....: </span>                  <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
<span class="gp">   ....: </span>

<span class="gp">In [49]: </span><span class="n">df</span>
<span class="gh">Out[49]: </span><span class="go"></span>
<span class="go">              A  B</span>
<span class="go">first second      </span>
<span class="go">bar   one     1  0</span>
<span class="go">      two     1  1</span>
<span class="go">baz   one     1  2</span>
<span class="go">      two     1  3</span>
<span class="go">foo   one     2  4</span>
<span class="go">      two     2  5</span>
<span class="go">qux   one     3  6</span>
<span class="go">      two     3  7</span>
</pre></div>
</div>
<p>The following example groups <code class="docutils literal notranslate"><span class="pre">df</span></code> by the <code class="docutils literal notranslate"><span class="pre">second</span></code> index level and
the <code class="docutils literal notranslate"><span class="pre">A</span></code> column.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [50]: </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">Grouper</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;A&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gh">Out[50]: </span><span class="go"></span>
<span class="go">          B</span>
<span class="go">second A   </span>
<span class="go">one    1  2</span>
<span class="go">       2  4</span>
<span class="go">       3  6</span>
<span class="go">two    1  4</span>
<span class="go">       2  5</span>
<span class="go">       3  7</span>
</pre></div>
</div>
<p>Index levels may also be specified by name.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [51]: </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">Grouper</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s1">&#39;second&#39;</span><span class="p">),</span> <span class="s1">&#39;A&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gh">Out[51]: </span><span class="go"></span>
<span class="go">          B</span>
<span class="go">second A   </span>
<span class="go">one    1  2</span>
<span class="go">       2  4</span>
<span class="go">       3  6</span>
<span class="go">two    1  4</span>
<span class="go">       2  5</span>
<span class="go">       3  7</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.</span></p>
</div>
<p>Index level names may be specified as keys directly to <code class="docutils literal notranslate"><span class="pre">groupby</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [52]: </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gh">Out[52]: </span><span class="go"></span>
<span class="go">          B</span>
<span class="go">second A   </span>
<span class="go">one    1  2</span>
<span class="go">       2  4</span>
<span class="go">       3  6</span>
<span class="go">two    1  4</span>
<span class="go">       2  5</span>
<span class="go">       3  7</span>
</pre></div>
</div>
</div>
<div class="section" id="dataframe-column-selection-in-groupby">
<h3>DataFrame column selection in GroupBy<a class="headerlink" href="#dataframe-column-selection-in-groupby" title="Permalink to this headline">¶</a></h3>
<p>Once you have created the GroupBy object from a DataFrame, you might want to do
something different for each of the columns. Thus, using <code class="docutils literal notranslate"><span class="pre">[]</span></code> similar to
getting a column from a DataFrame, you can do:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [53]: </span><span class="n">grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>

<span class="gp">In [54]: </span><span class="n">grouped_C</span> <span class="o">=</span> <span class="n">grouped</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]</span>

<span class="gp">In [55]: </span><span class="n">grouped_D</span> <span class="o">=</span> <span class="n">grouped</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>This is mainly syntactic sugar for the alternative and much more verbose:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [56]: </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>
<span class="gh">Out[56]: </span><span class="go">&lt;pandas.core.groupby.generic.SeriesGroupBy object at 0x7fd41af52410&gt;</span>
</pre></div>
</div>
<p>Additionally this method avoids recomputing the internal grouping information
derived from the passed key.</p>
</div>
</div>
<div class="section" id="iterating-through-groups">
<span id="groupby-iterating-label"></span><h2>Iterating through groups<a class="headerlink" href="#iterating-through-groups" title="Permalink to this headline">¶</a></h2>
<p>With the GroupBy object in hand, iterating through the grouped data is very
natural and functions similarly to <a class="reference external" href="https://docs.python.org/3/library/itertools.html#itertools.groupby" title="(in Python v3.8)"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.groupby()</span></code></a>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [57]: </span><span class="n">grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>

<span class="gp">In [58]: </span><span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">grouped</span><span class="p">:</span>
<span class="gp">   ....: </span>    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="gp">   ....: </span>    <span class="k">print</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
<span class="gp">   ....: </span>
<span class="go">bar</span>
<span class="go">     A      B         C         D</span>
<span class="go">1  bar    one  0.254161  1.511763</span>
<span class="go">3  bar  three  0.215897 -0.990582</span>
<span class="go">5  bar    two -0.077118  1.211526</span>
<span class="go">foo</span>
<span class="go">     A      B         C         D</span>
<span class="go">0  foo    one -0.575247  1.346061</span>
<span class="go">2  foo    two -1.143704  1.627081</span>
<span class="go">4  foo    two  1.193555 -0.441652</span>
<span class="go">6  foo    one -0.408530  0.268520</span>
<span class="go">7  foo  three -0.862495  0.024580</span>
</pre></div>
</div>
<p>In the case of grouping by multiple keys, the group name will be a tuple:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [59]: </span><span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">]):</span>
<span class="gp">   ....: </span>    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="gp">   ....: </span>    <span class="k">print</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
<span class="gp">   ....: </span>
<span class="go">(&#39;bar&#39;, &#39;one&#39;)</span>
<span class="go">     A    B         C         D</span>
<span class="go">1  bar  one  0.254161  1.511763</span>
<span class="go">(&#39;bar&#39;, &#39;three&#39;)</span>
<span class="go">     A      B         C         D</span>
<span class="go">3  bar  three  0.215897 -0.990582</span>
<span class="go">(&#39;bar&#39;, &#39;two&#39;)</span>
<span class="go">     A    B         C         D</span>
<span class="go">5  bar  two -0.077118  1.211526</span>
<span class="go">(&#39;foo&#39;, &#39;one&#39;)</span>
<span class="go">     A    B         C         D</span>
<span class="go">0  foo  one -0.575247  1.346061</span>
<span class="go">6  foo  one -0.408530  0.268520</span>
<span class="go">(&#39;foo&#39;, &#39;three&#39;)</span>
<span class="go">     A      B         C        D</span>
<span class="go">7  foo  three -0.862495  0.02458</span>
<span class="go">(&#39;foo&#39;, &#39;two&#39;)</span>
<span class="go">     A    B         C         D</span>
<span class="go">2  foo  two -1.143704  1.627081</span>
<span class="go">4  foo  two  1.193555 -0.441652</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="timeseries.html#timeseries-iterating-label"><span class="std std-ref">Iterating through groups</span></a>.</p>
</div>
<div class="section" id="selecting-a-group">
<h2>Selecting a group<a class="headerlink" href="#selecting-a-group" title="Permalink to this headline">¶</a></h2>
<p>A single group can be selected using
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_group()</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [60]: </span><span class="n">grouped</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">)</span>
<span class="gh">Out[60]: </span><span class="go"></span>
<span class="go">     A      B         C         D</span>
<span class="go">1  bar    one  0.254161  1.511763</span>
<span class="go">3  bar  three  0.215897 -0.990582</span>
<span class="go">5  bar    two -0.077118  1.211526</span>
</pre></div>
</div>
<p>Or for an object grouped on multiple columns:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [61]: </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">get_group</span><span class="p">((</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">))</span>
<span class="gh">Out[61]: </span><span class="go"></span>
<span class="go">     A    B         C         D</span>
<span class="go">1  bar  one  0.254161  1.511763</span>
</pre></div>
</div>
</div>
<div class="section" id="aggregation">
<span id="groupby-aggregate"></span><h2>Aggregation<a class="headerlink" href="#aggregation" title="Permalink to this headline">¶</a></h2>
<p>Once the GroupBy object has been created, several methods are available to
perform a computation on the grouped data. These operations are similar to the
<a class="reference internal" href="../getting_started/basics.html#basics-aggregate"><span class="std std-ref">aggregating API</span></a>, <a class="reference internal" href="computation.html#stats-aggregate"><span class="std std-ref">window functions API</span></a>,
and <a class="reference internal" href="timeseries.html#timeseries-aggregate"><span class="std std-ref">resample API</span></a>.</p>
<p>An obvious one is aggregation via the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">aggregate()</span></code> or equivalently
<code class="xref py py-meth docutils literal notranslate"><span class="pre">agg()</span></code> method:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [62]: </span><span class="n">grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>

<span class="gp">In [63]: </span><span class="n">grouped</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">)</span>
<span class="gh">Out[63]: </span><span class="go"></span>
<span class="go">            C         D</span>
<span class="go">A                      </span>
<span class="go">bar  0.392940  1.732707</span>
<span class="go">foo -1.796421  2.824590</span>

<span class="gp">In [64]: </span><span class="n">grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">])</span>

<span class="gp">In [65]: </span><span class="n">grouped</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">)</span>
<span class="gh">Out[65]: </span><span class="go"></span>
<span class="go">                  C         D</span>
<span class="go">A   B                        </span>
<span class="go">bar one    0.254161  1.511763</span>
<span class="go">    three  0.215897 -0.990582</span>
<span class="go">    two   -0.077118  1.211526</span>
<span class="go">foo one   -0.983776  1.614581</span>
<span class="go">    three -0.862495  0.024580</span>
<span class="go">    two    0.049851  1.185429</span>
</pre></div>
</div>
<p>As you can see, the result of the aggregation will have the group names as the
new index along the grouped axis. In the case of multiple keys, the result is a
<a class="reference internal" href="advanced.html#advanced-hierarchical"><span class="std std-ref">MultiIndex</span></a> by default, though this can be
changed by using the <code class="docutils literal notranslate"><span class="pre">as_index</span></code> option:</p>
<pre class="literal-block">In [66]: grouped = df.groupby(['A', 'B'], as_index=False)

In [67]: grouped.aggregate(np.sum)
Out[67]: 
     A      B         C         D
0  bar    one  0.254161  1.511763
1  bar  three  0.215897 -0.990582
2  bar    two -0.077118  1.211526
3  foo    one -0.983776  1.614581
4  foo  three -0.862495  0.024580
5  foo    two  0.049851  1.185429

In [68]: df.groupby('A', as_index=False).sum()
Out[68]: 
     A         C         D
0  bar  0.392940  1.732707
1  foo -1.796421  2.824590</pre>
<p>Note that you could use the <code class="docutils literal notranslate"><span class="pre">reset_index</span></code> DataFrame function to achieve the
same result as the column names are stored in the resulting <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [69]: </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
<span class="gh">Out[69]: </span><span class="go"></span>
<span class="go">     A      B         C         D</span>
<span class="go">0  bar    one  0.254161  1.511763</span>
<span class="go">1  bar  three  0.215897 -0.990582</span>
<span class="go">2  bar    two -0.077118  1.211526</span>
<span class="go">3  foo    one -0.983776  1.614581</span>
<span class="go">4  foo  three -0.862495  0.024580</span>
<span class="go">5  foo    two  0.049851  1.185429</span>
</pre></div>
</div>
<p>Another simple aggregation example is to compute the size of each group.
This is included in GroupBy as the <code class="docutils literal notranslate"><span class="pre">size</span></code> method. It returns a Series whose
index are the group names and whose values are the sizes of each group.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [70]: </span><span class="n">grouped</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="gh">Out[70]: </span><span class="go"></span>
<span class="go">A    B    </span>
<span class="go">bar  one      1</span>
<span class="go">     three    1</span>
<span class="go">     two      1</span>
<span class="go">foo  one      2</span>
<span class="go">     three    1</span>
<span class="go">     two      2</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [71]: </span><span class="n">grouped</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
<span class="gh">Out[71]: </span><span class="go"></span>
<span class="go">      C                                ...         D                              </span>
<span class="go">  count      mean       std       min  ...       25%       50%       75%       max</span>
<span class="go">0   1.0  0.254161       NaN  0.254161  ...  1.511763  1.511763  1.511763  1.511763</span>
<span class="go">1   1.0  0.215897       NaN  0.215897  ... -0.990582 -0.990582 -0.990582 -0.990582</span>
<span class="go">2   1.0 -0.077118       NaN -0.077118  ...  1.211526  1.211526  1.211526  1.211526</span>
<span class="go">3   2.0 -0.491888  0.117887 -0.575247  ...  0.537905  0.807291  1.076676  1.346061</span>
<span class="go">4   1.0 -0.862495       NaN -0.862495  ...  0.024580  0.024580  0.024580  0.024580</span>
<span class="go">5   2.0  0.024925  1.652692 -1.143704  ...  0.075531  0.592714  1.109898  1.627081</span>

<span class="go">[6 rows x 16 columns]</span>
</pre></div>
</div>
<div class="alert alert-info">
<p class="admonition-title">Note</p>
<p>Aggregation functions <strong>will not</strong> return the groups that you are aggregating over
if they are named <em>columns</em>, when <code class="docutils literal notranslate"><span class="pre">as_index=True</span></code>, the default. The grouped columns will
be the <strong>indices</strong> of the returned object.</p>
<p>Passing <code class="docutils literal notranslate"><span class="pre">as_index=False</span></code> <strong>will</strong> return the groups that you are aggregating over, if they are
named <em>columns</em>.</p>
</div>
<p>Aggregating functions are the ones that reduce the dimension of the returned objects.
Some common aggregating functions are tabulated below:</p>
<table class="colwidths-given table">
<colgroup>
<col style="width: 20%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">mean()</span></code></p></td>
<td><p>Compute mean of groups</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">sum()</span></code></p></td>
<td><p>Compute sum of group values</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">size()</span></code></p></td>
<td><p>Compute group sizes</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code></p></td>
<td><p>Compute count of group</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">std()</span></code></p></td>
<td><p>Standard deviation of groups</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">var()</span></code></p></td>
<td><p>Compute variance of groups</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">sem()</span></code></p></td>
<td><p>Standard error of the mean of groups</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">describe()</span></code></p></td>
<td><p>Generates descriptive statistics</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">first()</span></code></p></td>
<td><p>Compute first of group values</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">last()</span></code></p></td>
<td><p>Compute last of group values</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">nth()</span></code></p></td>
<td><p>Take nth value, or a subset if n is a list</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">min()</span></code></p></td>
<td><p>Compute min of group values</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">max()</span></code></p></td>
<td><p>Compute max of group values</p></td>
</tr>
</tbody>
</table>
<p>The aggregating functions above will exclude NA values. Any function which
reduces a <code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code> to a scalar value is an aggregation function and will work,
a trivial example is <code class="docutils literal notranslate"><span class="pre">df.groupby('A').agg(lambda</span> <span class="pre">ser:</span> <span class="pre">1)</span></code>. Note that
<code class="xref py py-meth docutils literal notranslate"><span class="pre">nth()</span></code> can act as a reducer <em>or</em> a
filter, see <a class="reference internal" href="#groupby-nth"><span class="std std-ref">here</span></a>.</p>
<div class="section" id="applying-multiple-functions-at-once">
<span id="groupby-aggregate-multifunc"></span><h3>Applying multiple functions at once<a class="headerlink" href="#applying-multiple-functions-at-once" title="Permalink to this headline">¶</a></h3>
<p>With grouped <code class="docutils literal notranslate"><span class="pre">Series</span></code> you can also pass a list or dict of functions to do
aggregation with, outputting a DataFrame:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [72]: </span><span class="n">grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>

<span class="gp">In [73]: </span><span class="n">grouped</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">])</span>
<span class="gh">Out[73]: </span><span class="go"></span>
<span class="go">          sum      mean       std</span>
<span class="go">A                                </span>
<span class="go">bar  0.392940  0.130980  0.181231</span>
<span class="go">foo -1.796421 -0.359284  0.912265</span>
</pre></div>
</div>
<p>On a grouped <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>, you can pass a list of functions to apply to each
column, which produces an aggregated result with a hierarchical index:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [74]: </span><span class="n">grouped</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">])</span>
<span class="gh">Out[74]: </span><span class="go"></span>
<span class="go">            C                             D                    </span>
<span class="go">          sum      mean       std       sum      mean       std</span>
<span class="go">A                                                              </span>
<span class="go">bar  0.392940  0.130980  0.181231  1.732707  0.577569  1.366330</span>
<span class="go">foo -1.796421 -0.359284  0.912265  2.824590  0.564918  0.884785</span>
</pre></div>
</div>
<p>The resulting aggregations are named for the functions themselves. If you
need to rename, then you can add in a chained operation for a <code class="docutils literal notranslate"><span class="pre">Series</span></code> like this:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [75]: </span><span class="p">(</span><span class="n">grouped</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">])</span>
<span class="gp">   ....: </span>             <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;sum&#39;</span><span class="p">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
<span class="gp">   ....: </span>                              <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span>
<span class="gp">   ....: </span>                              <span class="s1">&#39;std&#39;</span><span class="p">:</span> <span class="s1">&#39;baz&#39;</span><span class="p">}))</span>
<span class="gp">   ....: </span>
<span class="gh">Out[75]: </span><span class="go"></span>
<span class="go">          foo       bar       baz</span>
<span class="go">A                                </span>
<span class="go">bar  0.392940  0.130980  0.181231</span>
<span class="go">foo -1.796421 -0.359284  0.912265</span>
</pre></div>
</div>
<p>For a grouped <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>, you can rename in a similar manner:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [76]: </span><span class="p">(</span><span class="n">grouped</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">])</span>
<span class="gp">   ....: </span>        <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;sum&#39;</span><span class="p">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
<span class="gp">   ....: </span>                         <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span>
<span class="gp">   ....: </span>                         <span class="s1">&#39;std&#39;</span><span class="p">:</span> <span class="s1">&#39;baz&#39;</span><span class="p">}))</span>
<span class="gp">   ....: </span>
<span class="gh">Out[76]: </span><span class="go"></span>
<span class="go">            C                             D                    </span>
<span class="go">          foo       bar       baz       foo       bar       baz</span>
<span class="go">A                                                              </span>
<span class="go">bar  0.392940  0.130980  0.181231  1.732707  0.577569  1.366330</span>
<span class="go">foo -1.796421 -0.359284  0.912265  2.824590  0.564918  0.884785</span>
</pre></div>
</div>
</div>
<div class="section" id="applying-different-functions-to-dataframe-columns">
<h3>Applying different functions to DataFrame columns<a class="headerlink" href="#applying-different-functions-to-dataframe-columns" title="Permalink to this headline">¶</a></h3>
<p>By passing a dict to <code class="docutils literal notranslate"><span class="pre">aggregate</span></code> you can apply a different aggregation to the
columns of a DataFrame:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [77]: </span><span class="n">grouped</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span>
<span class="gp">   ....: </span>             <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)})</span>
<span class="gp">   ....: </span>
<span class="gh">Out[77]: </span><span class="go"></span>
<span class="go">            C         D</span>
<span class="go">A                      </span>
<span class="go">bar  0.392940  1.366330</span>
<span class="go">foo -1.796421  0.884785</span>
</pre></div>
</div>
<p>The function names can also be strings. In order for a string to be valid it
must be either implemented on GroupBy or available via <a class="reference internal" href="#groupby-dispatch"><span class="std std-ref">dispatching</span></a>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [78]: </span><span class="n">grouped</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="s1">&#39;std&#39;</span><span class="p">})</span>
<span class="gh">Out[78]: </span><span class="go"></span>
<span class="go">            C         D</span>
<span class="go">A                      </span>
<span class="go">bar  0.392940  1.366330</span>
<span class="go">foo -1.796421  0.884785</span>
</pre></div>
</div>
<div class="alert alert-info">
<p class="admonition-title">Note</p>
<p>If you pass a dict to <code class="docutils literal notranslate"><span class="pre">aggregate</span></code>, the ordering of the output columns is
non-deterministic. If you want to be sure the output columns will be in a specific
order, you can use an <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code>.  Compare the output of the following two commands:</p>
</div>
<pre class="literal-block">In [79]: from collections import OrderedDict

In [80]: grouped.agg({'D': 'std', 'C': 'mean'})
Out[80]: 
            D         C
A                      
bar  1.366330  0.130980
foo  0.884785 -0.359284

In [81]: grouped.agg(OrderedDict([('D', 'std'), ('C', 'mean')]))
Out[81]: 
            D         C
A                      
bar  1.366330  0.130980
foo  0.884785 -0.359284</pre>
</div>
<div class="section" id="cython-optimized-aggregation-functions">
<span id="groupby-aggregate-cython"></span><h3>Cython-optimized aggregation functions<a class="headerlink" href="#cython-optimized-aggregation-functions" title="Permalink to this headline">¶</a></h3>
<p>Some common aggregations, currently only <code class="docutils literal notranslate"><span class="pre">sum</span></code>, <code class="docutils literal notranslate"><span class="pre">mean</span></code>, <code class="docutils literal notranslate"><span class="pre">std</span></code>, and <code class="docutils literal notranslate"><span class="pre">sem</span></code>, have
optimized Cython implementations:</p>
<pre class="literal-block">In [82]: df.groupby('A').sum()
Out[82]: 
            C         D
A                      
bar  0.392940  1.732707
foo -1.796421  2.824590

In [83]: df.groupby(['A', 'B']).mean()
Out[83]: 
                  C         D
A   B                        
bar one    0.254161  1.511763
    three  0.215897 -0.990582
    two   -0.077118  1.211526
foo one   -0.491888  0.807291
    three -0.862495  0.024580
    two    0.024925  0.592714</pre>
<p>Of course <code class="docutils literal notranslate"><span class="pre">sum</span></code> and <code class="docutils literal notranslate"><span class="pre">mean</span></code> are implemented on pandas objects, so the above
code would work even without the special versions via dispatching (see below).</p>
</div>
</div>
<div class="section" id="transformation">
<span id="groupby-transform"></span><h2>Transformation<a class="headerlink" href="#transformation" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">transform</span></code> method returns an object that is indexed the same (same size)
as the one being grouped. The transform function must:</p>
<ul class="simple">
<li><p>Return a result that is either the same size as the group chunk or
broadcastable to the size of the group chunk (e.g., a scalar,
<code class="docutils literal notranslate"><span class="pre">grouped.transform(lambda</span> <span class="pre">x:</span> <span class="pre">x.iloc[-1])</span></code>).</p></li>
<li><p>Operate column-by-column on the group chunk.  The transform is applied to
the first group chunk using chunk.apply.</p></li>
<li><p>Not perform in-place operations on the group chunk. Group chunks should
be treated as immutable, and changes to a group chunk may produce unexpected
results. For example, when using <code class="docutils literal notranslate"><span class="pre">fillna</span></code>, <code class="docutils literal notranslate"><span class="pre">inplace</span></code> must be <code class="docutils literal notranslate"><span class="pre">False</span></code>
(<code class="docutils literal notranslate"><span class="pre">grouped.transform(lambda</span> <span class="pre">x:</span> <span class="pre">x.fillna(inplace=False))</span></code>).</p></li>
<li><p>(Optionally) operates on the entire group chunk. If this is supported, a
fast path is used starting from the <em>second</em> chunk.</p></li>
</ul>
<p>For example, suppose we wished to standardize the data within each group:</p>
<pre class="literal-block">In [84]: index = pd.date_range('10/1/1999', periods=1100)

In [85]: ts = pd.Series(np.random.normal(0.5, 2, 1100), index)

In [86]: ts = ts.rolling(window=100, min_periods=100).mean().dropna()

In [87]: ts.head()
Out[87]: 
2000-01-08    0.779333
2000-01-09    0.778852
2000-01-10    0.786476
2000-01-11    0.782797
2000-01-12    0.798110
Freq: D, dtype: float64

In [88]: ts.tail()
Out[88]: 
2002-09-30    0.660294
2002-10-01    0.631095
2002-10-02    0.673601
2002-10-03    0.709213
2002-10-04    0.719369
Freq: D, dtype: float64

In [89]: transformed = (ts.groupby(lambda x: x.year)
   ....:                  .transform(lambda x: (x - x.mean()) / x.std()))
   ....: </pre>
<p>We would expect the result to now have mean 0 and standard deviation 1 within
each group, which we can easily check:</p>
<pre class="literal-block"># Original Data
In [90]: grouped = ts.groupby(lambda x: x.year)

In [91]: grouped.mean()
Out[91]: 
2000    0.442441
2001    0.526246
2002    0.459365
dtype: float64

In [92]: grouped.std()
Out[92]: 
2000    0.131752
2001    0.210945
2002    0.128753
dtype: float64

# Transformed Data
In [93]: grouped_trans = transformed.groupby(lambda x: x.year)

In [94]: grouped_trans.mean()
Out[94]: 
2000   -2.460118e-16
2001    2.609785e-16
2002    2.853714e-16
dtype: float64

In [95]: grouped_trans.std()
Out[95]: 
2000    1.0
2001    1.0
2002    1.0
dtype: float64</pre>
<p>We can also visually compare the original and transformed data sets.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [96]: </span><span class="n">compare</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;Original&#39;</span><span class="p">:</span> <span class="n">ts</span><span class="p">,</span> <span class="s1">&#39;Transformed&#39;</span><span class="p">:</span> <span class="n">transformed</span><span class="p">})</span>

<span class="gp">In [97]: </span><span class="n">compare</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="gh">Out[97]: </span><span class="go">&lt;matplotlib.axes._subplots.AxesSubplot at 0x7fd41c1a2250&gt;</span>
</pre></div>
</div>
<img alt="../_images/groupby_transform_plot.png" src="../_images/groupby_transform_plot.png" />
<p>Transformation functions that have lower dimension outputs are broadcast to
match the shape of the input array.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [98]: </span><span class="n">ts</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">year</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
<span class="gh">Out[98]: </span><span class="go"></span>
<span class="go">2000-01-08    0.623893</span>
<span class="go">2000-01-09    0.623893</span>
<span class="go">2000-01-10    0.623893</span>
<span class="go">2000-01-11    0.623893</span>
<span class="go">2000-01-12    0.623893</span>
<span class="go">                ...   </span>
<span class="go">2002-09-30    0.558275</span>
<span class="go">2002-10-01    0.558275</span>
<span class="go">2002-10-02    0.558275</span>
<span class="go">2002-10-03    0.558275</span>
<span class="go">2002-10-04    0.558275</span>
<span class="go">Freq: D, Length: 1001, dtype: float64</span>
</pre></div>
</div>
<p>Alternatively, the built-in methods could be used to produce the same outputs.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [99]: </span><span class="nb">max</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">year</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="s1">&#39;max&#39;</span><span class="p">)</span>

<span class="gp">In [100]: </span><span class="nb">min</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">year</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="s1">&#39;min&#39;</span><span class="p">)</span>

<span class="gp">In [101]: </span><span class="nb">max</span> <span class="o">-</span> <span class="nb">min</span>
<span class="gh">Out[101]: </span><span class="go"></span>
<span class="go">2000-01-08    0.623893</span>
<span class="go">2000-01-09    0.623893</span>
<span class="go">2000-01-10    0.623893</span>
<span class="go">2000-01-11    0.623893</span>
<span class="go">2000-01-12    0.623893</span>
<span class="go">                ...   </span>
<span class="go">2002-09-30    0.558275</span>
<span class="go">2002-10-01    0.558275</span>
<span class="go">2002-10-02    0.558275</span>
<span class="go">2002-10-03    0.558275</span>
<span class="go">2002-10-04    0.558275</span>
<span class="go">Freq: D, Length: 1001, dtype: float64</span>
</pre></div>
</div>
<p>Another common data transform is to replace missing data with the group mean.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [102]: </span><span class="n">data_df</span>
<span class="gh">Out[102]: </span><span class="go"></span>
<span class="go">            A         B         C</span>
<span class="go">0    1.539708 -1.166480  0.533026</span>
<span class="go">1    1.302092 -0.505754       NaN</span>
<span class="go">2   -0.371983  1.104803 -0.651520</span>
<span class="go">3   -1.309622  1.118697 -1.161657</span>
<span class="go">4   -1.924296  0.396437  0.812436</span>
<span class="go">..        ...       ...       ...</span>
<span class="go">995 -0.093110  0.683847 -0.774753</span>
<span class="go">996 -0.185043  1.438572       NaN</span>
<span class="go">997 -0.394469 -0.642343  0.011374</span>
<span class="go">998 -1.174126  1.857148       NaN</span>
<span class="go">999  0.234564  0.517098  0.393534</span>

<span class="go">[1000 rows x 3 columns]</span>

<span class="gp">In [103]: </span><span class="n">countries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;US&#39;</span><span class="p">,</span> <span class="s1">&#39;UK&#39;</span><span class="p">,</span> <span class="s1">&#39;GR&#39;</span><span class="p">,</span> <span class="s1">&#39;JP&#39;</span><span class="p">])</span>

<span class="gp">In [104]: </span><span class="n">key</span> <span class="o">=</span> <span class="n">countries</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)]</span>

<span class="gp">In [105]: </span><span class="n">grouped</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

<span class="go"># Non-NA count in each group</span>
<span class="gp">In [106]: </span><span class="n">grouped</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class="gh">Out[106]: </span><span class="go"></span>
<span class="go">      A    B    C</span>
<span class="go">GR  209  217  189</span>
<span class="go">JP  240  255  217</span>
<span class="go">UK  216  231  193</span>
<span class="go">US  239  250  217</span>

<span class="gp">In [107]: </span><span class="n">transformed</span> <span class="o">=</span> <span class="n">grouped</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span>
</pre></div>
</div>
<p>We can verify that the group means have not changed in the transformed data
and that the transformed data contains no NAs.</p>
<pre class="literal-block">In [108]: grouped_trans = transformed.groupby(key)

In [109]: grouped.mean()  # original group means
Out[109]: 
           A         B         C
GR -0.098371 -0.015420  0.068053
JP  0.069025  0.023100 -0.077324
UK  0.034069 -0.052580 -0.116525
US  0.058664 -0.020399  0.028603

In [110]: grouped_trans.mean()  # transformation did not change group means
Out[110]: 
           A         B         C
GR -0.098371 -0.015420  0.068053
JP  0.069025  0.023100 -0.077324
UK  0.034069 -0.052580 -0.116525
US  0.058664 -0.020399  0.028603

In [111]: grouped.count()  # original has some missing data points
Out[111]: 
      A    B    C
GR  209  217  189
JP  240  255  217
UK  216  231  193
US  239  250  217

In [112]: grouped_trans.count()  # counts after transformation
Out[112]: 
      A    B    C
GR  228  228  228
JP  267  267  267
UK  247  247  247
US  258  258  258

In [113]: grouped_trans.size()  # Verify non-NA count equals group size
Out[113]: 
GR    228
JP    267
UK    247
US    258
dtype: int64</pre>
<div class="alert alert-info">
<p class="admonition-title">Note</p>
<p>Some functions will automatically transform the input when applied to a
GroupBy object, but returning an object of the same shape as the original.
Passing <code class="docutils literal notranslate"><span class="pre">as_index=False</span></code> will not affect these transformation methods.</p>
<p>For example: <code class="docutils literal notranslate"><span class="pre">fillna,</span> <span class="pre">ffill,</span> <span class="pre">bfill,</span> <span class="pre">shift.</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [114]: </span><span class="n">grouped</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span>
<span class="gh">Out[114]: </span><span class="go"></span>
<span class="go">            A         B         C</span>
<span class="go">0    1.539708 -1.166480  0.533026</span>
<span class="go">1    1.302092 -0.505754  0.533026</span>
<span class="go">2   -0.371983  1.104803 -0.651520</span>
<span class="go">3   -1.309622  1.118697 -1.161657</span>
<span class="go">4   -1.924296  0.396437  0.812436</span>
<span class="go">..        ...       ...       ...</span>
<span class="go">995 -0.093110  0.683847 -0.774753</span>
<span class="go">996 -0.185043  1.438572 -0.774753</span>
<span class="go">997 -0.394469 -0.642343  0.011374</span>
<span class="go">998 -1.174126  1.857148 -0.774753</span>
<span class="go">999  0.234564  0.517098  0.393534</span>

<span class="go">[1000 rows x 3 columns]</span>
</pre></div>
</div>
</div>
<div class="section" id="new-syntax-to-window-and-resample-operations">
<span id="groupby-transform-window-resample"></span><h3>New syntax to window and resample operations<a class="headerlink" href="#new-syntax-to-window-and-resample-operations" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.1.</span></p>
</div>
<p>Working with the resample, expanding or rolling operations on the groupby
level used to require the application of helper functions. However,
now it is possible to use <code class="docutils literal notranslate"><span class="pre">resample()</span></code>, <code class="docutils literal notranslate"><span class="pre">expanding()</span></code> and
<code class="docutils literal notranslate"><span class="pre">rolling()</span></code> as methods on groupbys.</p>
<p>The example below will apply the <code class="docutils literal notranslate"><span class="pre">rolling()</span></code> method on the samples of
the column B based on the groups of column A.</p>
<pre class="literal-block">In [115]: df_re = pd.DataFrame({'A': [1] * 10 + [5] * 10,
   .....:                       'B': np.arange(20)})
   .....: 

In [116]: df_re
Out[116]: 
    A   B
0   1   0
1   1   1
2   1   2
3   1   3
4   1   4
.. ..  ..
15  5  15
16  5  16
17  5  17
18  5  18
19  5  19

[20 rows x 2 columns]

In [117]: df_re.groupby('A').rolling(4).B.mean()
Out[117]: 
A    
1  0      NaN
   1      NaN
   2      NaN
   3      1.5
   4      2.5
         ... 
5  15    13.5
   16    14.5
   17    15.5
   18    16.5
   19    17.5
Name: B, Length: 20, dtype: float64</pre>
<p>The <code class="docutils literal notranslate"><span class="pre">expanding()</span></code> method will accumulate a given operation
(<code class="docutils literal notranslate"><span class="pre">sum()</span></code> in the example) for all the members of each particular
group.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [118]: </span><span class="n">df_re</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">expanding</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gh">Out[118]: </span><span class="go"></span>
<span class="go">         A      B</span>
<span class="go">A                </span>
<span class="go">1 0    1.0    0.0</span>
<span class="go">  1    2.0    1.0</span>
<span class="go">  2    3.0    3.0</span>
<span class="go">  3    4.0    6.0</span>
<span class="go">  4    5.0   10.0</span>
<span class="go">...    ...    ...</span>
<span class="go">5 15  30.0   75.0</span>
<span class="go">  16  35.0   91.0</span>
<span class="go">  17  40.0  108.0</span>
<span class="go">  18  45.0  126.0</span>
<span class="go">  19  50.0  145.0</span>

<span class="go">[20 rows x 2 columns]</span>
</pre></div>
</div>
<p>Suppose you want to use the <code class="docutils literal notranslate"><span class="pre">resample()</span></code> method to get a daily
frequency in each group of your dataframe and wish to complete the
missing values with the <code class="docutils literal notranslate"><span class="pre">ffill()</span></code> method.</p>
<pre class="literal-block">In [119]: df_re = pd.DataFrame({'date': pd.date_range(start='2016-01-01', periods=4,
   .....:                                             freq='W'),
   .....:                       'group': [1, 1, 2, 2],
   .....:                       'val': [5, 6, 7, 8]}).set_index('date')
   .....: 

In [120]: df_re
Out[120]: 
            group  val
date                  
2016-01-03      1    5
2016-01-10      1    6
2016-01-17      2    7
2016-01-24      2    8

In [121]: df_re.groupby('group').resample('1D').ffill()
Out[121]: 
                  group  val
group date                  
1     2016-01-03      1    5
      2016-01-04      1    5
      2016-01-05      1    5
      2016-01-06      1    5
      2016-01-07      1    5
...                 ...  ...
2     2016-01-20      2    7
      2016-01-21      2    7
      2016-01-22      2    7
      2016-01-23      2    7
      2016-01-24      2    8

[16 rows x 2 columns]</pre>
</div>
</div>
<div class="section" id="filtration">
<span id="groupby-filter"></span><h2>Filtration<a class="headerlink" href="#filtration" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">filter</span></code> method returns a subset of the original object. Suppose we
want to take only elements that belong to groups with a group sum greater
than 2.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [122]: </span><span class="n">sf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

<span class="gp">In [123]: </span><span class="n">sf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">sf</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="gh">Out[123]: </span><span class="go"></span>
<span class="go">3    3</span>
<span class="go">4    3</span>
<span class="go">5    3</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>The argument of <code class="docutils literal notranslate"><span class="pre">filter</span></code> must be a function that, applied to the group as a
whole, returns <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>Another useful operation is filtering out elements that belong to groups
with only a couple members.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [124]: </span><span class="n">dff</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="s1">&#39;aabbbbcc&#39;</span><span class="p">)})</span>

<span class="gp">In [125]: </span><span class="n">dff</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="gh">Out[125]: </span><span class="go"></span>
<span class="go">   A  B</span>
<span class="go">2  2  b</span>
<span class="go">3  3  b</span>
<span class="go">4  4  b</span>
<span class="go">5  5  b</span>
</pre></div>
</div>
<p>Alternatively, instead of dropping the offending groups, we can return a
like-indexed objects where the groups that do not pass the filter are filled
with NaNs.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [126]: </span><span class="n">dff</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gh">Out[126]: </span><span class="go"></span>
<span class="go">     A    B</span>
<span class="go">0  NaN  NaN</span>
<span class="go">1  NaN  NaN</span>
<span class="go">2  2.0    b</span>
<span class="go">3  3.0    b</span>
<span class="go">4  4.0    b</span>
<span class="go">5  5.0    b</span>
<span class="go">6  NaN  NaN</span>
<span class="go">7  NaN  NaN</span>
</pre></div>
</div>
<p>For DataFrames with multiple columns, filters should explicitly specify a column as the filter criterion.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [127]: </span><span class="n">dff</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>

<span class="gp">In [128]: </span><span class="n">dff</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="gh">Out[128]: </span><span class="go"></span>
<span class="go">   A  B  C</span>
<span class="go">2  2  b  2</span>
<span class="go">3  3  b  3</span>
<span class="go">4  4  b  4</span>
<span class="go">5  5  b  5</span>
</pre></div>
</div>
<div class="alert alert-info">
<p class="admonition-title">Note</p>
<p>Some functions when applied to a groupby object will act as a <strong>filter</strong> on the input, returning
a reduced shape of the original (and potentially eliminating groups), but with the index unchanged.
Passing <code class="docutils literal notranslate"><span class="pre">as_index=False</span></code> will not affect these transformation methods.</p>
<p>For example: <code class="docutils literal notranslate"><span class="pre">head,</span> <span class="pre">tail</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [129]: </span><span class="n">dff</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gh">Out[129]: </span><span class="go"></span>
<span class="go">   A  B  C</span>
<span class="go">0  0  a  0</span>
<span class="go">1  1  a  1</span>
<span class="go">2  2  b  2</span>
<span class="go">3  3  b  3</span>
<span class="go">6  6  c  6</span>
<span class="go">7  7  c  7</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="dispatching-to-instance-methods">
<span id="groupby-dispatch"></span><h2>Dispatching to instance methods<a class="headerlink" href="#dispatching-to-instance-methods" title="Permalink to this headline">¶</a></h2>
<p>When doing an aggregation or transformation, you might just want to call an
instance method on each data group. This is pretty easy to do by passing lambda
functions:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [130]: </span><span class="n">grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>

<span class="gp">In [131]: </span><span class="n">grouped</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">std</span><span class="p">())</span>
<span class="gh">Out[131]: </span><span class="go"></span>
<span class="go">            C         D</span>
<span class="go">A                      </span>
<span class="go">bar  0.181231  1.366330</span>
<span class="go">foo  0.912265  0.884785</span>
</pre></div>
</div>
<p>But, it’s rather verbose and can be untidy if you need to pass additional
arguments. Using a bit of metaprogramming cleverness, GroupBy now has the
ability to “dispatch” method calls to the groups:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [132]: </span><span class="n">grouped</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
<span class="gh">Out[132]: </span><span class="go"></span>
<span class="go">            C         D</span>
<span class="go">A                      </span>
<span class="go">bar  0.181231  1.366330</span>
<span class="go">foo  0.912265  0.884785</span>
</pre></div>
</div>
<p>What is actually happening here is that a function wrapper is being
generated. When invoked, it takes any passed arguments and invokes the function
with any arguments on each group (in the above example, the <code class="docutils literal notranslate"><span class="pre">std</span></code>
function). The results are then combined together much in the style of <code class="docutils literal notranslate"><span class="pre">agg</span></code>
and <code class="docutils literal notranslate"><span class="pre">transform</span></code> (it actually uses <code class="docutils literal notranslate"><span class="pre">apply</span></code> to infer the gluing, documented
next). This enables some operations to be carried out rather succinctly:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [133]: </span><span class="n">tsdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
<span class="gp">   .....: </span>                    <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;1/1/2000&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1000</span><span class="p">),</span>
<span class="gp">   .....: </span>                    <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>
<span class="gp">   .....: </span>

<span class="gp">In [134]: </span><span class="n">tsdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

<span class="gp">In [135]: </span><span class="n">grouped</span> <span class="o">=</span> <span class="n">tsdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">year</span><span class="p">)</span>

<span class="gp">In [136]: </span><span class="n">grouped</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">)</span>
<span class="gh">Out[136]: </span><span class="go"></span>
<span class="go">                   A         B         C</span>
<span class="go">2000-01-01       NaN       NaN       NaN</span>
<span class="go">2000-01-02 -0.353501 -0.080957 -0.876864</span>
<span class="go">2000-01-03 -0.353501 -0.080957 -0.876864</span>
<span class="go">2000-01-04  0.050976  0.044273 -0.559849</span>
<span class="go">2000-01-05  0.050976  0.044273 -0.559849</span>
<span class="go">...              ...       ...       ...</span>
<span class="go">2002-09-22  0.005011  0.053897 -1.026922</span>
<span class="go">2002-09-23  0.005011  0.053897 -1.026922</span>
<span class="go">2002-09-24 -0.456542 -1.849051  1.559856</span>
<span class="go">2002-09-25 -0.456542 -1.849051  1.559856</span>
<span class="go">2002-09-26  1.123162  0.354660  1.128135</span>

<span class="go">[1000 rows x 3 columns]</span>
</pre></div>
</div>
<p>In this example, we chopped the collection of time series into yearly chunks
then independently called <a class="reference internal" href="missing_data.html#missing-data-fillna"><span class="std std-ref">fillna</span></a> on the
groups.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">nlargest</span></code> and <code class="docutils literal notranslate"><span class="pre">nsmallest</span></code> methods work on <code class="docutils literal notranslate"><span class="pre">Series</span></code> style groupbys:</p>
<pre class="literal-block">In [137]: s = pd.Series([9, 8, 7, 5, 19, 1, 4.2, 3.3])

In [138]: g = pd.Series(list('abababab'))

In [139]: gb = s.groupby(g)

In [140]: gb.nlargest(3)
Out[140]: 
a  4    19.0
   0     9.0
   2     7.0
b  1     8.0
   3     5.0
   7     3.3
dtype: float64

In [141]: gb.nsmallest(3)
Out[141]: 
a  6    4.2
   2    7.0
   0    9.0
b  5    1.0
   7    3.3
   3    5.0
dtype: float64</pre>
</div>
<div class="section" id="flexible-apply">
<span id="groupby-apply"></span><h2>Flexible <code class="docutils literal notranslate"><span class="pre">apply</span></code><a class="headerlink" href="#flexible-apply" title="Permalink to this headline">¶</a></h2>
<p>Some operations on the grouped data might not fit into either the aggregate or
transform categories. Or, you may simply want GroupBy to infer how to combine
the results. For these, use the <code class="docutils literal notranslate"><span class="pre">apply</span></code> function, which can be substituted
for both <code class="docutils literal notranslate"><span class="pre">aggregate</span></code> and <code class="docutils literal notranslate"><span class="pre">transform</span></code> in many standard use cases. However,
<code class="docutils literal notranslate"><span class="pre">apply</span></code> can handle some exceptional use cases, for example:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [142]: </span><span class="n">df</span>
<span class="gh">Out[142]: </span><span class="go"></span>
<span class="go">     A      B         C         D</span>
<span class="go">0  foo    one -0.575247  1.346061</span>
<span class="go">1  bar    one  0.254161  1.511763</span>
<span class="go">2  foo    two -1.143704  1.627081</span>
<span class="go">3  bar  three  0.215897 -0.990582</span>
<span class="go">4  foo    two  1.193555 -0.441652</span>
<span class="go">5  bar    two -0.077118  1.211526</span>
<span class="go">6  foo    one -0.408530  0.268520</span>
<span class="go">7  foo  three -0.862495  0.024580</span>

<span class="gp">In [143]: </span><span class="n">grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>

<span class="go"># could also just call .describe()</span>
<span class="gp">In [144]: </span><span class="n">grouped</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">describe</span><span class="p">())</span>
<span class="gh">Out[144]: </span><span class="go"></span>
<span class="go">A         </span>
<span class="go">bar  count    3.000000</span>
<span class="go">     mean     0.130980</span>
<span class="go">     std      0.181231</span>
<span class="go">     min     -0.077118</span>
<span class="go">     25%      0.069390</span>
<span class="go">                ...   </span>
<span class="go">foo  min     -1.143704</span>
<span class="go">     25%     -0.862495</span>
<span class="go">     50%     -0.575247</span>
<span class="go">     75%     -0.408530</span>
<span class="go">     max      1.193555</span>
<span class="go">Name: C, Length: 16, dtype: float64</span>
</pre></div>
</div>
<p>The dimension of the returned result can also change:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [145]: </span><span class="n">grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)[</span><span class="s1">&#39;C&#39;</span><span class="p">]</span>

<span class="gp">In [146]: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
<span class="gp">   .....: </span>    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;original&#39;</span><span class="p">:</span> <span class="n">group</span><span class="p">,</span>
<span class="gp">   .....: </span>                         <span class="s1">&#39;demeaned&#39;</span><span class="p">:</span> <span class="n">group</span> <span class="o">-</span> <span class="n">group</span><span class="o">.</span><span class="n">mean</span><span class="p">()})</span>
<span class="gp">   .....: </span>

<span class="gp">In [147]: </span><span class="n">grouped</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gh">Out[147]: </span><span class="go"></span>
<span class="go">   original  demeaned</span>
<span class="go">0 -0.575247 -0.215962</span>
<span class="go">1  0.254161  0.123181</span>
<span class="go">2 -1.143704 -0.784420</span>
<span class="go">3  0.215897  0.084917</span>
<span class="go">4  1.193555  1.552839</span>
<span class="go">5 -0.077118 -0.208098</span>
<span class="go">6 -0.408530 -0.049245</span>
<span class="go">7 -0.862495 -0.503211</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">apply</span></code> on a Series can operate on a returned value from the applied function,
that is itself a series, and possibly upcast the result to a DataFrame:</p>
<pre class="literal-block">In [148]: def f(x):
   .....:     return pd.Series([x, x ** 2], index=['x', 'x^2'])
   .....: 

In [149]: s = pd.Series(np.random.rand(5))

In [150]: s
Out[150]: 
0    0.321438
1    0.493496
2    0.139505
3    0.910103
4    0.194158
dtype: float64

In [151]: s.apply(f)
Out[151]: 
          x       x^2
0  0.321438  0.103323
1  0.493496  0.243538
2  0.139505  0.019462
3  0.910103  0.828287
4  0.194158  0.037697</pre>
<div class="alert alert-info">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">apply</span></code> can act as a reducer, transformer, <em>or</em> filter function, depending on exactly what is passed to it.
So depending on the path taken, and exactly what you are grouping. Thus the grouped columns(s) may be included in
the output as well as set the indices.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>In the current implementation apply calls func twice on the
first group to decide whether it can take a fast or slow code
path. This can lead to unexpected behavior if func has
side-effects, as they will take effect twice for the first
group.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [152]: </span><span class="n">d</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>

<span class="gp">In [153]: </span><span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="gp">   .....: </span>    <span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="gp">   .....: </span>    <span class="k">return</span> <span class="n">df</span>
<span class="gp">   .....: </span>

<span class="gp">In [154]: </span><span class="n">d</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">identity</span><span class="p">)</span>
<span class="go">   a  b</span>
<span class="go">0  x  1</span>
<span class="go">   a  b</span>
<span class="go">1  y  2</span>
<span class="gh">Out[154]: </span><span class="go"></span>
<span class="go">   a  b</span>
<span class="go">0  x  1</span>
<span class="go">1  y  2</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="other-useful-features">
<h2>Other useful features<a class="headerlink" href="#other-useful-features" title="Permalink to this headline">¶</a></h2>
<div class="section" id="automatic-exclusion-of-nuisance-columns">
<h3>Automatic exclusion of “nuisance” columns<a class="headerlink" href="#automatic-exclusion-of-nuisance-columns" title="Permalink to this headline">¶</a></h3>
<p>Again consider the example DataFrame we’ve been looking at:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [155]: </span><span class="n">df</span>
<span class="gh">Out[155]: </span><span class="go"></span>
<span class="go">     A      B         C         D</span>
<span class="go">0  foo    one -0.575247  1.346061</span>
<span class="go">1  bar    one  0.254161  1.511763</span>
<span class="go">2  foo    two -1.143704  1.627081</span>
<span class="go">3  bar  three  0.215897 -0.990582</span>
<span class="go">4  foo    two  1.193555 -0.441652</span>
<span class="go">5  bar    two -0.077118  1.211526</span>
<span class="go">6  foo    one -0.408530  0.268520</span>
<span class="go">7  foo  three -0.862495  0.024580</span>
</pre></div>
</div>
<p>Suppose we wish to compute the standard deviation grouped by the <code class="docutils literal notranslate"><span class="pre">A</span></code>
column. There is a slight problem, namely that we don’t care about the data in
column <code class="docutils literal notranslate"><span class="pre">B</span></code>. We refer to this as a “nuisance” column. If the passed
aggregation function can’t be applied to some columns, the troublesome columns
will be (silently) dropped. Thus, this does not pose any problems:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [156]: </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
<span class="gh">Out[156]: </span><span class="go"></span>
<span class="go">            C         D</span>
<span class="go">A                      </span>
<span class="go">bar  0.181231  1.366330</span>
<span class="go">foo  0.912265  0.884785</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">df.groupby('A').colname.std().</span></code> is more efficient than
<code class="docutils literal notranslate"><span class="pre">df.groupby('A').std().colname</span></code>, so if the result of an aggregation function
is only interesting over one column (here <code class="docutils literal notranslate"><span class="pre">colname</span></code>), it may be filtered
<em>before</em> applying the aggregation function.</p>
<div class="alert alert-info">
<p class="admonition-title">Note</p>
<p>Any object column, also if it contains numerical values such as <code class="docutils literal notranslate"><span class="pre">Decimal</span></code>
objects, is considered as a “nuisance” columns. They are excluded from
aggregate functions automatically in groupby.</p>
<p>If you do wish to include decimal or object columns in an aggregation with
other non-nuisance data types, you must do so explicitly.</p>
</div>
<pre class="literal-block">In [157]: from decimal import Decimal

In [158]: df_dec = pd.DataFrame(
   .....:     {'id': [1, 2, 1, 2],
   .....:      'int_column': [1, 2, 3, 4],
   .....:      'dec_column': [Decimal('0.50'), Decimal('0.15'),
   .....:                     Decimal('0.25'), Decimal('0.40')]
   .....:      }
   .....: )
   .....: 

# Decimal columns can be sum'd explicitly by themselves...
In [159]: df_dec.groupby(['id'])[['dec_column']].sum()
Out[159]: 
   dec_column
id           
1        0.75
2        0.55

# ...but cannot be combined with standard data types or they will be excluded
In [160]: df_dec.groupby(['id'])[['int_column', 'dec_column']].sum()
Out[160]: 
    int_column
id            
1            4
2            6

# Use .agg function to aggregate over standard and &quot;nuisance&quot; data types
# at the same time
In [161]: df_dec.groupby(['id']).agg({'int_column': 'sum', 'dec_column': 'sum'})
Out[161]: 
    int_column dec_column
id                       
1            4       0.75
2            6       0.55</pre>
</div>
<div class="section" id="handling-of-un-observed-categorical-values">
<span id="groupby-observed"></span><h3>Handling of (un)observed Categorical values<a class="headerlink" href="#handling-of-un-observed-categorical-values" title="Permalink to this headline">¶</a></h3>
<p>When using a <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> grouper (as a single grouper, or as part of multiple groupers), the <code class="docutils literal notranslate"><span class="pre">observed</span></code> keyword
controls whether to return a cartesian product of all possible groupers values (<code class="docutils literal notranslate"><span class="pre">observed=False</span></code>) or only those
that are observed groupers (<code class="docutils literal notranslate"><span class="pre">observed=True</span></code>).</p>
<p>Show all values:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [162]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">],</span>
<span class="gp">   .....: </span>                                            <span class="n">categories</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]),</span>
<span class="gp">   .....: </span>                             <span class="n">observed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class="gp">   .....: </span>
<span class="gh">Out[162]: </span><span class="go"></span>
<span class="go">a    3</span>
<span class="go">b    0</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Show only the observed values:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [163]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">],</span>
<span class="gp">   .....: </span>                                            <span class="n">categories</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]),</span>
<span class="gp">   .....: </span>                             <span class="n">observed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class="gp">   .....: </span>
<span class="gh">Out[163]: </span><span class="go"></span>
<span class="go">a    3</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>The returned dtype of the grouped will <em>always</em> include <em>all</em> of the categories that were grouped.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [164]: </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">],</span>
<span class="gp">   .....: </span>                                                <span class="n">categories</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]),</span>
<span class="gp">   .....: </span>                                 <span class="n">observed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class="gp">   .....: </span>

<span class="gp">In [165]: </span><span class="n">s</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dtype</span>
<span class="gh">Out[165]: </span><span class="go">CategoricalDtype(categories=[&#39;a&#39;, &#39;b&#39;], ordered=False)</span>
</pre></div>
</div>
</div>
<div class="section" id="na-and-nat-group-handling">
<span id="groupby-missing"></span><h3>NA and NaT group handling<a class="headerlink" href="#na-and-nat-group-handling" title="Permalink to this headline">¶</a></h3>
<p>If there are any NaN or NaT values in the grouping key, these will be
automatically excluded. In other words, there will never be an “NA group” or
“NaT group”. This was not the case in older versions of pandas, but users were
generally discarding the NA group anyway (and supporting it was an
implementation headache).</p>
</div>
<div class="section" id="grouping-with-ordered-factors">
<h3>Grouping with ordered factors<a class="headerlink" href="#grouping-with-ordered-factors" title="Permalink to this headline">¶</a></h3>
<p>Categorical variables represented as instance of pandas’s <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> class
can be used as group keys. If so, the order of the levels will be preserved:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [166]: </span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>

<span class="gp">In [167]: </span><span class="n">factor</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">qcut</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">.</span><span class="mi">25</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">.</span><span class="mi">75</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>

<span class="gp">In [168]: </span><span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="gh">Out[168]: </span><span class="go"></span>
<span class="go">(-2.645, -0.523]   -1.362896</span>
<span class="go">(-0.523, 0.0296]   -0.260266</span>
<span class="go">(0.0296, 0.654]     0.361802</span>
<span class="go">(0.654, 2.21]       1.073801</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</div>
<div class="section" id="grouping-with-a-grouper-specification">
<span id="groupby-specify"></span><h3>Grouping with a Grouper specification<a class="headerlink" href="#grouping-with-a-grouper-specification" title="Permalink to this headline">¶</a></h3>
<p>You may need to specify a bit more data to properly group. You can
use the <code class="docutils literal notranslate"><span class="pre">pd.Grouper</span></code> to provide this local control.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [169]: </span><span class="kn">import</span> <span class="nn">datetime</span>

<span class="gp">In [170]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;Branch&#39;</span><span class="p">:</span> <span class="s1">&#39;A A A A A A A B&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span>
<span class="gp">   .....: </span>                   <span class="s1">&#39;Buyer&#39;</span><span class="p">:</span> <span class="s1">&#39;Carl Mark Carl Carl Joe Joe Joe Carl&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span>
<span class="gp">   .....: </span>                   <span class="s1">&#39;Quantity&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">   .....: </span>                   <span class="s1">&#39;Date&#39;</span><span class="p">:</span> <span class="p">[</span>
<span class="gp">   .....: </span>                       <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">   .....: </span>                       <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
<span class="gp">   .....: </span>                       <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">   .....: </span>                       <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">   .....: </span>                       <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">   .....: </span>                       <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">   .....: </span>                       <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="gp">   .....: </span>                       <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
<span class="gp">   .....: </span>                   <span class="p">})</span>
<span class="gp">   .....: </span>

<span class="gp">In [171]: </span><span class="n">df</span>
<span class="gh">Out[171]: </span><span class="go"></span>
<span class="go">  Branch Buyer  Quantity                Date</span>
<span class="go">0      A  Carl         1 2013-01-01 13:00:00</span>
<span class="go">1      A  Mark         3 2013-01-01 13:05:00</span>
<span class="go">2      A  Carl         5 2013-10-01 20:00:00</span>
<span class="go">3      A  Carl         1 2013-10-02 10:00:00</span>
<span class="go">4      A   Joe         8 2013-10-01 20:00:00</span>
<span class="go">5      A   Joe         1 2013-10-02 10:00:00</span>
<span class="go">6      A   Joe         9 2013-12-02 12:00:00</span>
<span class="go">7      B  Carl         3 2013-12-02 14:00:00</span>
</pre></div>
</div>
<p>Groupby a specific column with the desired frequency. This is like resampling.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [172]: </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">Grouper</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="s1">&#39;1M&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;Date&#39;</span><span class="p">),</span> <span class="s1">&#39;Buyer&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gh">Out[172]: </span><span class="go"></span>
<span class="go">                  Quantity</span>
<span class="go">Date       Buyer          </span>
<span class="go">2013-01-31 Carl          1</span>
<span class="go">           Mark          3</span>
<span class="go">2013-10-31 Carl          6</span>
<span class="go">           Joe           9</span>
<span class="go">2013-12-31 Carl          3</span>
<span class="go">           Joe           9</span>
</pre></div>
</div>
<p>You have an ambiguous specification in that you have a named index and a column
that could be potential groupers.</p>
<pre class="literal-block">In [173]: df = df.set_index('Date')

In [174]: df['Date'] = df.index + pd.offsets.MonthEnd(2)

In [175]: df.groupby([pd.Grouper(freq='6M', key='Date'), 'Buyer']).sum()
Out[175]: 
                  Quantity
Date       Buyer          
2013-02-28 Carl          1
           Mark          3
2014-02-28 Carl          9
           Joe          18

In [176]: df.groupby([pd.Grouper(freq='6M', level='Date'), 'Buyer']).sum()
Out[176]: 
                  Quantity
Date       Buyer          
2013-01-31 Carl          1
           Mark          3
2014-01-31 Carl          9
           Joe          18</pre>
</div>
<div class="section" id="taking-the-first-rows-of-each-group">
<h3>Taking the first rows of each group<a class="headerlink" href="#taking-the-first-rows-of-each-group" title="Permalink to this headline">¶</a></h3>
<p>Just like for a DataFrame or Series you can call head and tail on a groupby:</p>
<pre class="literal-block">In [177]: df = pd.DataFrame([[1, 2], [1, 4], [5, 6]], columns=['A', 'B'])

In [178]: df
Out[178]: 
   A  B
0  1  2
1  1  4
2  5  6

In [179]: g = df.groupby('A')

In [180]: g.head(1)
Out[180]: 
   A  B
0  1  2
2  5  6

In [181]: g.tail(1)
Out[181]: 
   A  B
1  1  4
2  5  6</pre>
<p>This shows the first or last n rows from each group.</p>
</div>
<div class="section" id="taking-the-nth-row-of-each-group">
<span id="groupby-nth"></span><h3>Taking the nth row of each group<a class="headerlink" href="#taking-the-nth-row-of-each-group" title="Permalink to this headline">¶</a></h3>
<p>To select from a DataFrame or Series the nth item, use
<code class="xref py py-meth docutils literal notranslate"><span class="pre">nth()</span></code>. This is a reduction method, and
will return a single row (or no row) per group if you pass an int for n:</p>
<pre class="literal-block">In [182]: df = pd.DataFrame([[1, np.nan], [1, 4], [5, 6]], columns=['A', 'B'])

In [183]: g = df.groupby('A')

In [184]: g.nth(0)
Out[184]: 
     B
A     
1  NaN
5  6.0

In [185]: g.nth(-1)
Out[185]: 
     B
A     
1  4.0
5  6.0

In [186]: g.nth(1)
Out[186]: 
     B
A     
1  4.0</pre>
<p>If you want to select the nth not-null item, use the <code class="docutils literal notranslate"><span class="pre">dropna</span></code> kwarg. For a DataFrame this should be either <code class="docutils literal notranslate"><span class="pre">'any'</span></code> or <code class="docutils literal notranslate"><span class="pre">'all'</span></code> just like you would pass to dropna:</p>
<pre class="literal-block"># nth(0) is the same as g.first()
In [187]: g.nth(0, dropna='any')
Out[187]: 
     B
A     
1  4.0
5  6.0

In [188]: g.first()
Out[188]: 
     B
A     
1  4.0
5  6.0

# nth(-1) is the same as g.last()
In [189]: g.nth(-1, dropna='any')  # NaNs denote group exhausted when using dropna
Out[189]: 
     B
A     
1  4.0
5  6.0

In [190]: g.last()
Out[190]: 
     B
A     
1  4.0
5  6.0

In [191]: g.B.nth(0, dropna='all')
Out[191]: 
A
1    4.0
5    6.0
Name: B, dtype: float64</pre>
<p>As with other methods, passing <code class="docutils literal notranslate"><span class="pre">as_index=False</span></code>, will achieve a filtration, which returns the grouped row.</p>
<pre class="literal-block">In [192]: df = pd.DataFrame([[1, np.nan], [1, 4], [5, 6]], columns=['A', 'B'])

In [193]: g = df.groupby('A', as_index=False)

In [194]: g.nth(0)
Out[194]: 
   A    B
0  1  NaN
2  5  6.0

In [195]: g.nth(-1)
Out[195]: 
   A    B
1  1  4.0
2  5  6.0</pre>
<p>You can also select multiple rows from each group by specifying multiple nth values as a list of ints.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [196]: </span><span class="n">business_dates</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="s1">&#39;4/1/2014&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;6/30/2014&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>

<span class="gp">In [197]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">business_dates</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">])</span>

<span class="go"># get the first, 4th, and last date index for each month</span>
<span class="gp">In [198]: </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">month</span><span class="p">])</span><span class="o">.</span><span class="n">nth</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gh">Out[198]: </span><span class="go"></span>
<span class="go">        a  b</span>
<span class="go">2014 4  1  1</span>
<span class="go">     4  1  1</span>
<span class="go">     4  1  1</span>
<span class="go">     5  1  1</span>
<span class="go">     5  1  1</span>
<span class="go">     5  1  1</span>
<span class="go">     6  1  1</span>
<span class="go">     6  1  1</span>
<span class="go">     6  1  1</span>
</pre></div>
</div>
</div>
<div class="section" id="enumerate-group-items">
<h3>Enumerate group items<a class="headerlink" href="#enumerate-group-items" title="Permalink to this headline">¶</a></h3>
<p>To see the order in which each row appears within its group, use the
<code class="docutils literal notranslate"><span class="pre">cumcount</span></code> method:</p>
<pre class="literal-block">In [199]: dfg = pd.DataFrame(list('aaabba'), columns=['A'])

In [200]: dfg
Out[200]: 
   A
0  a
1  a
2  a
3  b
4  b
5  a

In [201]: dfg.groupby('A').cumcount()
Out[201]: 
0    0
1    1
2    2
3    0
4    1
5    3
dtype: int64

In [202]: dfg.groupby('A').cumcount(ascending=False)
Out[202]: 
0    3
1    2
2    1
3    1
4    0
5    0
dtype: int64</pre>
</div>
<div class="section" id="enumerate-groups">
<span id="groupby-ngroup"></span><h3>Enumerate groups<a class="headerlink" href="#enumerate-groups" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.2.</span></p>
</div>
<p>To see the ordering of the groups (as opposed to the order of rows
within a group given by <code class="docutils literal notranslate"><span class="pre">cumcount</span></code>) you can use
<code class="xref py py-meth docutils literal notranslate"><span class="pre">ngroup()</span></code>.</p>
<p>Note that the numbers given to the groups match the order in which the
groups would be seen when iterating over the groupby object, not the
order they are first observed.</p>
<pre class="literal-block">In [203]: dfg = pd.DataFrame(list('aaabba'), columns=['A'])

In [204]: dfg
Out[204]: 
   A
0  a
1  a
2  a
3  b
4  b
5  a

In [205]: dfg.groupby('A').ngroup()
Out[205]: 
0    0
1    0
2    0
3    1
4    1
5    0
dtype: int64

In [206]: dfg.groupby('A').ngroup(ascending=False)
Out[206]: 
0    1
1    1
2    1
3    0
4    0
5    1
dtype: int64</pre>
</div>
<div class="section" id="plotting">
<h3>Plotting<a class="headerlink" href="#plotting" title="Permalink to this headline">¶</a></h3>
<p>Groupby also works with some plotting methods.  For example, suppose we
suspect that some features in a DataFrame may differ by group, in this case,
the values in column 1 where the group is “B” are 3 higher on average.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [207]: </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>

<span class="gp">In [208]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="gp">In [209]: </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>

<span class="gp">In [210]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">3</span>
</pre></div>
</div>
<p>We can easily visualize this with a boxplot:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [211]: </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">boxplot</span><span class="p">()</span>
<span class="gh">Out[211]: </span><span class="go"></span>
<span class="go">A         AxesSubplot(0.1,0.15;0.363636x0.75)</span>
<span class="go">B    AxesSubplot(0.536364,0.15;0.363636x0.75)</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<img alt="../_images/groupby_boxplot.png" src="../_images/groupby_boxplot.png" />
<p>The result of calling <code class="docutils literal notranslate"><span class="pre">boxplot</span></code> is a dictionary whose keys are the values
of our grouping column <code class="docutils literal notranslate"><span class="pre">g</span></code> (“A” and “B”). The values of the resulting dictionary
can be controlled by the <code class="docutils literal notranslate"><span class="pre">return_type</span></code> keyword of <code class="docutils literal notranslate"><span class="pre">boxplot</span></code>.
See the <a class="reference internal" href="visualization.html#visualization-box"><span class="std std-ref">visualization documentation</span></a> for more.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>For historical reasons, <code class="docutils literal notranslate"><span class="pre">df.groupby(&quot;g&quot;).boxplot()</span></code> is not equivalent
to <code class="docutils literal notranslate"><span class="pre">df.boxplot(by=&quot;g&quot;)</span></code>. See <a class="reference internal" href="visualization.html#visualization-box-return"><span class="std std-ref">here</span></a> for
an explanation.</p>
</div>
</div>
<div class="section" id="piping-function-calls">
<span id="groupby-pipe"></span><h3>Piping function calls<a class="headerlink" href="#piping-function-calls" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.21.0.</span></p>
</div>
<p>Similar to the functionality provided by <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> and <code class="docutils literal notranslate"><span class="pre">Series</span></code>, functions
that take <code class="docutils literal notranslate"><span class="pre">GroupBy</span></code> objects can be chained together using a <code class="docutils literal notranslate"><span class="pre">pipe</span></code> method to
allow for a cleaner, more readable syntax. To read about <code class="docutils literal notranslate"><span class="pre">.pipe</span></code> in general terms,
see <a class="reference internal" href="../getting_started/basics.html#basics-pipe"><span class="std std-ref">here</span></a>.</p>
<p>Combining <code class="docutils literal notranslate"><span class="pre">.groupby</span></code> and <code class="docutils literal notranslate"><span class="pre">.pipe</span></code> is often useful when you need to reuse
GroupBy objects.</p>
<p>As an example, imagine having a DataFrame with columns for stores, products,
revenue and quantity sold. We’d like to do a groupwise calculation of <em>prices</em>
(i.e. revenue/quantity) per store and per product. We could do this in a
multi-step operation, but expressing it in terms of piping can make the
code more readable. First we set the data:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [212]: </span><span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="gp">In [213]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;Store&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="s1">&#39;Store_1&#39;</span><span class="p">,</span> <span class="s1">&#39;Store_2&#39;</span><span class="p">],</span> <span class="n">n</span><span class="p">),</span>
<span class="gp">   .....: </span>                   <span class="s1">&#39;Product&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="s1">&#39;Product_1&#39;</span><span class="p">,</span>
<span class="gp">   .....: </span>                                                <span class="s1">&#39;Product_2&#39;</span><span class="p">],</span> <span class="n">n</span><span class="p">),</span>
<span class="gp">   .....: </span>                   <span class="s1">&#39;Revenue&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="mi">50</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
<span class="gp">   .....: </span>                   <span class="s1">&#39;Quantity&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)})</span>
<span class="gp">   .....: </span>

<span class="gp">In [214]: </span><span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gh">Out[214]: </span><span class="go"></span>
<span class="go">     Store    Product  Revenue  Quantity</span>
<span class="go">0  Store_2  Product_1    26.12         1</span>
<span class="go">1  Store_2  Product_1    28.86         1</span>
</pre></div>
</div>
<p>Now, to find prices per store/product, we can simply do:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [215]: </span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;Store&#39;</span><span class="p">,</span> <span class="s1">&#39;Product&#39;</span><span class="p">])</span>
<span class="gp">   .....: </span>   <span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="k">lambda</span> <span class="n">grp</span><span class="p">:</span> <span class="n">grp</span><span class="o">.</span><span class="n">Revenue</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">grp</span><span class="o">.</span><span class="n">Quantity</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="gp">   .....: </span>   <span class="o">.</span><span class="n">unstack</span><span class="p">()</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">   .....: </span>
<span class="gh">Out[215]: </span><span class="go"></span>
<span class="go">Product  Product_1  Product_2</span>
<span class="go">Store                        </span>
<span class="go">Store_1       6.82       7.05</span>
<span class="go">Store_2       6.30       6.64</span>
</pre></div>
</div>
<p>Piping can also be expressive when you want to deliver a grouped object to some
arbitrary function, for example:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [216]: </span><span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">groupby</span><span class="p">):</span>
<span class="gp">   .....: </span>    <span class="k">return</span> <span class="n">groupby</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="gp">   .....: </span>

<span class="gp">In [217]: </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;Store&#39;</span><span class="p">,</span> <span class="s1">&#39;Product&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span>
<span class="gh">Out[217]: </span><span class="go"></span>
<span class="go">                     Revenue  Quantity</span>
<span class="go">Store   Product                       </span>
<span class="go">Store_1 Product_1  34.622727  5.075758</span>
<span class="go">        Product_2  35.482815  5.029630</span>
<span class="go">Store_2 Product_1  32.972837  5.237589</span>
<span class="go">        Product_2  34.684360  5.224000</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">mean</span></code> takes a GroupBy object and finds the mean of the Revenue and Quantity
columns respectively for each Store-Product combination. The <code class="docutils literal notranslate"><span class="pre">mean</span></code> function can
be any function that takes in a GroupBy object; the <code class="docutils literal notranslate"><span class="pre">.pipe</span></code> will pass the GroupBy
object as a parameter into the function you specify.</p>
</div>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="regrouping-by-factor">
<h3>Regrouping by factor<a class="headerlink" href="#regrouping-by-factor" title="Permalink to this headline">¶</a></h3>
<p>Regroup columns of a DataFrame according to their sum, and sum the aggregated ones.</p>
<pre class="literal-block">In [218]: df = pd.DataFrame({'a': [1, 0, 0], 'b': [0, 1, 0],
   .....:                    'c': [1, 0, 0], 'd': [2, 3, 4]})
   .....: 

In [219]: df
Out[219]: 
   a  b  c  d
0  1  0  1  2
1  0  1  0  3
2  0  0  0  4

In [220]: df.groupby(df.sum(), axis=1).sum()
Out[220]: 
   1  9
0  2  2
1  1  3
2  0  4</pre>
</div>
<div class="section" id="multi-column-factorization">
<span id="groupby-multicolumn-factorization"></span><h3>Multi-column factorization<a class="headerlink" href="#multi-column-factorization" title="Permalink to this headline">¶</a></h3>
<p>By using <code class="xref py py-meth docutils literal notranslate"><span class="pre">ngroup()</span></code>, we can extract
information about the groups in a way similar to <a class="reference internal" href="../reference/api/pandas.factorize.html#pandas.factorize" title="pandas.factorize"><code class="xref py py-func docutils literal notranslate"><span class="pre">factorize()</span></code></a> (as described
further in the <a class="reference internal" href="reshaping.html#reshaping-factorize"><span class="std std-ref">reshaping API</span></a>) but which applies
naturally to multiple columns of mixed type and different
sources. This can be useful as an intermediate categorical-like step
in processing, when the relationships between the group rows are more
important than their content, or as input to an algorithm which only
accepts the integer encoding. (For more information about support in
pandas for full categorical data, see the <a class="reference internal" href="categorical.html#categorical"><span class="std std-ref">Categorical
introduction</span></a> and the
<span class="xref std std-ref">API documentation</span>.)</p>
<pre class="literal-block">In [221]: dfg = pd.DataFrame({&quot;A&quot;: [1, 1, 2, 3, 2], &quot;B&quot;: list(&quot;aaaba&quot;)})

In [222]: dfg
Out[222]: 
   A  B
0  1  a
1  1  a
2  2  a
3  3  b
4  2  a

In [223]: dfg.groupby([&quot;A&quot;, &quot;B&quot;]).ngroup()
Out[223]: 
0    0
1    0
2    1
3    2
4    1
dtype: int64

In [224]: dfg.groupby([&quot;A&quot;, [0, 0, 0, 1, 1]]).ngroup()
Out[224]: 
0    0
1    0
2    1
3    3
4    2
dtype: int64</pre>
</div>
<div class="section" id="groupby-by-indexer-to-resample-data">
<h3>Groupby by Indexer to ‘resample’ data<a class="headerlink" href="#groupby-by-indexer-to-resample-data" title="Permalink to this headline">¶</a></h3>
<p>Resampling produces new hypothetical samples (resamples) from already existing observed data or from a model that generates data. These new samples are similar to the pre-existing samples.</p>
<p>In order to resample to work on indices that are non-datetimelike, the following procedure can be utilized.</p>
<p>In the following examples, <strong>df.index // 5</strong> returns a binary array which is used to determine what gets selected for the groupby operation.</p>
<div class="alert alert-info">
<p class="admonition-title">Note</p>
<p>The below example shows how we can downsample by consolidation of samples into fewer samples. Here by using <strong>df.index // 5</strong>, we are aggregating the samples in bins. By applying <strong>std()</strong> function, we aggregate the information contained in many samples into a small subset of values which is their standard deviation thereby reducing the number of samples.</p>
</div>
<pre class="literal-block">In [225]: df = pd.DataFrame(np.random.randn(10, 2))

In [226]: df
Out[226]: 
          0         1
0 -0.793893  0.321153
1  0.342250  1.618906
2 -0.975807  1.918201
3 -0.810847 -1.405919
4 -1.977759  0.461659
5  0.730057 -1.316938
6 -0.751328  0.528290
7 -0.257759 -1.081009
8  0.505895 -1.701948
9 -1.006349  0.020208

In [227]: df.index // 5
Out[227]: Int64Index([0, 0, 0, 0, 0, 1, 1, 1, 1, 1], dtype='int64')

In [228]: df.groupby(df.index // 5).std()
Out[228]: 
          0         1
0  0.823647  1.312912
1  0.760109  0.942941</pre>
</div>
<div class="section" id="returning-a-series-to-propagate-names">
<h3>Returning a Series to propagate names<a class="headerlink" href="#returning-a-series-to-propagate-names" title="Permalink to this headline">¶</a></h3>
<p>Group DataFrame columns, compute a set of metrics and return a named Series.
The Series name is used as the name for the column index. This is especially
useful in conjunction with reshaping operations such as stacking in which the
column index name will be used as the name of the inserted column:</p>
<pre class="literal-block">In [229]: df = pd.DataFrame({'a': [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2],
   .....:                    'b': [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
   .....:                    'c': [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
   .....:                    'd': [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1]})
   .....: 

In [230]: def compute_metrics(x):
   .....:     result = {'b_sum': x['b'].sum(), 'c_mean': x['c'].mean()}
   .....:     return pd.Series(result, name='metrics')
   .....: 

In [231]: result = df.groupby('a').apply(compute_metrics)

In [232]: result
Out[232]: 
metrics  b_sum  c_mean
a                     
0          2.0     0.5
1          2.0     0.5
2          2.0     0.5

In [233]: result.stack()
Out[233]: 
a  metrics
0  b_sum      2.0
   c_mean     0.5
1  b_sum      2.0
   c_mean     0.5
2  b_sum      2.0
   c_mean     0.5
dtype: float64</pre>
</div>
</div>
</div>


              </div>
              <div class='prev-next-bottom'>
                
    <a class='left-prev' id="prev-link" href="computation.html" title="previous page">Computational tools</a>
    <a class='right-next' id="next-link" href="timeseries.html" title="next page">Time Series / Date functionality</a>

              </div>
          </main>

      </div>
    </div><script>
    // TOC sidebar - add "active" class to parent list
    //
    // Bootstrap's scrollspy adds the active class to the <a> link,
    // but for the automatic collapsing we need this on the parent list item.
    //
    // The event is triggered on "window" (and not the nav item as documented),
    // see https://github.com/twbs/bootstrap/issues/20086
    $(window).on("activate.bs.scrollspy", function(){
    var navLinks = document.querySelectorAll('#bd-toc-nav a');
    for (var i = 0; i < navLinks.length; i++) {
        var navLink = navLinks[i];
        navLink.parentElement.classList.remove('active');
    }
    var navLinks = document.querySelectorAll('#bd-toc-nav a.active');
    for (var i = 0; i < navLinks.length; i++) {
        var navLink = navLinks[i];
        navLink.parentElement.classList.add('active');
    }
    });

    /**
     * Use left and right arrow keys to navigate forward and backwards.
    */
    const LEFT_ARROW_KEYCODE = 37
    const RIGHT_ARROW_KEYCODE = 39

    const getPrevUrl = () => document.getElementById('prev-link').href
    const getNextUrl = () => document.getElementById('next-link').href
    const initPageNav = (event) => {
        const keycode = event.which

        if (keycode === LEFT_ARROW_KEYCODE) {
            window.location.href = getPrevUrl();
        } else if (keycode === RIGHT_ARROW_KEYCODE) {
            window.location.href = getNextUrl();
        }
    };

    var keyboardListener = false;
    $( document ).ready(() => {
        if (keyboardListener === false) {
            document.addEventListener('keydown', initPageNav)
            keyboardListener = true;
        }
    });
</script>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2008-2014, the pandas development team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.1.
    </div>
  </body>
</html>