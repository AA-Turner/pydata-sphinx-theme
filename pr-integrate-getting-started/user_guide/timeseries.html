

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Time Series / Date functionality &#8212; pandas 0.25.3 documentation</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="../_static/sphinx-bootstrap.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/getting_started.css" />
    <link href="../_static/css/custom.css" rel="stylesheet">
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Time Deltas" href="timedeltas.html" />
    <link rel="prev" title="Group By: split-apply-combine" href="groupby.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main">

<a class="navbar-brand" href="../index.html">
  <img src="../_static/pandas.svg" class="logo" alt="logo">
</a>

<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
</button>

<div id="navbar-menu" class="collapse navbar-collapse">
  <ul id="navbar-main-elements" class="navbar-nav mr-auto">
    <li class="nav-item">
        <a class="nav-link" href="../index.html">Home</a>
    </li>
    
    
    <li class="nav-item ">
        <a class="nav-link" href="../getting_started/index.html">Getting started</a>
    </li>
    
    <li class="nav-item active">
        <a class="nav-link" href="index.html">User Guide</a>
    </li>
    
    <li class="nav-item ">
        <a class="nav-link" href="../reference/index.html">API Reference</a>
    </li>
    
    <li class="nav-item ">
        <a class="nav-link" href="../development/index.html">Development</a>
    </li>
    
    <li class="nav-item ">
        <a class="nav-link" href="../whatsnew/index.html">Release Notes</a>
    </li>
    
    <li class="nav-item ">
        <a class="nav-link" href="../development/index.html">Development</a>
    </li>
    
  </ul>
  <ul class="navbar-nav ml-auto">
    <li class="nav-item">
      <a class="nav-link" href="https://github.com/pandas-dev/pandas" target="_blank" rel="noopener">
        <span><i class="fab fa-github-alt" style="color:#333;font-size:1rem;line-height:1.25"></i></span>
      </a>
    </li>
    <li class="nav-item">
      <a class="nav-link" href="https://twitter.com/pandas_dev" target="_blank" rel="noopener">
        <span><i class="fab fa-twitter" style="color:#55acee;font-size:1rem;line-height:1.25"></i></span>
      </a>
    </li>
  </ul>
</div>
    </nav>

    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
          <div class="col-12 col-md-3 col-xl-2 bd-sidebar">
              

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">

  <div class="bd-toc-item active">
  

  <ul class="nav bd-sidenav">
      
      
      
      
        
          
              <li class="">
                  <a href="io.html">IO Tools (Text, CSV, HDF5, …)</a>
              </li>
          
        
          
              <li class="">
                  <a href="indexing.html">Indexing and Selecting Data</a>
              </li>
          
        
          
              <li class="">
                  <a href="advanced.html">MultiIndex / Advanced Indexing</a>
              </li>
          
        
          
              <li class="">
                  <a href="merging.html">Merge, join, and concatenate</a>
              </li>
          
        
          
              <li class="">
                  <a href="reshaping.html">Reshaping and Pivot Tables</a>
              </li>
          
        
          
              <li class="">
                  <a href="text.html">Working with Text Data</a>
              </li>
          
        
          
              <li class="">
                  <a href="missing_data.html">Working with missing data</a>
              </li>
          
        
          
              <li class="">
                  <a href="categorical.html">Categorical Data</a>
              </li>
          
        
          
              <li class="">
                  <a href="integer_na.html">Nullable Integer Data Type</a>
              </li>
          
        
          
              <li class="">
                  <a href="visualization.html">Visualization</a>
              </li>
          
        
          
              <li class="">
                  <a href="computation.html">Computational tools</a>
              </li>
          
        
          
              <li class="">
                  <a href="groupby.html">Group By: split-apply-combine</a>
              </li>
          
        
          
              <li class="active">
                  <a href="">Time Series / Date functionality</a>
              </li>
          
        
          
              <li class="">
                  <a href="timedeltas.html">Time Deltas</a>
              </li>
          
        
          
              <li class="">
                  <a href="options.html">Options and Settings</a>
              </li>
          
        
          
              <li class="">
                  <a href="enhancingperf.html">Enhancing Performance</a>
              </li>
          
        
          
              <li class="">
                  <a href="sparse.html">Sparse data structures</a>
              </li>
          
        
          
              <li class="">
                  <a href="gotchas.html">Frequently Asked Questions (FAQ)</a>
              </li>
          
        
          
              <li class="">
                  <a href="cookbook.html">Cookbook</a>
              </li>
          
        
      
      
      
      
      
      
      
      
      
      
    </ul>

</nav>


              
          </div>

          <div class="d-none d-xl-block col-xl-2 bd-toc">
              

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#overview" class="nav-link">Overview</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#timestamps-vs-time-spans" class="nav-link">Timestamps vs. Time Spans</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#converting-to-timestamps" class="nav-link">Converting to Timestamps</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#providing-a-format-argument" class="nav-link">Providing a Format Argument</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#assembling-datetime-from-multiple-dataframe-columns" class="nav-link">Assembling Datetime from Multiple DataFrame Columns</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#invalid-data" class="nav-link">Invalid Data</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#epoch-timestamps" class="nav-link">Epoch Timestamps</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#from-timestamps-to-epoch" class="nav-link">From Timestamps to Epoch</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#using-the-origin-parameter" class="nav-link">Using the origin Parameter</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#generating-ranges-of-timestamps" class="nav-link">Generating Ranges of Timestamps</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#custom-frequency-ranges" class="nav-link">Custom Frequency Ranges</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#timestamp-limitations" class="nav-link">Timestamp Limitations</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#indexing" class="nav-link">Indexing</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#partial-string-indexing" class="nav-link">Partial String Indexing</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#slice-vs-exact-match" class="nav-link">Slice vs. Exact Match</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#exact-indexing" class="nav-link">Exact Indexing</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#truncating-fancy-indexing" class="nav-link">Truncating & Fancy Indexing</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#iterating-through-groups" class="nav-link">Iterating through groups</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#time-date-components" class="nav-link">Time/Date Components</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#dateoffset-objects" class="nav-link">DateOffset Objects</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#parametric-offsets" class="nav-link">Parametric Offsets</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#using-offsets-with-series-datetimeindex" class="nav-link">Using Offsets with Series / DatetimeIndex</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#custom-business-days" class="nav-link">Custom Business Days</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#business-hour" class="nav-link">Business Hour</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#custom-business-hour" class="nav-link">Custom Business Hour</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#offset-aliases" class="nav-link">Offset Aliases</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#combining-aliases" class="nav-link">Combining Aliases</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#anchored-offsets" class="nav-link">Anchored Offsets</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#anchored-offset-semantics" class="nav-link">Anchored Offset Semantics</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#holidays-holiday-calendars" class="nav-link">Holidays / Holiday Calendars</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#time-series-related-instance-methods" class="nav-link">Time Series-Related Instance Methods</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#shifting-lagging" class="nav-link">Shifting / Lagging</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#frequency-conversion" class="nav-link">Frequency Conversion</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#filling-forward-backward" class="nav-link">Filling Forward / Backward</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#converting-to-python-datetimes" class="nav-link">Converting to Python Datetimes</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#resampling" class="nav-link">Resampling</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#basics" class="nav-link">Basics</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#upsampling" class="nav-link">Upsampling</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#sparse-resampling" class="nav-link">Sparse Resampling</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#aggregation" class="nav-link">Aggregation</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#time-span-representation" class="nav-link">Time Span Representation</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#period" class="nav-link">Period</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#periodindex-and-period-range" class="nav-link">PeriodIndex and period_range</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#period-dtypes" class="nav-link">Period Dtypes</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#periodindex-partial-string-indexing" class="nav-link">PeriodIndex Partial String Indexing</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#frequency-conversion-and-resampling-with-periodindex" class="nav-link">Frequency Conversion and Resampling with PeriodIndex</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#converting-between-representations" class="nav-link">Converting Between Representations</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#representing-out-of-bounds-spans" class="nav-link">Representing Out-of-Bounds Spans</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#time-zone-handling" class="nav-link">Time Zone Handling</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#working-with-time-zones" class="nav-link">Working with Time Zones</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#ambiguous-times-when-localizing" class="nav-link">Ambiguous Times when Localizing</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#nonexistent-times-when-localizing" class="nav-link">Nonexistent Times when Localizing</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#time-zone-series-operations" class="nav-link">Time Zone Series Operations</a>
        </li>
    
            </ul>
        </li>
    
    </ul>
</nav>
              
            </div>

          <main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content" role="main">
              <div>
                
  <div class="section" id="time-series-date-functionality">
<span id="timeseries"></span><h1>Time Series / Date functionality<a class="headerlink" href="#time-series-date-functionality" title="Permalink to this headline">¶</a></h1>
<p>pandas contains extensive capabilities and features for working with time series data for all domains.
Using the NumPy <code class="docutils literal notranslate"><span class="pre">datetime64</span></code> and <code class="docutils literal notranslate"><span class="pre">timedelta64</span></code> dtypes, pandas has consolidated a large number of
features from other Python libraries like <code class="docutils literal notranslate"><span class="pre">scikits.timeseries</span></code> as well as created
a tremendous amount of new functionality for manipulating time series data.</p>
<p>For example, pandas supports:</p>
<p>Parsing time series information from various sources and formats</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">datetime</span>

<span class="gp">In [2]: </span><span class="n">dti</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">([</span><span class="s1">&#39;1/1/2018&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;2018-01-01&#39;</span><span class="p">),</span>
<span class="gp">   ...: </span>                      <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2018</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">   ...: </span>

<span class="gp">In [3]: </span><span class="n">dti</span>
<span class="gh">Out[3]: </span><span class="go">DatetimeIndex([&#39;2018-01-01&#39;, &#39;2018-01-01&#39;, &#39;2018-01-01&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</span>
</pre></div>
</div>
<p>Generate sequences of fixed-frequency dates and time spans</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">dti</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;2018-01-01&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>

<span class="gp">In [5]: </span><span class="n">dti</span>
<span class="gh">Out[5]: </span><span class="go"></span>
<span class="go">DatetimeIndex([&#39;2018-01-01 00:00:00&#39;, &#39;2018-01-01 01:00:00&#39;,</span>
<span class="go">               &#39;2018-01-01 02:00:00&#39;],</span>
<span class="go">              dtype=&#39;datetime64[ns]&#39;, freq=&#39;H&#39;)</span>
</pre></div>
</div>
<p>Manipulating and converting date times with timezone information</p>
<pre class="literal-block">In [6]: dti = dti.tz_localize('UTC')

In [7]: dti
Out[7]: 
DatetimeIndex(['2018-01-01 00:00:00+00:00', '2018-01-01 01:00:00+00:00',
               '2018-01-01 02:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='H')

In [8]: dti.tz_convert('US/Pacific')
Out[8]: 
DatetimeIndex(['2017-12-31 16:00:00-08:00', '2017-12-31 17:00:00-08:00',
               '2017-12-31 18:00:00-08:00'],
              dtype='datetime64[ns, US/Pacific]', freq='H')</pre>
<p>Resampling or converting a time series to a particular frequency</p>
<pre class="literal-block">In [9]: idx = pd.date_range('2018-01-01', periods=5, freq='H')

In [10]: ts = pd.Series(range(len(idx)), index=idx)

In [11]: ts
Out[11]: 
2018-01-01 00:00:00    0
2018-01-01 01:00:00    1
2018-01-01 02:00:00    2
2018-01-01 03:00:00    3
2018-01-01 04:00:00    4
Freq: H, dtype: int64

In [12]: ts.resample('2H').mean()
Out[12]: 
2018-01-01 00:00:00    0.5
2018-01-01 02:00:00    2.5
2018-01-01 04:00:00    4.0
Freq: 2H, dtype: float64</pre>
<p>Performing date and time arithmetic with absolute or relative time increments</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [13]: </span><span class="n">friday</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;2018-01-05&#39;</span><span class="p">)</span>

<span class="gp">In [14]: </span><span class="n">friday</span><span class="o">.</span><span class="n">day_name</span><span class="p">()</span>
<span class="gh">Out[14]: </span><span class="go">&#39;Friday&#39;</span>

<span class="go"># Add 1 day</span>
<span class="gp">In [15]: </span><span class="n">saturday</span> <span class="o">=</span> <span class="n">friday</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="s1">&#39;1 day&#39;</span><span class="p">)</span>

<span class="gp">In [16]: </span><span class="n">saturday</span><span class="o">.</span><span class="n">day_name</span><span class="p">()</span>
<span class="gh">Out[16]: </span><span class="go">&#39;Saturday&#39;</span>

<span class="go"># Add 1 business day (Friday --&gt; Monday)</span>
<span class="gp">In [17]: </span><span class="n">monday</span> <span class="o">=</span> <span class="n">friday</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">offsets</span><span class="o">.</span><span class="n">BDay</span><span class="p">()</span>

<span class="gp">In [18]: </span><span class="n">monday</span><span class="o">.</span><span class="n">day_name</span><span class="p">()</span>
<span class="gh">Out[18]: </span><span class="go">&#39;Monday&#39;</span>
</pre></div>
</div>
<p>pandas provides a relatively compact and self-contained set of tools for
performing the above tasks and more.</p>
<div class="section" id="overview">
<span id="timeseries-overview"></span><h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>pandas captures 4 general time related concepts:</p>
<ol class="arabic simple">
<li><p>Date times: A specific date and time with timezone support. Similar to <code class="docutils literal notranslate"><span class="pre">datetime.datetime</span></code> from the standard library.</p></li>
<li><p>Time deltas: An absolute time duration. Similar to <code class="docutils literal notranslate"><span class="pre">datetime.timedelta</span></code> from the standard library.</p></li>
<li><p>Time spans: A span of time defined by a point in time and its associated frequency.</p></li>
<li><p>Date offsets: A relative time duration that respects calendar arithmetic. Similar to <code class="docutils literal notranslate"><span class="pre">dateutil.relativedelta.relativedelta</span></code> from the <code class="docutils literal notranslate"><span class="pre">dateutil</span></code> package.</p></li>
</ol>
<table class="table">
<colgroup>
<col style="width: 15%" />
<col style="width: 12%" />
<col style="width: 13%" />
<col style="width: 31%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Concept</p></th>
<th class="head"><p>Scalar Class</p></th>
<th class="head"><p>Array Class</p></th>
<th class="head"><p>pandas Data Type</p></th>
<th class="head"><p>Primary Creation Method</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Date times</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Timestamp</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">datetime64[ns]</span></code> or <code class="docutils literal notranslate"><span class="pre">datetime64[ns,</span> <span class="pre">tz]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">to_datetime</span></code> or <code class="docutils literal notranslate"><span class="pre">date_range</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Time deltas</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Timedelta</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">TimedeltaIndex</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">timedelta64[ns]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">to_timedelta</span></code> or <code class="docutils literal notranslate"><span class="pre">timedelta_range</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Time spans</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Period</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">period[freq]</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Period</span></code> or <code class="docutils literal notranslate"><span class="pre">period_range</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Date offsets</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">DateOffset</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">DateOffset</span></code></p></td>
</tr>
</tbody>
</table>
<p>For time series data, it’s conventional to represent the time component in the index of a <code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code> or <a class="reference internal" href="../reference/api/pandas.DataFrame.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a>
so manipulations can be performed with respect to the time element.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [19]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;2000&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
<span class="gh">Out[19]: </span><span class="go"></span>
<span class="go">2000-01-01    0</span>
<span class="go">2000-01-02    1</span>
<span class="go">2000-01-03    2</span>
<span class="go">Freq: D, dtype: int64</span>
</pre></div>
</div>
<p>However, <code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code> and <a class="reference internal" href="../reference/api/pandas.DataFrame.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> can directly also support the time component as data itself.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [20]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;2000&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
<span class="gh">Out[20]: </span><span class="go"></span>
<span class="go">0   2000-01-01</span>
<span class="go">1   2000-01-02</span>
<span class="go">2   2000-01-03</span>
<span class="go">dtype: datetime64[ns]</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code> and <a class="reference internal" href="../reference/api/pandas.DataFrame.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> have extended data type support and functionality for <code class="docutils literal notranslate"><span class="pre">datetime</span></code>, <code class="docutils literal notranslate"><span class="pre">timedelta</span></code>
and <code class="docutils literal notranslate"><span class="pre">Period</span></code> data when passed into those constructors. <code class="docutils literal notranslate"><span class="pre">DateOffset</span></code>
data however will be stored as <code class="docutils literal notranslate"><span class="pre">object</span></code> data.</p>
<pre class="literal-block">In [21]: pd.Series(pd.period_range('1/1/2011', freq='M', periods=3))
Out[21]: 
0    2011-01
1    2011-02
2    2011-03
dtype: period[M]

In [22]: pd.Series([pd.DateOffset(1), pd.DateOffset(2)])
Out[22]: 
0         &lt;DateOffset&gt;
1    &lt;2 * DateOffsets&gt;
dtype: object

In [23]: pd.Series(pd.date_range('1/1/2011', freq='M', periods=3))
Out[23]: 
0   2011-01-31
1   2011-02-28
2   2011-03-31
dtype: datetime64[ns]</pre>
<p>Lastly, pandas represents null date times, time deltas, and time spans as <code class="docutils literal notranslate"><span class="pre">NaT</span></code> which
is useful for representing missing or null date like values and behaves similar
as <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> does for float data.</p>
<pre class="literal-block">In [24]: pd.Timestamp(pd.NaT)
Out[24]: NaT

In [25]: pd.Timedelta(pd.NaT)
Out[25]: NaT

In [26]: pd.Period(pd.NaT)
Out[26]: NaT

# Equality acts as np.nan would
In [27]: pd.NaT == pd.NaT
Out[27]: False</pre>
</div>
<div class="section" id="timestamps-vs-time-spans">
<span id="timeseries-representation"></span><h2>Timestamps vs. Time Spans<a class="headerlink" href="#timestamps-vs-time-spans" title="Permalink to this headline">¶</a></h2>
<p>Timestamped data is the most basic type of time series data that associates
values with points in time. For pandas objects it means using the points in
time.</p>
<pre class="literal-block">In [28]: pd.Timestamp(datetime.datetime(2012, 5, 1))
Out[28]: Timestamp('2012-05-01 00:00:00')

In [29]: pd.Timestamp('2012-05-01')
Out[29]: Timestamp('2012-05-01 00:00:00')

In [30]: pd.Timestamp(2012, 5, 1)
Out[30]: Timestamp('2012-05-01 00:00:00')</pre>
<p>However, in many cases it is more natural to associate things like change
variables with a time span instead. The span represented by <code class="docutils literal notranslate"><span class="pre">Period</span></code> can be
specified explicitly, or inferred from datetime string format.</p>
<p>For example:</p>
<pre class="literal-block">In [31]: pd.Period('2011-01')
Out[31]: Period('2011-01', 'M')

In [32]: pd.Period('2012-05', freq='D')
Out[32]: Period('2012-05-01', 'D')</pre>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Timestamp</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">Period</span></code> can serve as an index. Lists of
<code class="docutils literal notranslate"><span class="pre">Timestamp</span></code> and <code class="docutils literal notranslate"><span class="pre">Period</span></code> are automatically coerced to <code class="xref py py-class docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>
and <code class="xref py py-class docutils literal notranslate"><span class="pre">PeriodIndex</span></code> respectively.</p>
<pre class="literal-block">In [33]: dates = [pd.Timestamp('2012-05-01'),
   ....:          pd.Timestamp('2012-05-02'),
   ....:          pd.Timestamp('2012-05-03')]
   ....: 

In [34]: ts = pd.Series(np.random.randn(3), dates)

In [35]: type(ts.index)
Out[35]: pandas.core.indexes.datetimes.DatetimeIndex

In [36]: ts.index
Out[36]: DatetimeIndex(['2012-05-01', '2012-05-02', '2012-05-03'], dtype='datetime64[ns]', freq=None)

In [37]: ts
Out[37]: 
2012-05-01    0.469112
2012-05-02   -0.282863
2012-05-03   -1.509059
dtype: float64

In [38]: periods = [pd.Period('2012-01'), pd.Period('2012-02'), pd.Period('2012-03')]

In [39]: ts = pd.Series(np.random.randn(3), periods)

In [40]: type(ts.index)
Out[40]: pandas.core.indexes.period.PeriodIndex

In [41]: ts.index
Out[41]: PeriodIndex(['2012-01', '2012-02', '2012-03'], dtype='period[M]', freq='M')

In [42]: ts
Out[42]: 
2012-01   -1.135632
2012-02    1.212112
2012-03   -0.173215
Freq: M, dtype: float64</pre>
<p>pandas allows you to capture both representations and
convert between them. Under the hood, pandas represents timestamps using
instances of <code class="docutils literal notranslate"><span class="pre">Timestamp</span></code> and sequences of timestamps using instances of
<code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>. For regular time spans, pandas uses <code class="docutils literal notranslate"><span class="pre">Period</span></code> objects for
scalar values and <code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code> for sequences of spans. Better support for
irregular intervals with arbitrary start and end points are forth-coming in
future releases.</p>
</div>
<div class="section" id="converting-to-timestamps">
<span id="timeseries-converting"></span><h2>Converting to Timestamps<a class="headerlink" href="#converting-to-timestamps" title="Permalink to this headline">¶</a></h2>
<p>To convert a <code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code> or list-like object of date-like objects e.g. strings,
epochs, or a mixture, you can use the <code class="docutils literal notranslate"><span class="pre">to_datetime</span></code> function. When passed
a <code class="docutils literal notranslate"><span class="pre">Series</span></code>, this returns a <code class="docutils literal notranslate"><span class="pre">Series</span></code> (with the same index), while a list-like
is converted to a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>:</p>
<pre class="literal-block">In [43]: pd.to_datetime(pd.Series(['Jul 31, 2009', '2010-01-10', None]))
Out[43]: 
0   2009-07-31
1   2010-01-10
2          NaT
dtype: datetime64[ns]

In [44]: pd.to_datetime(['2005/11/23', '2010.12.31'])
Out[44]: DatetimeIndex(['2005-11-23', '2010-12-31'], dtype='datetime64[ns]', freq=None)</pre>
<p>If you use dates which start with the day first (i.e. European style),
you can pass the <code class="docutils literal notranslate"><span class="pre">dayfirst</span></code> flag:</p>
<pre class="literal-block">In [45]: pd.to_datetime(['04-01-2012 10:00'], dayfirst=True)
Out[45]: DatetimeIndex(['2012-01-04 10:00:00'], dtype='datetime64[ns]', freq=None)

In [46]: pd.to_datetime(['14-01-2012', '01-14-2012'], dayfirst=True)
Out[46]: DatetimeIndex(['2012-01-14', '2012-01-14'], dtype='datetime64[ns]', freq=None)</pre>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>You see in the above example that <code class="docutils literal notranslate"><span class="pre">dayfirst</span></code> isn’t strict, so if a date
can’t be parsed with the day being first it will be parsed as if
<code class="docutils literal notranslate"><span class="pre">dayfirst</span></code> were False.</p>
</div>
<p>If you pass a single string to <code class="docutils literal notranslate"><span class="pre">to_datetime</span></code>, it returns a single <code class="docutils literal notranslate"><span class="pre">Timestamp</span></code>.
<code class="docutils literal notranslate"><span class="pre">Timestamp</span></code> can also accept string input, but it doesn’t accept string parsing
options like <code class="docutils literal notranslate"><span class="pre">dayfirst</span></code> or <code class="docutils literal notranslate"><span class="pre">format</span></code>, so use <code class="docutils literal notranslate"><span class="pre">to_datetime</span></code> if these are required.</p>
<pre class="literal-block">In [47]: pd.to_datetime('2010/11/12')
Out[47]: Timestamp('2010-11-12 00:00:00')

In [48]: pd.Timestamp('2010/11/12')
Out[48]: Timestamp('2010-11-12 00:00:00')</pre>
<p>You can also use the <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> constructor directly:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [49]: </span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">([</span><span class="s1">&#39;2018-01-01&#39;</span><span class="p">,</span> <span class="s1">&#39;2018-01-03&#39;</span><span class="p">,</span> <span class="s1">&#39;2018-01-05&#39;</span><span class="p">])</span>
<span class="gh">Out[49]: </span><span class="go">DatetimeIndex([&#39;2018-01-01&#39;, &#39;2018-01-03&#39;, &#39;2018-01-05&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</span>
</pre></div>
</div>
<p>The string ‘infer’ can be passed in order to set the frequency of the index as the
inferred frequency upon creation:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [50]: </span><span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">([</span><span class="s1">&#39;2018-01-01&#39;</span><span class="p">,</span> <span class="s1">&#39;2018-01-03&#39;</span><span class="p">,</span> <span class="s1">&#39;2018-01-05&#39;</span><span class="p">],</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;infer&#39;</span><span class="p">)</span>
<span class="gh">Out[50]: </span><span class="go">DatetimeIndex([&#39;2018-01-01&#39;, &#39;2018-01-03&#39;, &#39;2018-01-05&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;2D&#39;)</span>
</pre></div>
</div>
<div class="section" id="providing-a-format-argument">
<h3>Providing a Format Argument<a class="headerlink" href="#providing-a-format-argument" title="Permalink to this headline">¶</a></h3>
<p>In addition to the required datetime string, a <code class="docutils literal notranslate"><span class="pre">format</span></code> argument can be passed to ensure specific parsing.
This could also potentially speed up the conversion considerably.</p>
<pre class="literal-block">In [51]: pd.to_datetime('2010/11/12', format='%Y/%m/%d')
Out[51]: Timestamp('2010-11-12 00:00:00')

In [52]: pd.to_datetime('12-11-2010 00:00', format='%d-%m-%Y %H:%M')
Out[52]: Timestamp('2010-11-12 00:00:00')</pre>
<p>For more information on the choices available when specifying the <code class="docutils literal notranslate"><span class="pre">format</span></code>
option, see the Python <a class="reference external" href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior">datetime documentation</a>.</p>
</div>
<div class="section" id="assembling-datetime-from-multiple-dataframe-columns">
<h3>Assembling Datetime from Multiple DataFrame Columns<a class="headerlink" href="#assembling-datetime-from-multiple-dataframe-columns" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.1.</span></p>
</div>
<p>You can also pass a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> of integer or string columns to assemble into a <code class="docutils literal notranslate"><span class="pre">Series</span></code> of <code class="docutils literal notranslate"><span class="pre">Timestamps</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [53]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;year&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2015</span><span class="p">,</span> <span class="mi">2016</span><span class="p">],</span>
<span class="gp">   ....: </span>                   <span class="s1">&#39;month&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">   ....: </span>                   <span class="s1">&#39;day&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">   ....: </span>                   <span class="s1">&#39;hour&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">   ....: </span>

<span class="gp">In [54]: </span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="gh">Out[54]: </span><span class="go"></span>
<span class="go">0   2015-02-04 02:00:00</span>
<span class="go">1   2016-03-05 03:00:00</span>
<span class="go">dtype: datetime64[ns]</span>
</pre></div>
</div>
<p>You can pass only the columns that you need to assemble.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [55]: </span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;year&#39;</span><span class="p">,</span> <span class="s1">&#39;month&#39;</span><span class="p">,</span> <span class="s1">&#39;day&#39;</span><span class="p">]])</span>
<span class="gh">Out[55]: </span><span class="go"></span>
<span class="go">0   2015-02-04</span>
<span class="go">1   2016-03-05</span>
<span class="go">dtype: datetime64[ns]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">pd.to_datetime</span></code> looks for standard designations of the datetime component in the column names, including:</p>
<ul class="simple">
<li><p>required: <code class="docutils literal notranslate"><span class="pre">year</span></code>, <code class="docutils literal notranslate"><span class="pre">month</span></code>, <code class="docutils literal notranslate"><span class="pre">day</span></code></p></li>
<li><p>optional: <code class="docutils literal notranslate"><span class="pre">hour</span></code>, <code class="docutils literal notranslate"><span class="pre">minute</span></code>, <code class="docutils literal notranslate"><span class="pre">second</span></code>, <code class="docutils literal notranslate"><span class="pre">millisecond</span></code>, <code class="docutils literal notranslate"><span class="pre">microsecond</span></code>, <code class="docutils literal notranslate"><span class="pre">nanosecond</span></code></p></li>
</ul>
</div>
<div class="section" id="invalid-data">
<h3>Invalid Data<a class="headerlink" href="#invalid-data" title="Permalink to this headline">¶</a></h3>
<p>The default behavior, <code class="docutils literal notranslate"><span class="pre">errors='raise'</span></code>, is to raise when unparseable:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [2]: </span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">([</span><span class="s1">&#39;2009/07/31&#39;</span><span class="p">,</span> <span class="s1">&#39;asd&#39;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">)</span>
<span class="go">ValueError: Unknown string format</span>
</pre></div>
</div>
<p>Pass <code class="docutils literal notranslate"><span class="pre">errors='ignore'</span></code> to return the original input when unparseable:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [56]: </span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">([</span><span class="s1">&#39;2009/07/31&#39;</span><span class="p">,</span> <span class="s1">&#39;asd&#39;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
<span class="gh">Out[56]: </span><span class="go">Index([&#39;2009/07/31&#39;, &#39;asd&#39;], dtype=&#39;object&#39;)</span>
</pre></div>
</div>
<p>Pass <code class="docutils literal notranslate"><span class="pre">errors='coerce'</span></code> to convert unparseable data to <code class="docutils literal notranslate"><span class="pre">NaT</span></code> (not a time):</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [57]: </span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">([</span><span class="s1">&#39;2009/07/31&#39;</span><span class="p">,</span> <span class="s1">&#39;asd&#39;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;coerce&#39;</span><span class="p">)</span>
<span class="gh">Out[57]: </span><span class="go">DatetimeIndex([&#39;2009-07-31&#39;, &#39;NaT&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</span>
</pre></div>
</div>
</div>
<div class="section" id="epoch-timestamps">
<span id="timeseries-converting-epoch"></span><h3>Epoch Timestamps<a class="headerlink" href="#epoch-timestamps" title="Permalink to this headline">¶</a></h3>
<p>pandas supports converting integer or float epoch times to <code class="docutils literal notranslate"><span class="pre">Timestamp</span></code> and
<code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>. The default unit is nanoseconds, since that is how <code class="docutils literal notranslate"><span class="pre">Timestamp</span></code>
objects are stored internally. However, epochs are often stored in another <code class="docutils literal notranslate"><span class="pre">unit</span></code>
which can be specified. These are computed from the starting point specified by the
<code class="docutils literal notranslate"><span class="pre">origin</span></code> parameter.</p>
<pre class="literal-block">In [58]: pd.to_datetime([1349720105, 1349806505, 1349892905,
   ....:                 1349979305, 1350065705], unit='s')
   ....: 
Out[58]: 
DatetimeIndex(['2012-10-08 18:15:05', '2012-10-09 18:15:05',
               '2012-10-10 18:15:05', '2012-10-11 18:15:05',
               '2012-10-12 18:15:05'],
              dtype='datetime64[ns]', freq=None)

In [59]: pd.to_datetime([1349720105100, 1349720105200, 1349720105300,
   ....:                 1349720105400, 1349720105500], unit='ms')
   ....: 
Out[59]: 
DatetimeIndex(['2012-10-08 18:15:05.100000', '2012-10-08 18:15:05.200000',
               '2012-10-08 18:15:05.300000', '2012-10-08 18:15:05.400000',
               '2012-10-08 18:15:05.500000'],
              dtype='datetime64[ns]', freq=None)</pre>
<p>Constructing a <code class="xref py py-class docutils literal notranslate"><span class="pre">Timestamp</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> with an epoch timestamp
with the <code class="docutils literal notranslate"><span class="pre">tz</span></code> argument specified will localize the epoch timestamps to UTC
first then convert the result to the specified time zone.</p>
<pre class="literal-block">In [60]: pd.Timestamp(1262347200000000000, tz='US/Pacific')
Out[60]: Timestamp('2010-01-01 04:00:00-0800', tz='US/Pacific')

In [61]: pd.DatetimeIndex([1262347200000000000], tz='US/Pacific')
Out[61]: DatetimeIndex(['2010-01-01 12:00:00-08:00'], dtype='datetime64[ns, US/Pacific]', freq=None)</pre>
<div class="alert alert-info">
<p class="admonition-title">Note</p>
<p>Epoch times will be rounded to the nearest nanosecond.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Conversion of float epoch times can lead to inaccurate and unexpected results.
<a class="reference external" href="https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues" title="(in Python v3.8)"><span class="xref std std-ref">Python floats</span></a> have about 15 digits precision in
decimal. Rounding during conversion from float to high precision <code class="docutils literal notranslate"><span class="pre">Timestamp</span></code> is
unavoidable. The only way to achieve exact precision is to use a fixed-width
types (e.g. an int64).</p>
<pre class="literal-block">In [62]: pd.to_datetime([1490195805.433, 1490195805.433502912], unit='s')
Out[62]: DatetimeIndex(['2017-03-22 15:16:45.433000088', '2017-03-22 15:16:45.433502913'], dtype='datetime64[ns]', freq=None)

In [63]: pd.to_datetime(1490195805433502912, unit='ns')
Out[63]: Timestamp('2017-03-22 15:16:45.433502912')</pre>
</div>
<div class="alert alert-info">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#timeseries-origin"><span class="std std-ref">Using the origin Parameter</span></a></p>
</div>
</div>
<div class="section" id="from-timestamps-to-epoch">
<span id="timeseries-converting-epoch-inverse"></span><h3>From Timestamps to Epoch<a class="headerlink" href="#from-timestamps-to-epoch" title="Permalink to this headline">¶</a></h3>
<p>To invert the operation from above, namely, to convert from a <code class="docutils literal notranslate"><span class="pre">Timestamp</span></code> to a ‘unix’ epoch:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [64]: </span><span class="n">stamps</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;2012-10-08 18:15:05&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>

<span class="gp">In [65]: </span><span class="n">stamps</span>
<span class="gh">Out[65]: </span><span class="go"></span>
<span class="go">DatetimeIndex([&#39;2012-10-08 18:15:05&#39;, &#39;2012-10-09 18:15:05&#39;,</span>
<span class="go">               &#39;2012-10-10 18:15:05&#39;, &#39;2012-10-11 18:15:05&#39;],</span>
<span class="go">              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>
</pre></div>
</div>
<p>We subtract the epoch (midnight at January 1, 1970 UTC) and then floor divide by the
“unit” (1 second).</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [66]: </span><span class="p">(</span><span class="n">stamps</span> <span class="o">-</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s2">&quot;1970-01-01&quot;</span><span class="p">))</span> <span class="o">//</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="s1">&#39;1s&#39;</span><span class="p">)</span>
<span class="gh">Out[66]: </span><span class="go">Int64Index([1349720105, 1349806505, 1349892905, 1349979305], dtype=&#39;int64&#39;)</span>
</pre></div>
</div>
</div>
<div class="section" id="using-the-origin-parameter">
<span id="timeseries-origin"></span><h3>Using the <code class="docutils literal notranslate"><span class="pre">origin</span></code> Parameter<a class="headerlink" href="#using-the-origin-parameter" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.0.</span></p>
</div>
<p>Using the <code class="docutils literal notranslate"><span class="pre">origin</span></code> parameter, one can specify an alternative starting point for creation
of a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>. For example, to use 1960-01-01 as the starting date:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [67]: </span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;1960-01-01&#39;</span><span class="p">))</span>
<span class="gh">Out[67]: </span><span class="go">DatetimeIndex([&#39;1960-01-02&#39;, &#39;1960-01-03&#39;, &#39;1960-01-04&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</span>
</pre></div>
</div>
<p>The default is set at <code class="docutils literal notranslate"><span class="pre">origin='unix'</span></code>, which defaults to <code class="docutils literal notranslate"><span class="pre">1970-01-01</span> <span class="pre">00:00:00</span></code>.
Commonly called ‘unix epoch’ or POSIX time.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [68]: </span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
<span class="gh">Out[68]: </span><span class="go">DatetimeIndex([&#39;1970-01-02&#39;, &#39;1970-01-03&#39;, &#39;1970-01-04&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="generating-ranges-of-timestamps">
<span id="timeseries-daterange"></span><h2>Generating Ranges of Timestamps<a class="headerlink" href="#generating-ranges-of-timestamps" title="Permalink to this headline">¶</a></h2>
<p>To generate an index with timestamps, you can use either the <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> or
<code class="docutils literal notranslate"><span class="pre">Index</span></code> constructor and pass in a list of datetime objects:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [69]: </span><span class="n">dates</span> <span class="o">=</span> <span class="p">[</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">   ....: </span>         <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">   ....: </span>         <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="gp">   ....: </span>

<span class="go"># Note the frequency information</span>
<span class="gp">In [70]: </span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">dates</span><span class="p">)</span>

<span class="gp">In [71]: </span><span class="n">index</span>
<span class="gh">Out[71]: </span><span class="go">DatetimeIndex([&#39;2012-05-01&#39;, &#39;2012-05-02&#39;, &#39;2012-05-03&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</span>

<span class="go"># Automatically converted to DatetimeIndex</span>
<span class="gp">In [72]: </span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">dates</span><span class="p">)</span>

<span class="gp">In [73]: </span><span class="n">index</span>
<span class="gh">Out[73]: </span><span class="go">DatetimeIndex([&#39;2012-05-01&#39;, &#39;2012-05-02&#39;, &#39;2012-05-03&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</span>
</pre></div>
</div>
<p>In practice this becomes very cumbersome because we often need a very long
index with a large number of timestamps. If we need timestamps on a regular
frequency, we can use the <a class="reference internal" href="../reference/api/pandas.date_range.html#pandas.date_range" title="pandas.date_range"><code class="xref py py-func docutils literal notranslate"><span class="pre">date_range()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.bdate_range.html#pandas.bdate_range" title="pandas.bdate_range"><code class="xref py py-func docutils literal notranslate"><span class="pre">bdate_range()</span></code></a> functions
to create a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>. The default frequency for <code class="docutils literal notranslate"><span class="pre">date_range</span></code> is a
<strong>calendar day</strong> while the default for <code class="docutils literal notranslate"><span class="pre">bdate_range</span></code> is a <strong>business day</strong>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [74]: </span><span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2011</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="gp">In [75]: </span><span class="n">end</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="gp">In [76]: </span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

<span class="gp">In [77]: </span><span class="n">index</span>
<span class="gh">Out[77]: </span><span class="go"></span>
<span class="go">DatetimeIndex([&#39;2011-01-01&#39;, &#39;2011-01-02&#39;, &#39;2011-01-03&#39;, &#39;2011-01-04&#39;,</span>
<span class="go">               &#39;2011-01-05&#39;, &#39;2011-01-06&#39;, &#39;2011-01-07&#39;, &#39;2011-01-08&#39;,</span>
<span class="go">               &#39;2011-01-09&#39;, &#39;2011-01-10&#39;,</span>
<span class="go">               ...</span>
<span class="go">               &#39;2011-12-23&#39;, &#39;2011-12-24&#39;, &#39;2011-12-25&#39;, &#39;2011-12-26&#39;,</span>
<span class="go">               &#39;2011-12-27&#39;, &#39;2011-12-28&#39;, &#39;2011-12-29&#39;, &#39;2011-12-30&#39;,</span>
<span class="go">               &#39;2011-12-31&#39;, &#39;2012-01-01&#39;],</span>
<span class="go">              dtype=&#39;datetime64[ns]&#39;, length=366, freq=&#39;D&#39;)</span>

<span class="gp">In [78]: </span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">bdate_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

<span class="gp">In [79]: </span><span class="n">index</span>
<span class="gh">Out[79]: </span><span class="go"></span>
<span class="go">DatetimeIndex([&#39;2011-01-03&#39;, &#39;2011-01-04&#39;, &#39;2011-01-05&#39;, &#39;2011-01-06&#39;,</span>
<span class="go">               &#39;2011-01-07&#39;, &#39;2011-01-10&#39;, &#39;2011-01-11&#39;, &#39;2011-01-12&#39;,</span>
<span class="go">               &#39;2011-01-13&#39;, &#39;2011-01-14&#39;,</span>
<span class="go">               ...</span>
<span class="go">               &#39;2011-12-19&#39;, &#39;2011-12-20&#39;, &#39;2011-12-21&#39;, &#39;2011-12-22&#39;,</span>
<span class="go">               &#39;2011-12-23&#39;, &#39;2011-12-26&#39;, &#39;2011-12-27&#39;, &#39;2011-12-28&#39;,</span>
<span class="go">               &#39;2011-12-29&#39;, &#39;2011-12-30&#39;],</span>
<span class="go">              dtype=&#39;datetime64[ns]&#39;, length=260, freq=&#39;B&#39;)</span>
</pre></div>
</div>
<p>Convenience functions like <code class="docutils literal notranslate"><span class="pre">date_range</span></code> and <code class="docutils literal notranslate"><span class="pre">bdate_range</span></code> can utilize a
variety of <a class="reference internal" href="#timeseries-offset-aliases"><span class="std std-ref">frequency aliases</span></a>:</p>
<pre class="literal-block">In [80]: pd.date_range(start, periods=1000, freq='M')
Out[80]: 
DatetimeIndex(['2011-01-31', '2011-02-28', '2011-03-31', '2011-04-30',
               '2011-05-31', '2011-06-30', '2011-07-31', '2011-08-31',
               '2011-09-30', '2011-10-31',
               ...
               '2093-07-31', '2093-08-31', '2093-09-30', '2093-10-31',
               '2093-11-30', '2093-12-31', '2094-01-31', '2094-02-28',
               '2094-03-31', '2094-04-30'],
              dtype='datetime64[ns]', length=1000, freq='M')

In [81]: pd.bdate_range(start, periods=250, freq='BQS')
Out[81]: 
DatetimeIndex(['2011-01-03', '2011-04-01', '2011-07-01', '2011-10-03',
               '2012-01-02', '2012-04-02', '2012-07-02', '2012-10-01',
               '2013-01-01', '2013-04-01',
               ...
               '2071-01-01', '2071-04-01', '2071-07-01', '2071-10-01',
               '2072-01-01', '2072-04-01', '2072-07-01', '2072-10-03',
               '2073-01-02', '2073-04-03'],
              dtype='datetime64[ns]', length=250, freq='BQS-JAN')</pre>
<p><code class="docutils literal notranslate"><span class="pre">date_range</span></code> and <code class="docutils literal notranslate"><span class="pre">bdate_range</span></code> make it easy to generate a range of dates
using various combinations of parameters like <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>, <code class="docutils literal notranslate"><span class="pre">periods</span></code>,
and <code class="docutils literal notranslate"><span class="pre">freq</span></code>. The start and end dates are strictly inclusive, so dates outside
of those specified will not be generated:</p>
<pre class="literal-block">In [82]: pd.date_range(start, end, freq='BM')
Out[82]: 
DatetimeIndex(['2011-01-31', '2011-02-28', '2011-03-31', '2011-04-29',
               '2011-05-31', '2011-06-30', '2011-07-29', '2011-08-31',
               '2011-09-30', '2011-10-31', '2011-11-30', '2011-12-30'],
              dtype='datetime64[ns]', freq='BM')

In [83]: pd.date_range(start, end, freq='W')
Out[83]: 
DatetimeIndex(['2011-01-02', '2011-01-09', '2011-01-16', '2011-01-23',
               '2011-01-30', '2011-02-06', '2011-02-13', '2011-02-20',
               '2011-02-27', '2011-03-06', '2011-03-13', '2011-03-20',
               '2011-03-27', '2011-04-03', '2011-04-10', '2011-04-17',
               '2011-04-24', '2011-05-01', '2011-05-08', '2011-05-15',
               '2011-05-22', '2011-05-29', '2011-06-05', '2011-06-12',
               '2011-06-19', '2011-06-26', '2011-07-03', '2011-07-10',
               '2011-07-17', '2011-07-24', '2011-07-31', '2011-08-07',
               '2011-08-14', '2011-08-21', '2011-08-28', '2011-09-04',
               '2011-09-11', '2011-09-18', '2011-09-25', '2011-10-02',
               '2011-10-09', '2011-10-16', '2011-10-23', '2011-10-30',
               '2011-11-06', '2011-11-13', '2011-11-20', '2011-11-27',
               '2011-12-04', '2011-12-11', '2011-12-18', '2011-12-25',
               '2012-01-01'],
              dtype='datetime64[ns]', freq='W-SUN')

In [84]: pd.bdate_range(end=end, periods=20)
Out[84]: 
DatetimeIndex(['2011-12-05', '2011-12-06', '2011-12-07', '2011-12-08',
               '2011-12-09', '2011-12-12', '2011-12-13', '2011-12-14',
               '2011-12-15', '2011-12-16', '2011-12-19', '2011-12-20',
               '2011-12-21', '2011-12-22', '2011-12-23', '2011-12-26',
               '2011-12-27', '2011-12-28', '2011-12-29', '2011-12-30'],
              dtype='datetime64[ns]', freq='B')

In [85]: pd.bdate_range(start=start, periods=20)
Out[85]: 
DatetimeIndex(['2011-01-03', '2011-01-04', '2011-01-05', '2011-01-06',
               '2011-01-07', '2011-01-10', '2011-01-11', '2011-01-12',
               '2011-01-13', '2011-01-14', '2011-01-17', '2011-01-18',
               '2011-01-19', '2011-01-20', '2011-01-21', '2011-01-24',
               '2011-01-25', '2011-01-26', '2011-01-27', '2011-01-28'],
              dtype='datetime64[ns]', freq='B')</pre>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.23.0.</span></p>
</div>
<p>Specifying <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>, and <code class="docutils literal notranslate"><span class="pre">periods</span></code> will generate a range of evenly spaced
dates from <code class="docutils literal notranslate"><span class="pre">start</span></code> to <code class="docutils literal notranslate"><span class="pre">end</span></code> inclusively, with <code class="docutils literal notranslate"><span class="pre">periods</span></code> number of elements in the
resulting <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>:</p>
<pre class="literal-block">In [86]: pd.date_range('2018-01-01', '2018-01-05', periods=5)
Out[86]: 
DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',
               '2018-01-05'],
              dtype='datetime64[ns]', freq=None)

In [87]: pd.date_range('2018-01-01', '2018-01-05', periods=10)
Out[87]: 
DatetimeIndex(['2018-01-01 00:00:00', '2018-01-01 10:40:00',
               '2018-01-01 21:20:00', '2018-01-02 08:00:00',
               '2018-01-02 18:40:00', '2018-01-03 05:20:00',
               '2018-01-03 16:00:00', '2018-01-04 02:40:00',
               '2018-01-04 13:20:00', '2018-01-05 00:00:00'],
              dtype='datetime64[ns]', freq=None)</pre>
<div class="section" id="custom-frequency-ranges">
<span id="timeseries-custom-freq-ranges"></span><h3>Custom Frequency Ranges<a class="headerlink" href="#custom-frequency-ranges" title="Permalink to this headline">¶</a></h3>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>This functionality was originally exclusive to <code class="docutils literal notranslate"><span class="pre">cdate_range</span></code>, which is
deprecated as of version 0.21.0 in favor of <code class="docutils literal notranslate"><span class="pre">bdate_range</span></code>.  Note that
<code class="docutils literal notranslate"><span class="pre">cdate_range</span></code> only utilizes the <code class="docutils literal notranslate"><span class="pre">weekmask</span></code> and <code class="docutils literal notranslate"><span class="pre">holidays</span></code> parameters
when custom business day, ‘C’, is passed as the frequency string. Support has
been expanded with <code class="docutils literal notranslate"><span class="pre">bdate_range</span></code> to work with any custom frequency string.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.21.0.</span></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">bdate_range</span></code> can also generate a range of custom frequency dates by using
the <code class="docutils literal notranslate"><span class="pre">weekmask</span></code> and <code class="docutils literal notranslate"><span class="pre">holidays</span></code> parameters.  These parameters will only be
used if a custom frequency string is passed.</p>
<pre class="literal-block">In [88]: weekmask = 'Mon Wed Fri'

In [89]: holidays = [datetime.datetime(2011, 1, 5), datetime.datetime(2011, 3, 14)]

In [90]: pd.bdate_range(start, end, freq='C', weekmask=weekmask, holidays=holidays)
Out[90]: 
DatetimeIndex(['2011-01-03', '2011-01-07', '2011-01-10', '2011-01-12',
               '2011-01-14', '2011-01-17', '2011-01-19', '2011-01-21',
               '2011-01-24', '2011-01-26',
               ...
               '2011-12-09', '2011-12-12', '2011-12-14', '2011-12-16',
               '2011-12-19', '2011-12-21', '2011-12-23', '2011-12-26',
               '2011-12-28', '2011-12-30'],
              dtype='datetime64[ns]', length=154, freq='C')

In [91]: pd.bdate_range(start, end, freq='CBMS', weekmask=weekmask)
Out[91]: 
DatetimeIndex(['2011-01-03', '2011-02-02', '2011-03-02', '2011-04-01',
               '2011-05-02', '2011-06-01', '2011-07-01', '2011-08-01',
               '2011-09-02', '2011-10-03', '2011-11-02', '2011-12-02'],
              dtype='datetime64[ns]', freq='CBMS')</pre>
<div class="alert alert-info">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#timeseries-custombusinessdays"><span class="std std-ref">Custom Business Days</span></a></p>
</div>
</div>
</div>
<div class="section" id="timestamp-limitations">
<span id="timeseries-timestamp-limits"></span><h2>Timestamp Limitations<a class="headerlink" href="#timestamp-limitations" title="Permalink to this headline">¶</a></h2>
<p>Since pandas represents timestamps in nanosecond resolution, the time span that
can be represented using a 64-bit integer is limited to approximately 584 years:</p>
<pre class="literal-block">In [92]: pd.Timestamp.min
Out[92]: Timestamp('1677-09-21 00:12:43.145225')

In [93]: pd.Timestamp.max
Out[93]: Timestamp('2262-04-11 23:47:16.854775807')</pre>
<div class="alert alert-info">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#timeseries-oob"><span class="std std-ref">Representing Out-of-Bounds Spans</span></a></p>
</div>
</div>
<div class="section" id="indexing">
<span id="timeseries-datetimeindex"></span><h2>Indexing<a class="headerlink" href="#indexing" title="Permalink to this headline">¶</a></h2>
<p>One of the main uses for <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> is as an index for pandas objects.
The <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> class contains many time series related optimizations:</p>
<ul class="simple">
<li><p>A large range of dates for various offsets are pre-computed and cached
under the hood in order to make generating subsequent date ranges very fast
(just have to grab a slice).</p></li>
<li><p>Fast shifting using the <code class="docutils literal notranslate"><span class="pre">shift</span></code> and <code class="docutils literal notranslate"><span class="pre">tshift</span></code> method on pandas objects.</p></li>
<li><p>Unioning of overlapping <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> objects with the same frequency is
very fast (important for fast data alignment).</p></li>
<li><p>Quick access to date fields via properties such as <code class="docutils literal notranslate"><span class="pre">year</span></code>, <code class="docutils literal notranslate"><span class="pre">month</span></code>, etc.</p></li>
<li><p>Regularization functions like <code class="docutils literal notranslate"><span class="pre">snap</span></code> and very fast <code class="docutils literal notranslate"><span class="pre">asof</span></code> logic.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> objects have all the basic functionality of regular <code class="docutils literal notranslate"><span class="pre">Index</span></code>
objects, and a smorgasbord of advanced time series specific methods for easy
frequency processing.</p>
<div class="alert alert-info">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../getting_started/basics.html#basics-reindexing"><span class="std std-ref">Reindexing methods</span></a></p>
</div>
<div class="alert alert-info">
<p class="admonition-title">Note</p>
<p>While pandas does not force you to have a sorted date index, some of these
methods may have unexpected or incorrect behavior if the dates are unsorted.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> can be used like a regular index and offers all of its
intelligent functionality like selection, slicing, etc.</p>
<pre class="literal-block">In [94]: rng = pd.date_range(start, end, freq='BM')

In [95]: ts = pd.Series(np.random.randn(len(rng)), index=rng)

In [96]: ts.index
Out[96]: 
DatetimeIndex(['2011-01-31', '2011-02-28', '2011-03-31', '2011-04-29',
               '2011-05-31', '2011-06-30', '2011-07-29', '2011-08-31',
               '2011-09-30', '2011-10-31', '2011-11-30', '2011-12-30'],
              dtype='datetime64[ns]', freq='BM')

In [97]: ts[:5].index
Out[97]: 
DatetimeIndex(['2011-01-31', '2011-02-28', '2011-03-31', '2011-04-29',
               '2011-05-31'],
              dtype='datetime64[ns]', freq='BM')

In [98]: ts[::2].index
Out[98]: 
DatetimeIndex(['2011-01-31', '2011-03-31', '2011-05-31', '2011-07-29',
               '2011-09-30', '2011-11-30'],
              dtype='datetime64[ns]', freq='2BM')</pre>
<div class="section" id="partial-string-indexing">
<span id="timeseries-partialindexing"></span><h3>Partial String Indexing<a class="headerlink" href="#partial-string-indexing" title="Permalink to this headline">¶</a></h3>
<p>Dates and strings that parse to timestamps can be passed as indexing parameters:</p>
<pre class="literal-block">In [99]: ts['1/31/2011']
Out[99]: 0.11920871129693428

In [100]: ts[datetime.datetime(2011, 12, 25):]
Out[100]: 
2011-12-30    0.56702
Freq: BM, dtype: float64

In [101]: ts['10/31/2011':'12/31/2011']
Out[101]: 
2011-10-31    0.271860
2011-11-30   -0.424972
2011-12-30    0.567020
Freq: BM, dtype: float64</pre>
<p>To provide convenience for accessing longer time series, you can also pass in
the year or year and month as strings:</p>
<pre class="literal-block">In [102]: ts['2011']
Out[102]: 
2011-01-31    0.119209
2011-02-28   -1.044236
2011-03-31   -0.861849
2011-04-29   -2.104569
2011-05-31   -0.494929
2011-06-30    1.071804
2011-07-29    0.721555
2011-08-31   -0.706771
2011-09-30   -1.039575
2011-10-31    0.271860
2011-11-30   -0.424972
2011-12-30    0.567020
Freq: BM, dtype: float64

In [103]: ts['2011-6']
Out[103]: 
2011-06-30    1.071804
Freq: BM, dtype: float64</pre>
<p>This type of slicing will work on a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> with a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> as well. Since the
partial string selection is a form of label slicing, the endpoints <strong>will be</strong> included. This
would include matching times on an included date:</p>
<pre class="literal-block">In [104]: dft = pd.DataFrame(np.random.randn(100000, 1), columns=['A'],
   .....:                    index=pd.date_range('20130101', periods=100000, freq='T'))
   .....: 

In [105]: dft
Out[105]: 
                            A
2013-01-01 00:00:00  0.276232
2013-01-01 00:01:00 -1.087401
2013-01-01 00:02:00 -0.673690
2013-01-01 00:03:00  0.113648
2013-01-01 00:04:00 -1.478427
...                       ...
2013-03-11 10:35:00 -0.747967
2013-03-11 10:36:00 -0.034523
2013-03-11 10:37:00 -0.201754
2013-03-11 10:38:00 -1.509067
2013-03-11 10:39:00 -1.693043

[100000 rows x 1 columns]

In [106]: dft['2013']
Out[106]: 
                            A
2013-01-01 00:00:00  0.276232
2013-01-01 00:01:00 -1.087401
2013-01-01 00:02:00 -0.673690
2013-01-01 00:03:00  0.113648
2013-01-01 00:04:00 -1.478427
...                       ...
2013-03-11 10:35:00 -0.747967
2013-03-11 10:36:00 -0.034523
2013-03-11 10:37:00 -0.201754
2013-03-11 10:38:00 -1.509067
2013-03-11 10:39:00 -1.693043

[100000 rows x 1 columns]</pre>
<p>This starts on the very first time in the month, and includes the last date and
time for the month:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [107]: </span><span class="n">dft</span><span class="p">[</span><span class="s1">&#39;2013-1&#39;</span><span class="p">:</span><span class="s1">&#39;2013-2&#39;</span><span class="p">]</span>
<span class="gh">Out[107]: </span><span class="go"></span>
<span class="go">                            A</span>
<span class="go">2013-01-01 00:00:00  0.276232</span>
<span class="go">2013-01-01 00:01:00 -1.087401</span>
<span class="go">2013-01-01 00:02:00 -0.673690</span>
<span class="go">2013-01-01 00:03:00  0.113648</span>
<span class="go">2013-01-01 00:04:00 -1.478427</span>
<span class="go">...                       ...</span>
<span class="go">2013-02-28 23:55:00  0.850929</span>
<span class="go">2013-02-28 23:56:00  0.976712</span>
<span class="go">2013-02-28 23:57:00 -2.693884</span>
<span class="go">2013-02-28 23:58:00 -1.575535</span>
<span class="go">2013-02-28 23:59:00 -1.573517</span>

<span class="go">[84960 rows x 1 columns]</span>
</pre></div>
</div>
<p>This specifies a stop time <strong>that includes all of the times on the last day</strong>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [108]: </span><span class="n">dft</span><span class="p">[</span><span class="s1">&#39;2013-1&#39;</span><span class="p">:</span><span class="s1">&#39;2013-2-28&#39;</span><span class="p">]</span>
<span class="gh">Out[108]: </span><span class="go"></span>
<span class="go">                            A</span>
<span class="go">2013-01-01 00:00:00  0.276232</span>
<span class="go">2013-01-01 00:01:00 -1.087401</span>
<span class="go">2013-01-01 00:02:00 -0.673690</span>
<span class="go">2013-01-01 00:03:00  0.113648</span>
<span class="go">2013-01-01 00:04:00 -1.478427</span>
<span class="go">...                       ...</span>
<span class="go">2013-02-28 23:55:00  0.850929</span>
<span class="go">2013-02-28 23:56:00  0.976712</span>
<span class="go">2013-02-28 23:57:00 -2.693884</span>
<span class="go">2013-02-28 23:58:00 -1.575535</span>
<span class="go">2013-02-28 23:59:00 -1.573517</span>

<span class="go">[84960 rows x 1 columns]</span>
</pre></div>
</div>
<p>This specifies an <strong>exact</strong> stop time (and is not the same as the above):</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [109]: </span><span class="n">dft</span><span class="p">[</span><span class="s1">&#39;2013-1&#39;</span><span class="p">:</span><span class="s1">&#39;2013-2-28 00:00:00&#39;</span><span class="p">]</span>
<span class="gh">Out[109]: </span><span class="go"></span>
<span class="go">                            A</span>
<span class="go">2013-01-01 00:00:00  0.276232</span>
<span class="go">2013-01-01 00:01:00 -1.087401</span>
<span class="go">2013-01-01 00:02:00 -0.673690</span>
<span class="go">2013-01-01 00:03:00  0.113648</span>
<span class="go">2013-01-01 00:04:00 -1.478427</span>
<span class="go">...                       ...</span>
<span class="go">2013-02-27 23:56:00  1.197749</span>
<span class="go">2013-02-27 23:57:00  0.720521</span>
<span class="go">2013-02-27 23:58:00 -0.072718</span>
<span class="go">2013-02-27 23:59:00 -0.681192</span>
<span class="go">2013-02-28 00:00:00 -0.557501</span>

<span class="go">[83521 rows x 1 columns]</span>
</pre></div>
</div>
<p>We are stopping on the included end-point as it is part of the index:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [110]: </span><span class="n">dft</span><span class="p">[</span><span class="s1">&#39;2013-1-15&#39;</span><span class="p">:</span><span class="s1">&#39;2013-1-15 12:30:00&#39;</span><span class="p">]</span>
<span class="gh">Out[110]: </span><span class="go"></span>
<span class="go">                            A</span>
<span class="go">2013-01-15 00:00:00 -0.984810</span>
<span class="go">2013-01-15 00:01:00  0.941451</span>
<span class="go">2013-01-15 00:02:00  1.559365</span>
<span class="go">2013-01-15 00:03:00  1.034374</span>
<span class="go">2013-01-15 00:04:00 -1.480656</span>
<span class="go">...                       ...</span>
<span class="go">2013-01-15 12:26:00  0.371454</span>
<span class="go">2013-01-15 12:27:00 -0.930806</span>
<span class="go">2013-01-15 12:28:00 -0.069177</span>
<span class="go">2013-01-15 12:29:00  0.066510</span>
<span class="go">2013-01-15 12:30:00 -0.003945</span>

<span class="go">[751 rows x 1 columns]</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.0.</span></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> partial string indexing also works on a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> with a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>:</p>
<pre class="literal-block">In [111]: dft2 = pd.DataFrame(np.random.randn(20, 1),
   .....:                     columns=['A'],
   .....:                     index=pd.MultiIndex.from_product(
   .....:                         [pd.date_range('20130101', periods=10, freq='12H'),
   .....:                          ['a', 'b']]))
   .....: 

In [112]: dft2
Out[112]: 
                              A
2013-01-01 00:00:00 a -0.298694
                    b  0.823553
2013-01-01 12:00:00 a  0.943285
                    b -1.479399
2013-01-02 00:00:00 a -1.643342
...                         ...
2013-01-04 12:00:00 b  0.069036
2013-01-05 00:00:00 a  0.122297
                    b  1.422060
2013-01-05 12:00:00 a  0.370079
                    b  1.016331

[20 rows x 1 columns]

In [113]: dft2.loc['2013-01-05']
Out[113]: 
                              A
2013-01-05 00:00:00 a  0.122297
                    b  1.422060
2013-01-05 12:00:00 a  0.370079
                    b  1.016331

In [114]: idx = pd.IndexSlice

In [115]: dft2 = dft2.swaplevel(0, 1).sort_index()

In [116]: dft2.loc[idx[:, '2013-01-05'], :]
Out[116]: 
                              A
a 2013-01-05 00:00:00  0.122297
  2013-01-05 12:00:00  0.370079
b 2013-01-05 00:00:00  1.422060
  2013-01-05 12:00:00  1.016331</pre>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.25.0.</span></p>
</div>
<p>Slicing with string indexing also honors UTC offset.</p>
<pre class="literal-block">In [117]: df = pd.DataFrame([0], index=pd.DatetimeIndex(['2019-01-01'], tz='US/Pacific'))

In [118]: df
Out[118]: 
                           0
2019-01-01 00:00:00-08:00  0

In [119]: df['2019-01-01 12:00:00+04:00':'2019-01-01 13:00:00+04:00']
Out[119]: 
                           0
2019-01-01 00:00:00-08:00  0</pre>
</div>
<div class="section" id="slice-vs-exact-match">
<span id="timeseries-slice-vs-exact-match"></span><h3>Slice vs. Exact Match<a class="headerlink" href="#slice-vs-exact-match" title="Permalink to this headline">¶</a></h3>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.20.0.</span></p>
</div>
<p>The same string used as an indexing parameter can be treated either as a slice or as an exact match depending on the resolution of the index. If the string is less accurate than the index, it will be treated as a slice, otherwise as an exact match.</p>
<p>Consider a <code class="docutils literal notranslate"><span class="pre">Series</span></code> object with a minute resolution index:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [120]: </span><span class="n">series_minute</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">   .....: </span>                          <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">([</span><span class="s1">&#39;2011-12-31 23:59:00&#39;</span><span class="p">,</span>
<span class="gp">   .....: </span>                                            <span class="s1">&#39;2012-01-01 00:00:00&#39;</span><span class="p">,</span>
<span class="gp">   .....: </span>                                            <span class="s1">&#39;2012-01-01 00:02:00&#39;</span><span class="p">]))</span>
<span class="gp">   .....: </span>

<span class="gp">In [121]: </span><span class="n">series_minute</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">resolution</span>
<span class="gh">Out[121]: </span><span class="go">&#39;minute&#39;</span>
</pre></div>
</div>
<p>A timestamp string less accurate than a minute gives a <code class="docutils literal notranslate"><span class="pre">Series</span></code> object.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [122]: </span><span class="n">series_minute</span><span class="p">[</span><span class="s1">&#39;2011-12-31 23&#39;</span><span class="p">]</span>
<span class="gh">Out[122]: </span><span class="go"></span>
<span class="go">2011-12-31 23:59:00    1</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>A timestamp string with minute resolution (or more accurate), gives a scalar instead, i.e. it is not casted to a slice.</p>
<pre class="literal-block">In [123]: series_minute['2011-12-31 23:59']
Out[123]: 1

In [124]: series_minute['2011-12-31 23:59:00']
Out[124]: 1</pre>
<p>If index resolution is second, then the minute-accurate timestamp gives a
<code class="docutils literal notranslate"><span class="pre">Series</span></code>.</p>
<pre class="literal-block">In [125]: series_second = pd.Series([1, 2, 3],
   .....:                           pd.DatetimeIndex(['2011-12-31 23:59:59',
   .....:                                             '2012-01-01 00:00:00',
   .....:                                             '2012-01-01 00:00:01']))
   .....: 

In [126]: series_second.index.resolution
Out[126]: 'second'

In [127]: series_second['2011-12-31 23:59']
Out[127]: 
2011-12-31 23:59:59    1
dtype: int64</pre>
<p>If the timestamp string is treated as a slice, it can be used to index <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> with <code class="docutils literal notranslate"><span class="pre">[]</span></code> as well.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [128]: </span><span class="n">dft_minute</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]},</span>
<span class="gp">   .....: </span>                          <span class="n">index</span><span class="o">=</span><span class="n">series_minute</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
<span class="gp">   .....: </span>

<span class="gp">In [129]: </span><span class="n">dft_minute</span><span class="p">[</span><span class="s1">&#39;2011-12-31 23&#39;</span><span class="p">]</span>
<span class="gh">Out[129]: </span><span class="go"></span>
<span class="go">                     a  b</span>
<span class="go">2011-12-31 23:59:00  1  4</span>
</pre></div>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>However, if the string is treated as an exact match, the selection in <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>’s <code class="docutils literal notranslate"><span class="pre">[]</span></code> will be column-wise and not row-wise, see <a class="reference internal" href="indexing.html#indexing-basics"><span class="std std-ref">Indexing Basics</span></a>. For example <code class="docutils literal notranslate"><span class="pre">dft_minute['2011-12-31</span> <span class="pre">23:59']</span></code> will raise <code class="docutils literal notranslate"><span class="pre">KeyError</span></code> as <code class="docutils literal notranslate"><span class="pre">'2012-12-31</span> <span class="pre">23:59'</span></code> has the same resolution as the index and there is no column with such name:</p>
<p>To <em>always</em> have unambiguous selection, whether the row is treated as a slice or a single selection, use <code class="docutils literal notranslate"><span class="pre">.loc</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [130]: </span><span class="n">dft_minute</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;2011-12-31 23:59&#39;</span><span class="p">]</span>
<span class="gh">Out[130]: </span><span class="go"></span>
<span class="go">a    1</span>
<span class="go">b    4</span>
<span class="go">Name: 2011-12-31 23:59:00, dtype: int64</span>
</pre></div>
</div>
</div>
<p>Note also that <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> resolution cannot be less precise than day.</p>
<pre class="literal-block">In [131]: series_monthly = pd.Series([1, 2, 3],
   .....:                            pd.DatetimeIndex(['2011-12', '2012-01', '2012-02']))
   .....: 

In [132]: series_monthly.index.resolution
Out[132]: 'day'

In [133]: series_monthly['2011-12']  # returns Series
Out[133]: 
2011-12-01    1
dtype: int64</pre>
</div>
<div class="section" id="exact-indexing">
<h3>Exact Indexing<a class="headerlink" href="#exact-indexing" title="Permalink to this headline">¶</a></h3>
<p>As discussed in previous section, indexing a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> with a partial string depends on the “accuracy” of the period, in other words how specific the interval is in relation to the resolution of the index. In contrast, indexing with <code class="docutils literal notranslate"><span class="pre">Timestamp</span></code> or <code class="docutils literal notranslate"><span class="pre">datetime</span></code> objects is exact, because the objects have exact meaning. These also follow the semantics of <em>including both endpoints</em>.</p>
<p>These <code class="docutils literal notranslate"><span class="pre">Timestamp</span></code> and <code class="docutils literal notranslate"><span class="pre">datetime</span></code> objects have exact <code class="docutils literal notranslate"><span class="pre">hours,</span> <span class="pre">minutes,</span></code> and <code class="docutils literal notranslate"><span class="pre">seconds</span></code>, even though they were not explicitly specified (they are <code class="docutils literal notranslate"><span class="pre">0</span></code>).</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [134]: </span><span class="n">dft</span><span class="p">[</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">28</span><span class="p">)]</span>
<span class="gh">Out[134]: </span><span class="go"></span>
<span class="go">                            A</span>
<span class="go">2013-01-01 00:00:00  0.276232</span>
<span class="go">2013-01-01 00:01:00 -1.087401</span>
<span class="go">2013-01-01 00:02:00 -0.673690</span>
<span class="go">2013-01-01 00:03:00  0.113648</span>
<span class="go">2013-01-01 00:04:00 -1.478427</span>
<span class="go">...                       ...</span>
<span class="go">2013-02-27 23:56:00  1.197749</span>
<span class="go">2013-02-27 23:57:00  0.720521</span>
<span class="go">2013-02-27 23:58:00 -0.072718</span>
<span class="go">2013-02-27 23:59:00 -0.681192</span>
<span class="go">2013-02-28 00:00:00 -0.557501</span>

<span class="go">[83521 rows x 1 columns]</span>
</pre></div>
</div>
<p>With no defaults.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [135]: </span><span class="n">dft</span><span class="p">[</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
<span class="gp">   .....: </span>    <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
<span class="gp">   .....: </span>
<span class="gh">Out[135]: </span><span class="go"></span>
<span class="go">                            A</span>
<span class="go">2013-01-01 10:12:00  0.565375</span>
<span class="go">2013-01-01 10:13:00  0.068184</span>
<span class="go">2013-01-01 10:14:00  0.788871</span>
<span class="go">2013-01-01 10:15:00 -0.280343</span>
<span class="go">2013-01-01 10:16:00  0.931536</span>
<span class="go">...                       ...</span>
<span class="go">2013-02-28 10:08:00  0.148098</span>
<span class="go">2013-02-28 10:09:00 -0.388138</span>
<span class="go">2013-02-28 10:10:00  0.139348</span>
<span class="go">2013-02-28 10:11:00  0.085288</span>
<span class="go">2013-02-28 10:12:00  0.950146</span>

<span class="go">[83521 rows x 1 columns]</span>
</pre></div>
</div>
</div>
<div class="section" id="truncating-fancy-indexing">
<h3>Truncating &amp; Fancy Indexing<a class="headerlink" href="#truncating-fancy-indexing" title="Permalink to this headline">¶</a></h3>
<p>A <a class="reference internal" href="../reference/api/pandas.DataFrame.truncate.html#pandas.DataFrame.truncate" title="pandas.DataFrame.truncate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">truncate()</span></code></a> convenience function is provided that is similar
to slicing. Note that <code class="docutils literal notranslate"><span class="pre">truncate</span></code> assumes a 0 value for any unspecified date
component in a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> in contrast to slicing which returns any
partially matching dates:</p>
<pre class="literal-block">In [136]: rng2 = pd.date_range('2011-01-01', '2012-01-01', freq='W')

In [137]: ts2 = pd.Series(np.random.randn(len(rng2)), index=rng2)

In [138]: ts2.truncate(before='2011-11', after='2011-12')
Out[138]: 
2011-11-06    0.437823
2011-11-13   -0.293083
2011-11-20   -0.059881
2011-11-27    1.252450
Freq: W-SUN, dtype: float64

In [139]: ts2['2011-11':'2011-12']
Out[139]: 
2011-11-06    0.437823
2011-11-13   -0.293083
2011-11-20   -0.059881
2011-11-27    1.252450
2011-12-04    0.046611
2011-12-11    0.059478
2011-12-18   -0.286539
2011-12-25    0.841669
Freq: W-SUN, dtype: float64</pre>
<p>Even complicated fancy indexing that breaks the <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> frequency
regularity will result in a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>, although frequency is lost:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [140]: </span><span class="n">ts2</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span>
<span class="gh">Out[140]: </span><span class="go">DatetimeIndex([&#39;2011-01-02&#39;, &#39;2011-01-16&#39;, &#39;2011-02-13&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="iterating-through-groups">
<span id="timeseries-iterating-label"></span><h2>Iterating through groups<a class="headerlink" href="#iterating-through-groups" title="Permalink to this headline">¶</a></h2>
<p>With the <code class="docutils literal notranslate"><span class="pre">Resampler</span></code> object in hand, iterating through the grouped data is very
natural and functions similarly to <a class="reference external" href="https://docs.python.org/3/library/itertools.html#itertools.groupby" title="(in Python v3.8)"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.groupby()</span></code></a>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [141]: </span><span class="n">small</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
<span class="gp">   .....: </span>    <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
<span class="gp">   .....: </span>    <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">([</span><span class="s1">&#39;2017-01-01T00:00:00&#39;</span><span class="p">,</span>
<span class="gp">   .....: </span>                          <span class="s1">&#39;2017-01-01T00:30:00&#39;</span><span class="p">,</span>
<span class="gp">   .....: </span>                          <span class="s1">&#39;2017-01-01T00:31:00&#39;</span><span class="p">,</span>
<span class="gp">   .....: </span>                          <span class="s1">&#39;2017-01-01T01:00:00&#39;</span><span class="p">,</span>
<span class="gp">   .....: </span>                          <span class="s1">&#39;2017-01-01T03:00:00&#39;</span><span class="p">,</span>
<span class="gp">   .....: </span>                          <span class="s1">&#39;2017-01-01T03:05:00&#39;</span><span class="p">])</span>
<span class="gp">   .....: </span><span class="p">)</span>
<span class="gp">   .....: </span>

<span class="gp">In [142]: </span><span class="n">resampled</span> <span class="o">=</span> <span class="n">small</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>

<span class="gp">In [143]: </span><span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">resampled</span><span class="p">:</span>
<span class="gp">   .....: </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Group: &quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="gp">   .....: </span>    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">27</span><span class="p">)</span>
<span class="gp">   .....: </span>    <span class="k">print</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">   .....: </span>
<span class="go">Group:  2017-01-01 00:00:00</span>
<span class="gt">---------------------------</span>
<span class="mi">2017</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mo">01</span> <span class="mo">00</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mo">00</span>    <span class="mi">0</span>
<span class="mi">2017</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mo">01</span> <span class="mo">00</span><span class="p">:</span><span class="mi">30</span><span class="p">:</span><span class="mo">00</span>    <span class="mi">1</span>
<span class="mi">2017</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mo">01</span> <span class="mo">00</span><span class="p">:</span><span class="mi">31</span><span class="p">:</span><span class="mo">00</span>    <span class="mi">2</span>
<span class="ne">dtype</span>: int64

<span class="ne">Group</span>:  2017-01-01 01:00:00
<span class="gt">---------------------------</span>
<span class="mi">2017</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mo">01</span> <span class="mo">01</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mo">00</span>    <span class="mi">3</span>
<span class="ne">dtype</span>: int64

<span class="ne">Group</span>:  2017-01-01 02:00:00
<span class="gt">---------------------------</span>
<span class="n">Series</span><span class="p">([],</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">int64</span><span class="p">)</span>

<span class="ne">Group</span>:  2017-01-01 03:00:00
<span class="gt">---------------------------</span>
<span class="mi">2017</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mo">01</span> <span class="mo">03</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mo">00</span>    <span class="mi">4</span>
<span class="mi">2017</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mo">01</span> <span class="mo">03</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">00</span>    <span class="mi">5</span>
<span class="ne">dtype</span>: int64
</pre></div>
</div>
<p>See <a class="reference internal" href="groupby.html#groupby-iterating-label"><span class="std std-ref">Iterating through groups</span></a> or <code class="xref py py-class docutils literal notranslate"><span class="pre">Resampler.__iter__</span></code> for more.</p>
</div>
<div class="section" id="time-date-components">
<span id="timeseries-components"></span><h2>Time/Date Components<a class="headerlink" href="#time-date-components" title="Permalink to this headline">¶</a></h2>
<p>There are several time/date properties that one can access from <code class="docutils literal notranslate"><span class="pre">Timestamp</span></code> or a collection of timestamps like a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>.</p>
<table class="colwidths-given table">
<colgroup>
<col style="width: 19%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>year</p></td>
<td><p>The year of the datetime</p></td>
</tr>
<tr class="row-odd"><td><p>month</p></td>
<td><p>The month of the datetime</p></td>
</tr>
<tr class="row-even"><td><p>day</p></td>
<td><p>The days of the datetime</p></td>
</tr>
<tr class="row-odd"><td><p>hour</p></td>
<td><p>The hour of the datetime</p></td>
</tr>
<tr class="row-even"><td><p>minute</p></td>
<td><p>The minutes of the datetime</p></td>
</tr>
<tr class="row-odd"><td><p>second</p></td>
<td><p>The seconds of the datetime</p></td>
</tr>
<tr class="row-even"><td><p>microsecond</p></td>
<td><p>The microseconds of the datetime</p></td>
</tr>
<tr class="row-odd"><td><p>nanosecond</p></td>
<td><p>The nanoseconds of the datetime</p></td>
</tr>
<tr class="row-even"><td><p>date</p></td>
<td><p>Returns datetime.date (does not contain timezone information)</p></td>
</tr>
<tr class="row-odd"><td><p>time</p></td>
<td><p>Returns datetime.time (does not contain timezone information)</p></td>
</tr>
<tr class="row-even"><td><p>timetz</p></td>
<td><p>Returns datetime.time as local time with timezone information</p></td>
</tr>
<tr class="row-odd"><td><p>dayofyear</p></td>
<td><p>The ordinal day of year</p></td>
</tr>
<tr class="row-even"><td><p>weekofyear</p></td>
<td><p>The week ordinal of the year</p></td>
</tr>
<tr class="row-odd"><td><p>week</p></td>
<td><p>The week ordinal of the year</p></td>
</tr>
<tr class="row-even"><td><p>dayofweek</p></td>
<td><p>The number of the day of the week with Monday=0, Sunday=6</p></td>
</tr>
<tr class="row-odd"><td><p>weekday</p></td>
<td><p>The number of the day of the week with Monday=0, Sunday=6</p></td>
</tr>
<tr class="row-even"><td><p>weekday_name</p></td>
<td><p>The name of the day in a week (ex: Friday)</p></td>
</tr>
<tr class="row-odd"><td><p>quarter</p></td>
<td><p>Quarter of the date: Jan-Mar = 1, Apr-Jun = 2, etc.</p></td>
</tr>
<tr class="row-even"><td><p>days_in_month</p></td>
<td><p>The number of days in the month of the datetime</p></td>
</tr>
<tr class="row-odd"><td><p>is_month_start</p></td>
<td><p>Logical indicating if first day of month (defined by frequency)</p></td>
</tr>
<tr class="row-even"><td><p>is_month_end</p></td>
<td><p>Logical indicating if last day of month (defined by frequency)</p></td>
</tr>
<tr class="row-odd"><td><p>is_quarter_start</p></td>
<td><p>Logical indicating if first day of quarter (defined by frequency)</p></td>
</tr>
<tr class="row-even"><td><p>is_quarter_end</p></td>
<td><p>Logical indicating if last day of quarter (defined by frequency)</p></td>
</tr>
<tr class="row-odd"><td><p>is_year_start</p></td>
<td><p>Logical indicating if first day of year (defined by frequency)</p></td>
</tr>
<tr class="row-even"><td><p>is_year_end</p></td>
<td><p>Logical indicating if last day of year (defined by frequency)</p></td>
</tr>
<tr class="row-odd"><td><p>is_leap_year</p></td>
<td><p>Logical indicating if the date belongs to a leap year</p></td>
</tr>
</tbody>
</table>
<p>Furthermore, if you have a <code class="docutils literal notranslate"><span class="pre">Series</span></code> with datetimelike values, then you can
access these properties via the <code class="docutils literal notranslate"><span class="pre">.dt</span></code> accessor, as detailed in the section
on <a class="reference internal" href="../getting_started/basics.html#basics-dt-accessors"><span class="std std-ref">.dt accessors</span></a>.</p>
</div>
<div class="section" id="dateoffset-objects">
<span id="timeseries-offsets"></span><h2>DateOffset Objects<a class="headerlink" href="#dateoffset-objects" title="Permalink to this headline">¶</a></h2>
<p>In the preceding examples, frequency strings (e.g. <code class="docutils literal notranslate"><span class="pre">'D'</span></code>) were used to specify
a frequency that defined:</p>
<ul class="simple">
<li><p>how the date times in <code class="xref py py-class docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> were spaced when using <a class="reference internal" href="../reference/api/pandas.date_range.html#pandas.date_range" title="pandas.date_range"><code class="xref py py-meth docutils literal notranslate"><span class="pre">date_range()</span></code></a></p></li>
<li><p>the frequency of a <code class="xref py py-class docutils literal notranslate"><span class="pre">Period</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">PeriodIndex</span></code></p></li>
</ul>
<p>These frequency strings map to a <code class="xref py py-class docutils literal notranslate"><span class="pre">DateOffset</span></code> object and its subclasses. A <code class="xref py py-class docutils literal notranslate"><span class="pre">DateOffset</span></code>
is similar to a <code class="xref py py-class docutils literal notranslate"><span class="pre">Timedelta</span></code> that represents a duration of time but follows specific calendar duration rules.
For example, a <code class="xref py py-class docutils literal notranslate"><span class="pre">Timedelta</span></code> day will always increment <code class="docutils literal notranslate"><span class="pre">datetimes</span></code> by 24 hours, while a <code class="xref py py-class docutils literal notranslate"><span class="pre">DateOffset</span></code> day
will increment <code class="docutils literal notranslate"><span class="pre">datetimes</span></code> to the same time the next day whether a day represents 23, 24 or 25 hours due to daylight
savings time. However, all <code class="xref py py-class docutils literal notranslate"><span class="pre">DateOffset</span></code> subclasses that are an hour or smaller
(<code class="docutils literal notranslate"><span class="pre">Hour</span></code>, <code class="docutils literal notranslate"><span class="pre">Minute</span></code>, <code class="docutils literal notranslate"><span class="pre">Second</span></code>, <code class="docutils literal notranslate"><span class="pre">Milli</span></code>, <code class="docutils literal notranslate"><span class="pre">Micro</span></code>, <code class="docutils literal notranslate"><span class="pre">Nano</span></code>) behave like
<code class="xref py py-class docutils literal notranslate"><span class="pre">Timedelta</span></code> and respect absolute time.</p>
<p>The basic <code class="xref py py-class docutils literal notranslate"><span class="pre">DateOffset</span></code> acts similar to <code class="docutils literal notranslate"><span class="pre">dateutil.relativedelta</span></code> (<a class="reference external" href="https://dateutil.readthedocs.io/en/stable/relativedelta.html">relativedelta documentation</a>)
that shifts a date time by the corresponding calendar duration specified. The
arithmetic operator (<code class="docutils literal notranslate"><span class="pre">+</span></code>) or the <code class="docutils literal notranslate"><span class="pre">apply</span></code> method can be used to perform the shift.</p>
<pre class="literal-block"># This particular day contains a day light savings time transition
In [144]: ts = pd.Timestamp('2016-10-30 00:00:00', tz='Europe/Helsinki')

# Respects absolute time
In [145]: ts + pd.Timedelta(days=1)
Out[145]: Timestamp('2016-10-30 23:00:00+0200', tz='Europe/Helsinki')

# Respects calendar time
In [146]: ts + pd.DateOffset(days=1)
Out[146]: Timestamp('2016-10-31 00:00:00+0200', tz='Europe/Helsinki')

In [147]: friday = pd.Timestamp('2018-01-05')

In [148]: friday.day_name()
Out[148]: 'Friday'

# Add 2 business days (Friday --&gt; Tuesday)
In [149]: two_business_days = 2 * pd.offsets.BDay()

In [150]: two_business_days.apply(friday)
Out[150]: Timestamp('2018-01-09 00:00:00')

In [151]: friday + two_business_days
Out[151]: Timestamp('2018-01-09 00:00:00')

In [152]: (friday + two_business_days).day_name()
Out[152]: 'Tuesday'</pre>
<p>Most <code class="docutils literal notranslate"><span class="pre">DateOffsets</span></code> have associated frequencies strings, or offset aliases, that can be passed
into <code class="docutils literal notranslate"><span class="pre">freq</span></code> keyword arguments. The available date offsets and associated frequency strings can be found below:</p>
<table class="colwidths-given table">
<colgroup>
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Date Offset</p></th>
<th class="head"><p>Frequency String</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">DateOffset</span></code></p></td>
<td><p>None</p></td>
<td><p>Generic offset class, defaults to 1 calendar day</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">BDay</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">BusinessDay</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'B'</span></code></p></td>
<td><p>business day (weekday)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">CDay</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">CustomBusinessDay</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'C'</span></code></p></td>
<td><p>custom business day</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Week</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'W'</span></code></p></td>
<td><p>one week, optionally anchored on a day of the week</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">WeekOfMonth</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'WOM'</span></code></p></td>
<td><p>the x-th day of the y-th week of each month</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">LastWeekOfMonth</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'LWOM'</span></code></p></td>
<td><p>the x-th day of the last week of each month</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">MonthEnd</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'M'</span></code></p></td>
<td><p>calendar month end</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">MonthBegin</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'MS'</span></code></p></td>
<td><p>calendar month begin</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">BMonthEnd</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">BusinessMonthEnd</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'BM'</span></code></p></td>
<td><p>business month end</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">BMonthBegin</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">BusinessMonthBegin</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'BMS'</span></code></p></td>
<td><p>business month begin</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">CBMonthEnd</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">CustomBusinessMonthEnd</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'CBM'</span></code></p></td>
<td><p>custom business month end</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">CBMonthBegin</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">CustomBusinessMonthBegin</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'CBMS'</span></code></p></td>
<td><p>custom business month begin</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">SemiMonthEnd</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'SM'</span></code></p></td>
<td><p>15th (or other day_of_month) and calendar month end</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">SemiMonthBegin</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'SMS'</span></code></p></td>
<td><p>15th (or other day_of_month) and calendar month begin</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">QuarterEnd</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'Q'</span></code></p></td>
<td><p>calendar quarter end</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">QuarterBegin</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'QS'</span></code></p></td>
<td><p>calendar quarter begin</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">BQuarterEnd</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'BQ</span></code></p></td>
<td><p>business quarter end</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">BQuarterBegin</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'BQS'</span></code></p></td>
<td><p>business quarter begin</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">FY5253Quarter</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'REQ'</span></code></p></td>
<td><p>retail (aka 52-53 week) quarter</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">YearEnd</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'A'</span></code></p></td>
<td><p>calendar year end</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">YearBegin</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'AS'</span></code> or <code class="docutils literal notranslate"><span class="pre">'BYS'</span></code></p></td>
<td><p>calendar year begin</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">BYearEnd</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'BA'</span></code></p></td>
<td><p>business year end</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">BYearBegin</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'BAS'</span></code></p></td>
<td><p>business year begin</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">FY5253</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'RE'</span></code></p></td>
<td><p>retail (aka 52-53 week) year</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Easter</span></code></p></td>
<td><p>None</p></td>
<td><p>Easter holiday</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">BusinessHour</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'BH'</span></code></p></td>
<td><p>business hour</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">CustomBusinessHour</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'CBH'</span></code></p></td>
<td><p>custom business hour</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Day</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'D'</span></code></p></td>
<td><p>one absolute day</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Hour</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'H'</span></code></p></td>
<td><p>one hour</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Minute</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'T'</span></code> or <code class="docutils literal notranslate"><span class="pre">'min'</span></code></p></td>
<td><p>one minute</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Second</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'S'</span></code></p></td>
<td><p>one second</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Milli</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'L'</span></code> or <code class="docutils literal notranslate"><span class="pre">'ms'</span></code></p></td>
<td><p>one millisecond</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Micro</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'U'</span></code> or <code class="docutils literal notranslate"><span class="pre">'us'</span></code></p></td>
<td><p>one microsecond</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Nano</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'N'</span></code></p></td>
<td><p>one nanosecond</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">DateOffsets</span></code> additionally have <code class="xref py py-meth docutils literal notranslate"><span class="pre">rollforward()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">rollback()</span></code>
methods for moving a date forward or backward respectively to a valid offset
date relative to the offset. For example, business offsets will roll dates
that land on the weekends (Saturday and Sunday) forward to Monday since
business offsets operate on the weekdays.</p>
<pre class="literal-block">In [153]: ts = pd.Timestamp('2018-01-06 00:00:00')

In [154]: ts.day_name()
Out[154]: 'Saturday'

# BusinessHour's valid offset dates are Monday through Friday
In [155]: offset = pd.offsets.BusinessHour(start='09:00')

# Bring the date to the closest offset date (Monday)
In [156]: offset.rollforward(ts)
Out[156]: Timestamp('2018-01-08 09:00:00')

# Date is brought to the closest offset date first and then the hour is added
In [157]: ts + offset
Out[157]: Timestamp('2018-01-08 10:00:00')</pre>
<p>These operations preserve time (hour, minute, etc) information by default.
To reset time to midnight, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">normalize()</span></code> before or after applying
the operation (depending on whether you want the time information included
in the operation).</p>
<pre class="literal-block">In [158]: ts = pd.Timestamp('2014-01-01 09:00')

In [159]: day = pd.offsets.Day()

In [160]: day.apply(ts)
Out[160]: Timestamp('2014-01-02 09:00:00')

In [161]: day.apply(ts).normalize()
Out[161]: Timestamp('2014-01-02 00:00:00')

In [162]: ts = pd.Timestamp('2014-01-01 22:00')

In [163]: hour = pd.offsets.Hour()

In [164]: hour.apply(ts)
Out[164]: Timestamp('2014-01-01 23:00:00')

In [165]: hour.apply(ts).normalize()
Out[165]: Timestamp('2014-01-01 00:00:00')

In [166]: hour.apply(pd.Timestamp(&quot;2014-01-01 23:30&quot;)).normalize()
Out[166]: Timestamp('2014-01-02 00:00:00')</pre>
<div class="section" id="parametric-offsets">
<h3>Parametric Offsets<a class="headerlink" href="#parametric-offsets" title="Permalink to this headline">¶</a></h3>
<p>Some of the offsets can be “parameterized” when created to result in different
behaviors. For example, the <code class="docutils literal notranslate"><span class="pre">Week</span></code> offset for generating weekly data accepts a
<code class="docutils literal notranslate"><span class="pre">weekday</span></code> parameter which results in the generated dates always lying on a
particular day of the week:</p>
<pre class="literal-block">In [167]: d = datetime.datetime(2008, 8, 18, 9, 0)

In [168]: d
Out[168]: datetime.datetime(2008, 8, 18, 9, 0)

In [169]: d + pd.offsets.Week()
Out[169]: Timestamp('2008-08-25 09:00:00')

In [170]: d + pd.offsets.Week(weekday=4)
Out[170]: Timestamp('2008-08-22 09:00:00')

In [171]: (d + pd.offsets.Week(weekday=4)).weekday()
Out[171]: 4

In [172]: d - pd.offsets.Week()
Out[172]: Timestamp('2008-08-11 09:00:00')</pre>
<p>The <code class="docutils literal notranslate"><span class="pre">normalize</span></code> option will be effective for addition and subtraction.</p>
<pre class="literal-block">In [173]: d + pd.offsets.Week(normalize=True)
Out[173]: Timestamp('2008-08-25 00:00:00')

In [174]: d - pd.offsets.Week(normalize=True)
Out[174]: Timestamp('2008-08-11 00:00:00')</pre>
<p>Another example is parameterizing <code class="docutils literal notranslate"><span class="pre">YearEnd</span></code> with the specific ending month:</p>
<pre class="literal-block">In [175]: d + pd.offsets.YearEnd()
Out[175]: Timestamp('2008-12-31 09:00:00')

In [176]: d + pd.offsets.YearEnd(month=6)
Out[176]: Timestamp('2009-06-30 09:00:00')</pre>
</div>
<div class="section" id="using-offsets-with-series-datetimeindex">
<span id="timeseries-offsetseries"></span><h3>Using Offsets with <code class="docutils literal notranslate"><span class="pre">Series</span></code> / <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code><a class="headerlink" href="#using-offsets-with-series-datetimeindex" title="Permalink to this headline">¶</a></h3>
<p>Offsets can be used with either a <code class="docutils literal notranslate"><span class="pre">Series</span></code> or <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> to
apply the offset to each element.</p>
<pre class="literal-block">In [177]: rng = pd.date_range('2012-01-01', '2012-01-03')

In [178]: s = pd.Series(rng)

In [179]: rng
Out[179]: DatetimeIndex(['2012-01-01', '2012-01-02', '2012-01-03'], dtype='datetime64[ns]', freq='D')

In [180]: rng + pd.DateOffset(months=2)
Out[180]: DatetimeIndex(['2012-03-01', '2012-03-02', '2012-03-03'], dtype='datetime64[ns]', freq='D')

In [181]: s + pd.DateOffset(months=2)
Out[181]: 
0   2012-03-01
1   2012-03-02
2   2012-03-03
dtype: datetime64[ns]

In [182]: s - pd.DateOffset(months=2)
Out[182]: 
0   2011-11-01
1   2011-11-02
2   2011-11-03
dtype: datetime64[ns]</pre>
<p>If the offset class maps directly to a <code class="docutils literal notranslate"><span class="pre">Timedelta</span></code> (<code class="docutils literal notranslate"><span class="pre">Day</span></code>, <code class="docutils literal notranslate"><span class="pre">Hour</span></code>,
<code class="docutils literal notranslate"><span class="pre">Minute</span></code>, <code class="docutils literal notranslate"><span class="pre">Second</span></code>, <code class="docutils literal notranslate"><span class="pre">Micro</span></code>, <code class="docutils literal notranslate"><span class="pre">Milli</span></code>, <code class="docutils literal notranslate"><span class="pre">Nano</span></code>) it can be
used exactly like a <code class="docutils literal notranslate"><span class="pre">Timedelta</span></code> - see the
<a class="reference internal" href="timedeltas.html#timedeltas-operations"><span class="std std-ref">Timedelta section</span></a> for more examples.</p>
<pre class="literal-block">In [183]: s - pd.offsets.Day(2)
Out[183]: 
0   2011-12-30
1   2011-12-31
2   2012-01-01
dtype: datetime64[ns]

In [184]: td = s - pd.Series(pd.date_range('2011-12-29', '2011-12-31'))

In [185]: td
Out[185]: 
0   3 days
1   3 days
2   3 days
dtype: timedelta64[ns]

In [186]: td + pd.offsets.Minute(15)
Out[186]: 
0   3 days 00:15:00
1   3 days 00:15:00
2   3 days 00:15:00
dtype: timedelta64[ns]</pre>
<p>Note that some offsets (such as <code class="docutils literal notranslate"><span class="pre">BQuarterEnd</span></code>) do not have a
vectorized implementation.  They can still be used but may
calculate significantly slower and will show a <code class="docutils literal notranslate"><span class="pre">PerformanceWarning</span></code></p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [187]: </span><span class="n">rng</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">offsets</span><span class="o">.</span><span class="n">BQuarterEnd</span><span class="p">()</span>
<span class="gh">Out[187]: </span><span class="go">DatetimeIndex([&#39;2012-03-30&#39;, &#39;2012-03-30&#39;, &#39;2012-03-30&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</span>
</pre></div>
</div>
</div>
<div class="section" id="custom-business-days">
<span id="timeseries-custombusinessdays"></span><h3>Custom Business Days<a class="headerlink" href="#custom-business-days" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">CDay</span></code> or <code class="docutils literal notranslate"><span class="pre">CustomBusinessDay</span></code> class provides a parametric
<code class="docutils literal notranslate"><span class="pre">BusinessDay</span></code> class which can be used to create customized business day
calendars which account for local holidays and local weekend conventions.</p>
<p>As an interesting example, let’s look at Egypt where a Friday-Saturday weekend is observed.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [188]: </span><span class="n">weekmask_egypt</span> <span class="o">=</span> <span class="s1">&#39;Sun Mon Tue Wed Thu&#39;</span>

<span class="go"># They also observe International Workers&#39; Day so let&#39;s</span>
<span class="go"># add that for a couple of years</span>
<span class="gp">In [189]: </span><span class="n">holidays</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;2012-05-01&#39;</span><span class="p">,</span>
<span class="gp">   .....: </span>            <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">   .....: </span>            <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;2014-05-01&#39;</span><span class="p">)]</span>
<span class="gp">   .....: </span>

<span class="gp">In [190]: </span><span class="n">bday_egypt</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">offsets</span><span class="o">.</span><span class="n">CustomBusinessDay</span><span class="p">(</span><span class="n">holidays</span><span class="o">=</span><span class="n">holidays</span><span class="p">,</span>
<span class="gp">   .....: </span>                                          <span class="n">weekmask</span><span class="o">=</span><span class="n">weekmask_egypt</span><span class="p">)</span>
<span class="gp">   .....: </span>

<span class="gp">In [191]: </span><span class="n">dt</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2013</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>

<span class="gp">In [192]: </span><span class="n">dt</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">bday_egypt</span>
<span class="gh">Out[192]: </span><span class="go">Timestamp(&#39;2013-05-05 00:00:00&#39;)</span>
</pre></div>
</div>
<p>Let’s map to the weekday names:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [193]: </span><span class="n">dts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">bday_egypt</span><span class="p">)</span>

<span class="gp">In [194]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">dts</span><span class="o">.</span><span class="n">weekday</span><span class="p">,</span> <span class="n">dts</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
<span class="gp">   .....: </span>    <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="s1">&#39;Mon Tue Wed Thu Fri Sat Sun&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
<span class="gp">   .....: </span>
<span class="gh">Out[194]: </span><span class="go"></span>
<span class="go">2013-04-30    Tue</span>
<span class="go">2013-05-02    Thu</span>
<span class="go">2013-05-05    Sun</span>
<span class="go">2013-05-06    Mon</span>
<span class="go">2013-05-07    Tue</span>
<span class="go">Freq: C, dtype: object</span>
</pre></div>
</div>
<p>Holiday calendars can be used to provide the list of holidays.  See the
<a class="reference internal" href="#timeseries-holiday"><span class="std std-ref">holiday calendar</span></a> section for more information.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [195]: </span><span class="kn">from</span> <span class="nn">pandas.tseries.holiday</span> <span class="kn">import</span> <span class="n">USFederalHolidayCalendar</span>

<span class="gp">In [196]: </span><span class="n">bday_us</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">offsets</span><span class="o">.</span><span class="n">CustomBusinessDay</span><span class="p">(</span><span class="n">calendar</span><span class="o">=</span><span class="n">USFederalHolidayCalendar</span><span class="p">())</span>

<span class="go"># Friday before MLK Day</span>
<span class="gp">In [197]: </span><span class="n">dt</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2014</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span>

<span class="go"># Tuesday after MLK Day (Monday is skipped because it&#39;s a holiday)</span>
<span class="gp">In [198]: </span><span class="n">dt</span> <span class="o">+</span> <span class="n">bday_us</span>
<span class="gh">Out[198]: </span><span class="go">Timestamp(&#39;2014-01-21 00:00:00&#39;)</span>
</pre></div>
</div>
<p>Monthly offsets that respect a certain holiday calendar can be defined
in the usual way.</p>
<pre class="literal-block">In [199]: bmth_us = pd.offsets.CustomBusinessMonthBegin(
   .....:     calendar=USFederalHolidayCalendar())
   .....: 

# Skip new years
In [200]: dt = datetime.datetime(2013, 12, 17)

In [201]: dt + bmth_us
Out[201]: Timestamp('2014-01-02 00:00:00')

# Define date index with custom offset
In [202]: pd.date_range(start='20100101', end='20120101', freq=bmth_us)
Out[202]: 
DatetimeIndex(['2010-01-04', '2010-02-01', '2010-03-01', '2010-04-01',
               '2010-05-03', '2010-06-01', '2010-07-01', '2010-08-02',
               '2010-09-01', '2010-10-01', '2010-11-01', '2010-12-01',
               '2011-01-03', '2011-02-01', '2011-03-01', '2011-04-01',
               '2011-05-02', '2011-06-01', '2011-07-01', '2011-08-01',
               '2011-09-01', '2011-10-03', '2011-11-01', '2011-12-01'],
              dtype='datetime64[ns]', freq='CBMS')</pre>
<div class="alert alert-info">
<p class="admonition-title">Note</p>
<p>The frequency string ‘C’ is used to indicate that a CustomBusinessDay
DateOffset is used, it is important to note that since CustomBusinessDay is
a parameterised type, instances of CustomBusinessDay may differ and this is
not detectable from the ‘C’ frequency string. The user therefore needs to
ensure that the ‘C’ frequency string is used consistently within the user’s
application.</p>
</div>
</div>
<div class="section" id="business-hour">
<span id="timeseries-businesshour"></span><h3>Business Hour<a class="headerlink" href="#business-hour" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">BusinessHour</span></code> class provides a business hour representation on <code class="docutils literal notranslate"><span class="pre">BusinessDay</span></code>,
allowing to use specific start and end times.</p>
<p>By default, <code class="docutils literal notranslate"><span class="pre">BusinessHour</span></code> uses 9:00 - 17:00 as business hours.
Adding <code class="docutils literal notranslate"><span class="pre">BusinessHour</span></code> will increment <code class="docutils literal notranslate"><span class="pre">Timestamp</span></code> by hourly frequency.
If target <code class="docutils literal notranslate"><span class="pre">Timestamp</span></code> is out of business hours, move to the next business hour
then increment it. If the result exceeds the business hours end, the remaining
hours are added to the next business day.</p>
<pre class="literal-block">In [203]: bh = pd.offsets.BusinessHour()

In [204]: bh
Out[204]: &lt;BusinessHour: BH=09:00-17:00&gt;

# 2014-08-01 is Friday
In [205]: pd.Timestamp('2014-08-01 10:00').weekday()
Out[205]: 4

In [206]: pd.Timestamp('2014-08-01 10:00') + bh
Out[206]: Timestamp('2014-08-01 11:00:00')

# Below example is the same as: pd.Timestamp('2014-08-01 09:00') + bh
In [207]: pd.Timestamp('2014-08-01 08:00') + bh
Out[207]: Timestamp('2014-08-01 10:00:00')

# If the results is on the end time, move to the next business day
In [208]: pd.Timestamp('2014-08-01 16:00') + bh
Out[208]: Timestamp('2014-08-04 09:00:00')

# Remainings are added to the next day
In [209]: pd.Timestamp('2014-08-01 16:30') + bh
Out[209]: Timestamp('2014-08-04 09:30:00')

# Adding 2 business hours
In [210]: pd.Timestamp('2014-08-01 10:00') + pd.offsets.BusinessHour(2)
Out[210]: Timestamp('2014-08-01 12:00:00')

# Subtracting 3 business hours
In [211]: pd.Timestamp('2014-08-01 10:00') + pd.offsets.BusinessHour(-3)
Out[211]: Timestamp('2014-07-31 15:00:00')</pre>
<p>You can also specify <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">end</span></code> time by keywords. The argument must
be a <code class="docutils literal notranslate"><span class="pre">str</span></code> with an <code class="docutils literal notranslate"><span class="pre">hour:minute</span></code> representation or a <code class="docutils literal notranslate"><span class="pre">datetime.time</span></code>
instance. Specifying seconds, microseconds and nanoseconds as business hour
results in <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
<pre class="literal-block">In [212]: bh = pd.offsets.BusinessHour(start='11:00', end=datetime.time(20, 0))

In [213]: bh
Out[213]: &lt;BusinessHour: BH=11:00-20:00&gt;

In [214]: pd.Timestamp('2014-08-01 13:00') + bh
Out[214]: Timestamp('2014-08-01 14:00:00')

In [215]: pd.Timestamp('2014-08-01 09:00') + bh
Out[215]: Timestamp('2014-08-01 12:00:00')

In [216]: pd.Timestamp('2014-08-01 18:00') + bh
Out[216]: Timestamp('2014-08-01 19:00:00')</pre>
<p>Passing <code class="docutils literal notranslate"><span class="pre">start</span></code> time later than <code class="docutils literal notranslate"><span class="pre">end</span></code> represents midnight business hour.
In this case, business hour exceeds midnight and overlap to the next day.
Valid business hours are distinguished by whether it started from valid <code class="docutils literal notranslate"><span class="pre">BusinessDay</span></code>.</p>
<pre class="literal-block">In [217]: bh = pd.offsets.BusinessHour(start='17:00', end='09:00')

In [218]: bh
Out[218]: &lt;BusinessHour: BH=17:00-09:00&gt;

In [219]: pd.Timestamp('2014-08-01 17:00') + bh
Out[219]: Timestamp('2014-08-01 18:00:00')

In [220]: pd.Timestamp('2014-08-01 23:00') + bh
Out[220]: Timestamp('2014-08-02 00:00:00')

# Although 2014-08-02 is Satuaday,
# it is valid because it starts from 08-01 (Friday).
In [221]: pd.Timestamp('2014-08-02 04:00') + bh
Out[221]: Timestamp('2014-08-02 05:00:00')

# Although 2014-08-04 is Monday,
# it is out of business hours because it starts from 08-03 (Sunday).
In [222]: pd.Timestamp('2014-08-04 04:00') + bh
Out[222]: Timestamp('2014-08-04 18:00:00')</pre>
<p>Applying <code class="docutils literal notranslate"><span class="pre">BusinessHour.rollforward</span></code> and <code class="docutils literal notranslate"><span class="pre">rollback</span></code> to out of business hours results in
the next business hour start or previous day’s end. Different from other offsets, <code class="docutils literal notranslate"><span class="pre">BusinessHour.rollforward</span></code>
may output different results from <code class="docutils literal notranslate"><span class="pre">apply</span></code> by definition.</p>
<p>This is because one day’s business hour end is equal to next day’s business hour start. For example,
under the default business hours (9:00 - 17:00), there is no gap (0 minutes) between <code class="docutils literal notranslate"><span class="pre">2014-08-01</span> <span class="pre">17:00</span></code> and
<code class="docutils literal notranslate"><span class="pre">2014-08-04</span> <span class="pre">09:00</span></code>.</p>
<pre class="literal-block"># This adjusts a Timestamp to business hour edge
In [223]: pd.offsets.BusinessHour().rollback(pd.Timestamp('2014-08-02 15:00'))
Out[223]: Timestamp('2014-08-01 17:00:00')

In [224]: pd.offsets.BusinessHour().rollforward(pd.Timestamp('2014-08-02 15:00'))
Out[224]: Timestamp('2014-08-04 09:00:00')

# It is the same as BusinessHour().apply(pd.Timestamp('2014-08-01 17:00')).
# And it is the same as BusinessHour().apply(pd.Timestamp('2014-08-04 09:00'))
In [225]: pd.offsets.BusinessHour().apply(pd.Timestamp('2014-08-02 15:00'))
Out[225]: Timestamp('2014-08-04 10:00:00')

# BusinessDay results (for reference)
In [226]: pd.offsets.BusinessHour().rollforward(pd.Timestamp('2014-08-02'))
Out[226]: Timestamp('2014-08-04 09:00:00')

# It is the same as BusinessDay().apply(pd.Timestamp('2014-08-01'))
# The result is the same as rollworward because BusinessDay never overlap.
In [227]: pd.offsets.BusinessHour().apply(pd.Timestamp('2014-08-02'))
Out[227]: Timestamp('2014-08-04 10:00:00')</pre>
<p><code class="docutils literal notranslate"><span class="pre">BusinessHour</span></code> regards Saturday and Sunday as holidays. To use arbitrary
holidays, you can use <code class="docutils literal notranslate"><span class="pre">CustomBusinessHour</span></code> offset, as explained in the
following subsection.</p>
</div>
<div class="section" id="custom-business-hour">
<span id="timeseries-custombusinesshour"></span><h3>Custom Business Hour<a class="headerlink" href="#custom-business-hour" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.18.1.</span></p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">CustomBusinessHour</span></code> is a mixture of <code class="docutils literal notranslate"><span class="pre">BusinessHour</span></code> and <code class="docutils literal notranslate"><span class="pre">CustomBusinessDay</span></code> which
allows you to specify arbitrary holidays. <code class="docutils literal notranslate"><span class="pre">CustomBusinessHour</span></code> works as the same
as <code class="docutils literal notranslate"><span class="pre">BusinessHour</span></code> except that it skips specified custom holidays.</p>
<pre class="literal-block">In [228]: from pandas.tseries.holiday import USFederalHolidayCalendar

In [229]: bhour_us = pd.offsets.CustomBusinessHour(calendar=USFederalHolidayCalendar())

# Friday before MLK Day
In [230]: dt = datetime.datetime(2014, 1, 17, 15)

In [231]: dt + bhour_us
Out[231]: Timestamp('2014-01-17 16:00:00')

# Tuesday after MLK Day (Monday is skipped because it's a holiday)
In [232]: dt + bhour_us * 2
Out[232]: Timestamp('2014-01-21 09:00:00')</pre>
<p>You can use keyword arguments supported by either <code class="docutils literal notranslate"><span class="pre">BusinessHour</span></code> and <code class="docutils literal notranslate"><span class="pre">CustomBusinessDay</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [233]: </span><span class="n">bhour_mon</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">offsets</span><span class="o">.</span><span class="n">CustomBusinessHour</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="s1">&#39;10:00&#39;</span><span class="p">,</span>
<span class="gp">   .....: </span>                                          <span class="n">weekmask</span><span class="o">=</span><span class="s1">&#39;Tue Wed Thu Fri&#39;</span><span class="p">)</span>
<span class="gp">   .....: </span>

<span class="go"># Monday is skipped because it&#39;s a holiday, business hour starts from 10:00</span>
<span class="gp">In [234]: </span><span class="n">dt</span> <span class="o">+</span> <span class="n">bhour_mon</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gh">Out[234]: </span><span class="go">Timestamp(&#39;2014-01-21 10:00:00&#39;)</span>
</pre></div>
</div>
</div>
<div class="section" id="offset-aliases">
<span id="timeseries-offset-aliases"></span><h3>Offset Aliases<a class="headerlink" href="#offset-aliases" title="Permalink to this headline">¶</a></h3>
<p>A number of string aliases are given to useful common time series
frequencies. We will refer to these aliases as <em>offset aliases</em>.</p>
<table class="colwidths-given table">
<colgroup>
<col style="width: 13%" />
<col style="width: 87%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Alias</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>B</p></td>
<td><p>business day frequency</p></td>
</tr>
<tr class="row-odd"><td><p>C</p></td>
<td><p>custom business day frequency</p></td>
</tr>
<tr class="row-even"><td><p>D</p></td>
<td><p>calendar day frequency</p></td>
</tr>
<tr class="row-odd"><td><p>W</p></td>
<td><p>weekly frequency</p></td>
</tr>
<tr class="row-even"><td><p>M</p></td>
<td><p>month end frequency</p></td>
</tr>
<tr class="row-odd"><td><p>SM</p></td>
<td><p>semi-month end frequency (15th and end of month)</p></td>
</tr>
<tr class="row-even"><td><p>BM</p></td>
<td><p>business month end frequency</p></td>
</tr>
<tr class="row-odd"><td><p>CBM</p></td>
<td><p>custom business month end frequency</p></td>
</tr>
<tr class="row-even"><td><p>MS</p></td>
<td><p>month start frequency</p></td>
</tr>
<tr class="row-odd"><td><p>SMS</p></td>
<td><p>semi-month start frequency (1st and 15th)</p></td>
</tr>
<tr class="row-even"><td><p>BMS</p></td>
<td><p>business month start frequency</p></td>
</tr>
<tr class="row-odd"><td><p>CBMS</p></td>
<td><p>custom business month start frequency</p></td>
</tr>
<tr class="row-even"><td><p>Q</p></td>
<td><p>quarter end frequency</p></td>
</tr>
<tr class="row-odd"><td><p>BQ</p></td>
<td><p>business quarter end frequency</p></td>
</tr>
<tr class="row-even"><td><p>QS</p></td>
<td><p>quarter start frequency</p></td>
</tr>
<tr class="row-odd"><td><p>BQS</p></td>
<td><p>business quarter start frequency</p></td>
</tr>
<tr class="row-even"><td><p>A, Y</p></td>
<td><p>year end frequency</p></td>
</tr>
<tr class="row-odd"><td><p>BA, BY</p></td>
<td><p>business year end frequency</p></td>
</tr>
<tr class="row-even"><td><p>AS, YS</p></td>
<td><p>year start frequency</p></td>
</tr>
<tr class="row-odd"><td><p>BAS, BYS</p></td>
<td><p>business year start frequency</p></td>
</tr>
<tr class="row-even"><td><p>BH</p></td>
<td><p>business hour frequency</p></td>
</tr>
<tr class="row-odd"><td><p>H</p></td>
<td><p>hourly frequency</p></td>
</tr>
<tr class="row-even"><td><p>T, min</p></td>
<td><p>minutely frequency</p></td>
</tr>
<tr class="row-odd"><td><p>S</p></td>
<td><p>secondly frequency</p></td>
</tr>
<tr class="row-even"><td><p>L, ms</p></td>
<td><p>milliseconds</p></td>
</tr>
<tr class="row-odd"><td><p>U, us</p></td>
<td><p>microseconds</p></td>
</tr>
<tr class="row-even"><td><p>N</p></td>
<td><p>nanoseconds</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="combining-aliases">
<h3>Combining Aliases<a class="headerlink" href="#combining-aliases" title="Permalink to this headline">¶</a></h3>
<p>As we have seen previously, the alias and the offset instance are fungible in
most functions:</p>
<pre class="literal-block">In [235]: pd.date_range(start, periods=5, freq='B')
Out[235]: 
DatetimeIndex(['2011-01-03', '2011-01-04', '2011-01-05', '2011-01-06',
               '2011-01-07'],
              dtype='datetime64[ns]', freq='B')

In [236]: pd.date_range(start, periods=5, freq=pd.offsets.BDay())
Out[236]: 
DatetimeIndex(['2011-01-03', '2011-01-04', '2011-01-05', '2011-01-06',
               '2011-01-07'],
              dtype='datetime64[ns]', freq='B')</pre>
<p>You can combine together day and intraday offsets:</p>
<pre class="literal-block">In [237]: pd.date_range(start, periods=10, freq='2h20min')
Out[237]: 
DatetimeIndex(['2011-01-01 00:00:00', '2011-01-01 02:20:00',
               '2011-01-01 04:40:00', '2011-01-01 07:00:00',
               '2011-01-01 09:20:00', '2011-01-01 11:40:00',
               '2011-01-01 14:00:00', '2011-01-01 16:20:00',
               '2011-01-01 18:40:00', '2011-01-01 21:00:00'],
              dtype='datetime64[ns]', freq='140T')

In [238]: pd.date_range(start, periods=10, freq='1D10U')
Out[238]: 
DatetimeIndex([       '2011-01-01 00:00:00', '2011-01-02 00:00:00.000010',
               '2011-01-03 00:00:00.000020', '2011-01-04 00:00:00.000030',
               '2011-01-05 00:00:00.000040', '2011-01-06 00:00:00.000050',
               '2011-01-07 00:00:00.000060', '2011-01-08 00:00:00.000070',
               '2011-01-09 00:00:00.000080', '2011-01-10 00:00:00.000090'],
              dtype='datetime64[ns]', freq='86400000010U')</pre>
</div>
<div class="section" id="anchored-offsets">
<h3>Anchored Offsets<a class="headerlink" href="#anchored-offsets" title="Permalink to this headline">¶</a></h3>
<p>For some frequencies you can specify an anchoring suffix:</p>
<table class="colwidths-given table">
<colgroup>
<col style="width: 13%" />
<col style="width: 87%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Alias</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>W-SUN</p></td>
<td><p>weekly frequency (Sundays). Same as ‘W’</p></td>
</tr>
<tr class="row-odd"><td><p>W-MON</p></td>
<td><p>weekly frequency (Mondays)</p></td>
</tr>
<tr class="row-even"><td><p>W-TUE</p></td>
<td><p>weekly frequency (Tuesdays)</p></td>
</tr>
<tr class="row-odd"><td><p>W-WED</p></td>
<td><p>weekly frequency (Wednesdays)</p></td>
</tr>
<tr class="row-even"><td><p>W-THU</p></td>
<td><p>weekly frequency (Thursdays)</p></td>
</tr>
<tr class="row-odd"><td><p>W-FRI</p></td>
<td><p>weekly frequency (Fridays)</p></td>
</tr>
<tr class="row-even"><td><p>W-SAT</p></td>
<td><p>weekly frequency (Saturdays)</p></td>
</tr>
<tr class="row-odd"><td><p>(B)Q(S)-DEC</p></td>
<td><p>quarterly frequency, year ends in December. Same as ‘Q’</p></td>
</tr>
<tr class="row-even"><td><p>(B)Q(S)-JAN</p></td>
<td><p>quarterly frequency, year ends in January</p></td>
</tr>
<tr class="row-odd"><td><p>(B)Q(S)-FEB</p></td>
<td><p>quarterly frequency, year ends in February</p></td>
</tr>
<tr class="row-even"><td><p>(B)Q(S)-MAR</p></td>
<td><p>quarterly frequency, year ends in March</p></td>
</tr>
<tr class="row-odd"><td><p>(B)Q(S)-APR</p></td>
<td><p>quarterly frequency, year ends in April</p></td>
</tr>
<tr class="row-even"><td><p>(B)Q(S)-MAY</p></td>
<td><p>quarterly frequency, year ends in May</p></td>
</tr>
<tr class="row-odd"><td><p>(B)Q(S)-JUN</p></td>
<td><p>quarterly frequency, year ends in June</p></td>
</tr>
<tr class="row-even"><td><p>(B)Q(S)-JUL</p></td>
<td><p>quarterly frequency, year ends in July</p></td>
</tr>
<tr class="row-odd"><td><p>(B)Q(S)-AUG</p></td>
<td><p>quarterly frequency, year ends in August</p></td>
</tr>
<tr class="row-even"><td><p>(B)Q(S)-SEP</p></td>
<td><p>quarterly frequency, year ends in September</p></td>
</tr>
<tr class="row-odd"><td><p>(B)Q(S)-OCT</p></td>
<td><p>quarterly frequency, year ends in October</p></td>
</tr>
<tr class="row-even"><td><p>(B)Q(S)-NOV</p></td>
<td><p>quarterly frequency, year ends in November</p></td>
</tr>
<tr class="row-odd"><td><p>(B)A(S)-DEC</p></td>
<td><p>annual frequency, anchored end of December. Same as ‘A’</p></td>
</tr>
<tr class="row-even"><td><p>(B)A(S)-JAN</p></td>
<td><p>annual frequency, anchored end of January</p></td>
</tr>
<tr class="row-odd"><td><p>(B)A(S)-FEB</p></td>
<td><p>annual frequency, anchored end of February</p></td>
</tr>
<tr class="row-even"><td><p>(B)A(S)-MAR</p></td>
<td><p>annual frequency, anchored end of March</p></td>
</tr>
<tr class="row-odd"><td><p>(B)A(S)-APR</p></td>
<td><p>annual frequency, anchored end of April</p></td>
</tr>
<tr class="row-even"><td><p>(B)A(S)-MAY</p></td>
<td><p>annual frequency, anchored end of May</p></td>
</tr>
<tr class="row-odd"><td><p>(B)A(S)-JUN</p></td>
<td><p>annual frequency, anchored end of June</p></td>
</tr>
<tr class="row-even"><td><p>(B)A(S)-JUL</p></td>
<td><p>annual frequency, anchored end of July</p></td>
</tr>
<tr class="row-odd"><td><p>(B)A(S)-AUG</p></td>
<td><p>annual frequency, anchored end of August</p></td>
</tr>
<tr class="row-even"><td><p>(B)A(S)-SEP</p></td>
<td><p>annual frequency, anchored end of September</p></td>
</tr>
<tr class="row-odd"><td><p>(B)A(S)-OCT</p></td>
<td><p>annual frequency, anchored end of October</p></td>
</tr>
<tr class="row-even"><td><p>(B)A(S)-NOV</p></td>
<td><p>annual frequency, anchored end of November</p></td>
</tr>
</tbody>
</table>
<p>These can be used as arguments to <code class="docutils literal notranslate"><span class="pre">date_range</span></code>, <code class="docutils literal notranslate"><span class="pre">bdate_range</span></code>, constructors
for <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>, as well as various other timeseries-related functions
in pandas.</p>
</div>
<div class="section" id="anchored-offset-semantics">
<h3>Anchored Offset Semantics<a class="headerlink" href="#anchored-offset-semantics" title="Permalink to this headline">¶</a></h3>
<p>For those offsets that are anchored to the start or end of specific
frequency (<code class="docutils literal notranslate"><span class="pre">MonthEnd</span></code>, <code class="docutils literal notranslate"><span class="pre">MonthBegin</span></code>, <code class="docutils literal notranslate"><span class="pre">WeekEnd</span></code>, etc), the following
rules apply to rolling forward and backwards.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">n</span></code> is not 0, if the given date is not on an anchor point, it snapped to the next(previous)
anchor point, and moved <code class="docutils literal notranslate"><span class="pre">|n|-1</span></code> additional steps forwards or backwards.</p>
<pre class="literal-block">In [239]: pd.Timestamp('2014-01-02') + pd.offsets.MonthBegin(n=1)
Out[239]: Timestamp('2014-02-01 00:00:00')

In [240]: pd.Timestamp('2014-01-02') + pd.offsets.MonthEnd(n=1)
Out[240]: Timestamp('2014-01-31 00:00:00')

In [241]: pd.Timestamp('2014-01-02') - pd.offsets.MonthBegin(n=1)
Out[241]: Timestamp('2014-01-01 00:00:00')

In [242]: pd.Timestamp('2014-01-02') - pd.offsets.MonthEnd(n=1)
Out[242]: Timestamp('2013-12-31 00:00:00')

In [243]: pd.Timestamp('2014-01-02') + pd.offsets.MonthBegin(n=4)
Out[243]: Timestamp('2014-05-01 00:00:00')

In [244]: pd.Timestamp('2014-01-02') - pd.offsets.MonthBegin(n=4)
Out[244]: Timestamp('2013-10-01 00:00:00')</pre>
<p>If the given date <em>is</em> on an anchor point, it is moved <code class="docutils literal notranslate"><span class="pre">|n|</span></code> points forwards
or backwards.</p>
<pre class="literal-block">In [245]: pd.Timestamp('2014-01-01') + pd.offsets.MonthBegin(n=1)
Out[245]: Timestamp('2014-02-01 00:00:00')

In [246]: pd.Timestamp('2014-01-31') + pd.offsets.MonthEnd(n=1)
Out[246]: Timestamp('2014-02-28 00:00:00')

In [247]: pd.Timestamp('2014-01-01') - pd.offsets.MonthBegin(n=1)
Out[247]: Timestamp('2013-12-01 00:00:00')

In [248]: pd.Timestamp('2014-01-31') - pd.offsets.MonthEnd(n=1)
Out[248]: Timestamp('2013-12-31 00:00:00')

In [249]: pd.Timestamp('2014-01-01') + pd.offsets.MonthBegin(n=4)
Out[249]: Timestamp('2014-05-01 00:00:00')

In [250]: pd.Timestamp('2014-01-31') - pd.offsets.MonthBegin(n=4)
Out[250]: Timestamp('2013-10-01 00:00:00')</pre>
<p>For the case when <code class="docutils literal notranslate"><span class="pre">n=0</span></code>, the date is not moved if on an anchor point, otherwise
it is rolled forward to the next anchor point.</p>
<pre class="literal-block">In [251]: pd.Timestamp('2014-01-02') + pd.offsets.MonthBegin(n=0)
Out[251]: Timestamp('2014-02-01 00:00:00')

In [252]: pd.Timestamp('2014-01-02') + pd.offsets.MonthEnd(n=0)
Out[252]: Timestamp('2014-01-31 00:00:00')

In [253]: pd.Timestamp('2014-01-01') + pd.offsets.MonthBegin(n=0)
Out[253]: Timestamp('2014-01-01 00:00:00')

In [254]: pd.Timestamp('2014-01-31') + pd.offsets.MonthEnd(n=0)
Out[254]: Timestamp('2014-01-31 00:00:00')</pre>
</div>
<div class="section" id="holidays-holiday-calendars">
<span id="timeseries-holiday"></span><h3>Holidays / Holiday Calendars<a class="headerlink" href="#holidays-holiday-calendars" title="Permalink to this headline">¶</a></h3>
<p>Holidays and calendars provide a simple way to define holiday rules to be used
with <code class="docutils literal notranslate"><span class="pre">CustomBusinessDay</span></code> or in other analysis that requires a predefined
set of holidays.  The <code class="docutils literal notranslate"><span class="pre">AbstractHolidayCalendar</span></code> class provides all the necessary
methods to return a list of holidays and only <code class="docutils literal notranslate"><span class="pre">rules</span></code> need to be defined
in a specific holiday calendar class. Furthermore, the <code class="docutils literal notranslate"><span class="pre">start_date</span></code> and <code class="docutils literal notranslate"><span class="pre">end_date</span></code>
class attributes determine over what date range holidays are generated.  These
should be overwritten on the <code class="docutils literal notranslate"><span class="pre">AbstractHolidayCalendar</span></code> class to have the range
apply to all calendar subclasses.  <code class="docutils literal notranslate"><span class="pre">USFederalHolidayCalendar</span></code> is the
only calendar that exists and primarily serves as an example for developing
other calendars.</p>
<p>For holidays that occur on fixed dates (e.g., US Memorial Day or July 4th) an
observance rule determines when that holiday is observed if it falls on a weekend
or some other non-observed day.  Defined observance rules are:</p>
<table class="colwidths-given table">
<colgroup>
<col style="width: 18%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Rule</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>nearest_workday</p></td>
<td><p>move Saturday to Friday and Sunday to Monday</p></td>
</tr>
<tr class="row-odd"><td><p>sunday_to_monday</p></td>
<td><p>move Sunday to following Monday</p></td>
</tr>
<tr class="row-even"><td><p>next_monday_or_tuesday</p></td>
<td><p>move Saturday to Monday and Sunday/Monday to Tuesday</p></td>
</tr>
<tr class="row-odd"><td><p>previous_friday</p></td>
<td><p>move Saturday and Sunday to previous Friday”</p></td>
</tr>
<tr class="row-even"><td><p>next_monday</p></td>
<td><p>move Saturday and Sunday to following Monday</p></td>
</tr>
</tbody>
</table>
<p>An example of how holidays and holiday calendars are defined:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [255]: </span><span class="kn">from</span> <span class="nn">pandas.tseries.holiday</span> <span class="kn">import</span> <span class="n">Holiday</span><span class="p">,</span> <span class="n">USMemorialDay</span><span class="p">,</span>\
<span class="gp">   .....: </span>    <span class="n">AbstractHolidayCalendar</span><span class="p">,</span> <span class="n">nearest_workday</span><span class="p">,</span> <span class="n">MO</span>
<span class="gp">   .....: </span>

<span class="gp">In [256]: </span><span class="k">class</span> <span class="nc">ExampleCalendar</span><span class="p">(</span><span class="n">AbstractHolidayCalendar</span><span class="p">):</span>
<span class="gp">   .....: </span>    <span class="n">rules</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">   .....: </span>        <span class="n">USMemorialDay</span><span class="p">,</span>
<span class="gp">   .....: </span>        <span class="n">Holiday</span><span class="p">(</span><span class="s1">&#39;July 4th&#39;</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">observance</span><span class="o">=</span><span class="n">nearest_workday</span><span class="p">),</span>
<span class="gp">   .....: </span>        <span class="n">Holiday</span><span class="p">(</span><span class="s1">&#39;Columbus Day&#39;</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">   .....: </span>                <span class="n">offset</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DateOffset</span><span class="p">(</span><span class="n">weekday</span><span class="o">=</span><span class="n">MO</span><span class="p">(</span><span class="mi">2</span><span class="p">)))]</span>
<span class="gp">   .....: </span>

<span class="gp">In [257]: </span><span class="n">cal</span> <span class="o">=</span> <span class="n">ExampleCalendar</span><span class="p">()</span>

<span class="gp">In [258]: </span><span class="n">cal</span><span class="o">.</span><span class="n">holidays</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">31</span><span class="p">))</span>
<span class="gh">Out[258]: </span><span class="go">DatetimeIndex([&#39;2012-05-28&#39;, &#39;2012-07-04&#39;, &#39;2012-10-08&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">hint</dt>
<dd class="field-odd"><p><strong>weekday=MO(2)</strong> is same as <strong>2 * Week(weekday=2)</strong></p>
</dd>
</dl>
<p>Using this calendar, creating an index or doing offset arithmetic skips weekends
and holidays (i.e., Memorial Day/July 4th).  For example, the below defines
a custom business day offset using the <code class="docutils literal notranslate"><span class="pre">ExampleCalendar</span></code>.  Like any other offset,
it can be used to create a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> or added to <code class="docutils literal notranslate"><span class="pre">datetime</span></code>
or <code class="docutils literal notranslate"><span class="pre">Timestamp</span></code> objects.</p>
<pre class="literal-block">In [259]: pd.date_range(start='7/1/2012', end='7/10/2012',
   .....:               freq=pd.offsets.CDay(calendar=cal)).to_pydatetime()
   .....: 
Out[259]: 
array([datetime.datetime(2012, 7, 2, 0, 0),
       datetime.datetime(2012, 7, 3, 0, 0),
       datetime.datetime(2012, 7, 5, 0, 0),
       datetime.datetime(2012, 7, 6, 0, 0),
       datetime.datetime(2012, 7, 9, 0, 0),
       datetime.datetime(2012, 7, 10, 0, 0)], dtype=object)

In [260]: offset = pd.offsets.CustomBusinessDay(calendar=cal)

In [261]: datetime.datetime(2012, 5, 25) + offset
Out[261]: Timestamp('2012-05-29 00:00:00')

In [262]: datetime.datetime(2012, 7, 3) + offset
Out[262]: Timestamp('2012-07-05 00:00:00')

In [263]: datetime.datetime(2012, 7, 3) + 2 * offset
Out[263]: Timestamp('2012-07-06 00:00:00')

In [264]: datetime.datetime(2012, 7, 6) + offset
Out[264]: Timestamp('2012-07-09 00:00:00')</pre>
<p>Ranges are defined by the <code class="docutils literal notranslate"><span class="pre">start_date</span></code> and <code class="docutils literal notranslate"><span class="pre">end_date</span></code> class attributes
of <code class="docutils literal notranslate"><span class="pre">AbstractHolidayCalendar</span></code>.  The defaults are shown below.</p>
<pre class="literal-block">In [265]: AbstractHolidayCalendar.start_date
Out[265]: Timestamp('1970-01-01 00:00:00')

In [266]: AbstractHolidayCalendar.end_date
Out[266]: Timestamp('2030-12-31 00:00:00')</pre>
<p>These dates can be overwritten by setting the attributes as
datetime/Timestamp/string.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [267]: </span><span class="n">AbstractHolidayCalendar</span><span class="o">.</span><span class="n">start_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="gp">In [268]: </span><span class="n">AbstractHolidayCalendar</span><span class="o">.</span><span class="n">end_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">31</span><span class="p">)</span>

<span class="gp">In [269]: </span><span class="n">cal</span><span class="o">.</span><span class="n">holidays</span><span class="p">()</span>
<span class="gh">Out[269]: </span><span class="go">DatetimeIndex([&#39;2012-05-28&#39;, &#39;2012-07-04&#39;, &#39;2012-10-08&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</span>
</pre></div>
</div>
<p>Every calendar class is accessible by name using the <code class="docutils literal notranslate"><span class="pre">get_calendar</span></code> function
which returns a holiday class instance.  Any imported calendar class will
automatically be available by this function.  Also, <code class="docutils literal notranslate"><span class="pre">HolidayCalendarFactory</span></code>
provides an easy interface to create calendars that are combinations of calendars
or calendars with additional rules.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [270]: </span><span class="kn">from</span> <span class="nn">pandas.tseries.holiday</span> <span class="kn">import</span> <span class="n">get_calendar</span><span class="p">,</span> <span class="n">HolidayCalendarFactory</span><span class="p">,</span>\
<span class="gp">   .....: </span>    <span class="n">USLaborDay</span>
<span class="gp">   .....: </span>

<span class="gp">In [271]: </span><span class="n">cal</span> <span class="o">=</span> <span class="n">get_calendar</span><span class="p">(</span><span class="s1">&#39;ExampleCalendar&#39;</span><span class="p">)</span>

<span class="gp">In [272]: </span><span class="n">cal</span><span class="o">.</span><span class="n">rules</span>
<span class="gh">Out[272]: </span><span class="go"></span>
<span class="go">[Holiday: Memorial Day (month=5, day=31, offset=&lt;DateOffset: weekday=MO(-1)&gt;),</span>
<span class="go"> Holiday: July 4th (month=7, day=4, observance=&lt;function nearest_workday at 0x7fd412b14f80&gt;),</span>
<span class="go"> Holiday: Columbus Day (month=10, day=1, offset=&lt;DateOffset: weekday=MO(+2)&gt;)]</span>

<span class="gp">In [273]: </span><span class="n">new_cal</span> <span class="o">=</span> <span class="n">HolidayCalendarFactory</span><span class="p">(</span><span class="s1">&#39;NewExampleCalendar&#39;</span><span class="p">,</span> <span class="n">cal</span><span class="p">,</span> <span class="n">USLaborDay</span><span class="p">)</span>

<span class="gp">In [274]: </span><span class="n">new_cal</span><span class="o">.</span><span class="n">rules</span>
<span class="gh">Out[274]: </span><span class="go"></span>
<span class="go">[Holiday: Labor Day (month=9, day=1, offset=&lt;DateOffset: weekday=MO(+1)&gt;),</span>
<span class="go"> Holiday: Memorial Day (month=5, day=31, offset=&lt;DateOffset: weekday=MO(-1)&gt;),</span>
<span class="go"> Holiday: July 4th (month=7, day=4, observance=&lt;function nearest_workday at 0x7fd412b14f80&gt;),</span>
<span class="go"> Holiday: Columbus Day (month=10, day=1, offset=&lt;DateOffset: weekday=MO(+2)&gt;)]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="time-series-related-instance-methods">
<span id="timeseries-advanced-datetime"></span><h2>Time Series-Related Instance Methods<a class="headerlink" href="#time-series-related-instance-methods" title="Permalink to this headline">¶</a></h2>
<div class="section" id="shifting-lagging">
<h3>Shifting / Lagging<a class="headerlink" href="#shifting-lagging" title="Permalink to this headline">¶</a></h3>
<p>One may want to <em>shift</em> or <em>lag</em> the values in a time series back and forward in
time. The method for this is <code class="xref py py-meth docutils literal notranslate"><span class="pre">shift()</span></code>, which is available on all of
the pandas objects.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [275]: </span><span class="n">ts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rng</span><span class="p">)),</span> <span class="n">index</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>

<span class="gp">In [276]: </span><span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>

<span class="gp">In [277]: </span><span class="n">ts</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gh">Out[277]: </span><span class="go"></span>
<span class="go">2012-01-01    NaN</span>
<span class="go">2012-01-02    0.0</span>
<span class="go">2012-01-03    1.0</span>
<span class="go">Freq: D, dtype: float64</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">shift</span></code> method accepts an <code class="docutils literal notranslate"><span class="pre">freq</span></code> argument which can accept a
<code class="docutils literal notranslate"><span class="pre">DateOffset</span></code> class or other <code class="docutils literal notranslate"><span class="pre">timedelta</span></code>-like object or also an
<a class="reference internal" href="#timeseries-offset-aliases"><span class="std std-ref">offset alias</span></a>:</p>
<pre class="literal-block">In [278]: ts.shift(5, freq=pd.offsets.BDay())
Out[278]: 
2012-01-06    0
2012-01-09    1
2012-01-10    2
Freq: B, dtype: int64

In [279]: ts.shift(5, freq='BM')
Out[279]: 
2012-05-31    0
2012-05-31    1
2012-05-31    2
Freq: D, dtype: int64</pre>
<p>Rather than changing the alignment of the data and the index, <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> and
<code class="docutils literal notranslate"><span class="pre">Series</span></code> objects also have a <code class="xref py py-meth docutils literal notranslate"><span class="pre">tshift()</span></code> convenience method that
changes all the dates in the index by a specified number of offsets:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [280]: </span><span class="n">ts</span><span class="o">.</span><span class="n">tshift</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
<span class="gh">Out[280]: </span><span class="go"></span>
<span class="go">2012-01-06    0</span>
<span class="go">2012-01-07    1</span>
<span class="go">2012-01-08    2</span>
<span class="go">Freq: D, dtype: int64</span>
</pre></div>
</div>
<p>Note that with <code class="docutils literal notranslate"><span class="pre">tshift</span></code>, the leading entry is no longer NaN because the data
is not being realigned.</p>
</div>
<div class="section" id="frequency-conversion">
<h3>Frequency Conversion<a class="headerlink" href="#frequency-conversion" title="Permalink to this headline">¶</a></h3>
<p>The primary function for changing frequencies is the <code class="xref py py-meth docutils literal notranslate"><span class="pre">asfreq()</span></code>
method. For a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>, this is basically just a thin, but convenient
wrapper around <code class="xref py py-meth docutils literal notranslate"><span class="pre">reindex()</span></code>  which generates a <code class="docutils literal notranslate"><span class="pre">date_range</span></code> and
calls <code class="docutils literal notranslate"><span class="pre">reindex</span></code>.</p>
<pre class="literal-block">In [281]: dr = pd.date_range('1/1/2010', periods=3, freq=3 * pd.offsets.BDay())

In [282]: ts = pd.Series(np.random.randn(3), index=dr)

In [283]: ts
Out[283]: 
2010-01-01    1.494522
2010-01-06   -0.778425
2010-01-11   -0.253355
Freq: 3B, dtype: float64

In [284]: ts.asfreq(pd.offsets.BDay())
Out[284]: 
2010-01-01    1.494522
2010-01-04         NaN
2010-01-05         NaN
2010-01-06   -0.778425
2010-01-07         NaN
2010-01-08         NaN
2010-01-11   -0.253355
Freq: B, dtype: float64</pre>
<p><code class="docutils literal notranslate"><span class="pre">asfreq</span></code> provides a further convenience so you can specify an interpolation
method for any gaps that may appear after the frequency conversion.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [285]: </span><span class="n">ts</span><span class="o">.</span><span class="n">asfreq</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">offsets</span><span class="o">.</span><span class="n">BDay</span><span class="p">(),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">)</span>
<span class="gh">Out[285]: </span><span class="go"></span>
<span class="go">2010-01-01    1.494522</span>
<span class="go">2010-01-04    1.494522</span>
<span class="go">2010-01-05    1.494522</span>
<span class="go">2010-01-06   -0.778425</span>
<span class="go">2010-01-07   -0.778425</span>
<span class="go">2010-01-08   -0.778425</span>
<span class="go">2010-01-11   -0.253355</span>
<span class="go">Freq: B, dtype: float64</span>
</pre></div>
</div>
</div>
<div class="section" id="filling-forward-backward">
<h3>Filling Forward / Backward<a class="headerlink" href="#filling-forward-backward" title="Permalink to this headline">¶</a></h3>
<p>Related to <code class="docutils literal notranslate"><span class="pre">asfreq</span></code> and <code class="docutils literal notranslate"><span class="pre">reindex</span></code> is <code class="xref py py-meth docutils literal notranslate"><span class="pre">fillna()</span></code>, which is
documented in the <a class="reference internal" href="missing_data.html#missing-data-fillna"><span class="std std-ref">missing data section</span></a>.</p>
</div>
<div class="section" id="converting-to-python-datetimes">
<h3>Converting to Python Datetimes<a class="headerlink" href="#converting-to-python-datetimes" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> can be converted to an array of Python native
<a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a> objects using the <code class="docutils literal notranslate"><span class="pre">to_pydatetime</span></code> method.</p>
</div>
</div>
<div class="section" id="resampling">
<span id="timeseries-resampling"></span><h2>Resampling<a class="headerlink" href="#resampling" title="Permalink to this headline">¶</a></h2>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>The interface to <code class="docutils literal notranslate"><span class="pre">.resample</span></code> has changed in 0.18.0 to be more groupby-like and hence more flexible.
See the <a class="reference internal" href="../whatsnew/v0.18.0.html#whatsnew-0180-breaking-resample"><span class="std std-ref">whatsnew docs</span></a> for a comparison with prior versions.</p>
</div>
<p>Pandas has a simple, powerful, and efficient functionality for performing
resampling operations during frequency conversion (e.g., converting secondly
data into 5-minutely data). This is extremely common in, but not limited to,
financial applications.</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">resample()</span></code> is a time-based groupby, followed by a reduction method
on each of its groups. See some <a class="reference internal" href="cookbook.html#cookbook-resample"><span class="std std-ref">cookbook examples</span></a> for
some advanced strategies.</p>
<p>Starting in version 0.18.1, the <code class="docutils literal notranslate"><span class="pre">resample()</span></code> function can be used directly from
<code class="docutils literal notranslate"><span class="pre">DataFrameGroupBy</span></code> objects, see the <a class="reference internal" href="groupby.html#groupby-transform-window-resample"><span class="std std-ref">groupby docs</span></a>.</p>
<div class="alert alert-info">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">.resample()</span></code> is similar to using a <code class="xref py py-meth docutils literal notranslate"><span class="pre">rolling()</span></code> operation with
a time-based offset, see a discussion <a class="reference internal" href="computation.html#stats-moments-ts-versus-resampling"><span class="std std-ref">here</span></a>.</p>
</div>
<div class="section" id="basics">
<h3>Basics<a class="headerlink" href="#basics" title="Permalink to this headline">¶</a></h3>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [286]: </span><span class="n">rng</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;1/1/2012&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>

<span class="gp">In [287]: </span><span class="n">ts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rng</span><span class="p">)),</span> <span class="n">index</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>

<span class="gp">In [288]: </span><span class="n">ts</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;5Min&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gh">Out[288]: </span><span class="go"></span>
<span class="go">2012-01-01    25103</span>
<span class="go">Freq: 5T, dtype: int64</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">resample</span></code> function is very flexible and allows you to specify many
different parameters to control the frequency conversion and resampling
operation.</p>
<p>Any function available via <a class="reference internal" href="groupby.html#groupby-dispatch"><span class="std std-ref">dispatching</span></a> is available as
a method of the returned object, including <code class="docutils literal notranslate"><span class="pre">sum</span></code>, <code class="docutils literal notranslate"><span class="pre">mean</span></code>, <code class="docutils literal notranslate"><span class="pre">std</span></code>, <code class="docutils literal notranslate"><span class="pre">sem</span></code>,
<code class="docutils literal notranslate"><span class="pre">max</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">median</span></code>, <code class="docutils literal notranslate"><span class="pre">first</span></code>, <code class="docutils literal notranslate"><span class="pre">last</span></code>, <code class="docutils literal notranslate"><span class="pre">ohlc</span></code>:</p>
<pre class="literal-block">In [289]: ts.resample('5Min').mean()
Out[289]: 
2012-01-01    251.03
Freq: 5T, dtype: float64

In [290]: ts.resample('5Min').ohlc()
Out[290]: 
            open  high  low  close
2012-01-01   308   460    9    205

In [291]: ts.resample('5Min').max()
Out[291]: 
2012-01-01    460
Freq: 5T, dtype: int64</pre>
<p>For downsampling, <code class="docutils literal notranslate"><span class="pre">closed</span></code> can be set to ‘left’ or ‘right’ to specify which
end of the interval is closed:</p>
<pre class="literal-block">In [292]: ts.resample('5Min', closed='right').mean()
Out[292]: 
2011-12-31 23:55:00    308.000000
2012-01-01 00:00:00    250.454545
Freq: 5T, dtype: float64

In [293]: ts.resample('5Min', closed='left').mean()
Out[293]: 
2012-01-01    251.03
Freq: 5T, dtype: float64</pre>
<p>Parameters like <code class="docutils literal notranslate"><span class="pre">label</span></code> and <code class="docutils literal notranslate"><span class="pre">loffset</span></code> are used to manipulate the resulting
labels. <code class="docutils literal notranslate"><span class="pre">label</span></code> specifies whether the result is labeled with the beginning or
the end of the interval. <code class="docutils literal notranslate"><span class="pre">loffset</span></code> performs a time adjustment on the output
labels.</p>
<pre class="literal-block">In [294]: ts.resample('5Min').mean()  # by default label='left'
Out[294]: 
2012-01-01    251.03
Freq: 5T, dtype: float64

In [295]: ts.resample('5Min', label='left').mean()
Out[295]: 
2012-01-01    251.03
Freq: 5T, dtype: float64

In [296]: ts.resample('5Min', label='left', loffset='1s').mean()
Out[296]: 
2012-01-01 00:00:01    251.03
dtype: float64</pre>
<div class="alert alert-info">
<p class="admonition-title">Note</p>
<p>The default values for <code class="docutils literal notranslate"><span class="pre">label</span></code> and <code class="docutils literal notranslate"><span class="pre">closed</span></code> is ‘left’ for all
frequency offsets except for ‘M’, ‘A’, ‘Q’, ‘BM’, ‘BA’, ‘BQ’, and ‘W’
which all have a default of ‘right’.</p>
<pre class="literal-block">In [297]: rng2 = pd.date_range('1/1/2012', end='3/31/2012', freq='D')

In [298]: ts2 = pd.Series(range(len(rng2)), index=rng2)

# default: label='right', closed='right'
In [299]: ts2.resample('M').max()
Out[299]: 
2012-01-31    30
2012-02-29    59
2012-03-31    90
Freq: M, dtype: int64

# default: label='left', closed='left'
In [300]: ts2.resample('SM').max()
Out[300]: 
2011-12-31    13
2012-01-15    29
2012-01-31    44
2012-02-15    58
2012-02-29    73
2012-03-15    89
2012-03-31    90
Freq: SM-15, dtype: int64

In [301]: ts2.resample('SM', label='right', closed='right').max()
Out[301]: 
2012-01-15    14.0
2012-01-31    30.0
2012-02-15    45.0
2012-02-29    59.0
2012-03-15    74.0
2012-03-31    90.0
2012-04-15     NaN
Freq: SM-15, dtype: float64</pre>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">axis</span></code> parameter can be set to 0 or 1 and allows you to resample the
specified axis for a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">kind</span></code> can be set to ‘timestamp’ or ‘period’ to convert the resulting index
to/from timestamp and time span representations. By default <code class="docutils literal notranslate"><span class="pre">resample</span></code>
retains the input representation.</p>
<p><code class="docutils literal notranslate"><span class="pre">convention</span></code> can be set to ‘start’ or ‘end’ when resampling period data
(detail below). It specifies how low frequency periods are converted to higher
frequency periods.</p>
</div>
<div class="section" id="upsampling">
<h3>Upsampling<a class="headerlink" href="#upsampling" title="Permalink to this headline">¶</a></h3>
<p>For upsampling, you can specify a way to upsample and the <code class="docutils literal notranslate"><span class="pre">limit</span></code> parameter to interpolate over the gaps that are created:</p>
<pre class="literal-block"># from secondly to every 250 milliseconds
In [302]: ts[:2].resample('250L').asfreq()
Out[302]: 
2012-01-01 00:00:00.000    308.0
2012-01-01 00:00:00.250      NaN
2012-01-01 00:00:00.500      NaN
2012-01-01 00:00:00.750      NaN
2012-01-01 00:00:01.000    204.0
Freq: 250L, dtype: float64

In [303]: ts[:2].resample('250L').ffill()
Out[303]: 
2012-01-01 00:00:00.000    308
2012-01-01 00:00:00.250    308
2012-01-01 00:00:00.500    308
2012-01-01 00:00:00.750    308
2012-01-01 00:00:01.000    204
Freq: 250L, dtype: int64

In [304]: ts[:2].resample('250L').ffill(limit=2)
Out[304]: 
2012-01-01 00:00:00.000    308.0
2012-01-01 00:00:00.250    308.0
2012-01-01 00:00:00.500    308.0
2012-01-01 00:00:00.750      NaN
2012-01-01 00:00:01.000    204.0
Freq: 250L, dtype: float64</pre>
</div>
<div class="section" id="sparse-resampling">
<h3>Sparse Resampling<a class="headerlink" href="#sparse-resampling" title="Permalink to this headline">¶</a></h3>
<p>Sparse timeseries are the ones where you have a lot fewer points relative
to the amount of time you are looking to resample. Naively upsampling a sparse
series can potentially generate lots of intermediate values. When you don’t want
to use a method to fill these values, e.g. <code class="docutils literal notranslate"><span class="pre">fill_method</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, then
intermediate values will be filled with <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">resample</span></code> is a time-based groupby, the following is a method to efficiently
resample only the groups that are not all <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [305]: </span><span class="n">rng</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;2014-1-1&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="s1">&#39;1s&#39;</span><span class="p">)</span>

<span class="gp">In [306]: </span><span class="n">ts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
</pre></div>
</div>
<p>If we want to resample to the full range of the series:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [307]: </span><span class="n">ts</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;3T&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gh">Out[307]: </span><span class="go"></span>
<span class="go">2014-01-01 00:00:00     0</span>
<span class="go">2014-01-01 00:03:00     0</span>
<span class="go">2014-01-01 00:06:00     0</span>
<span class="go">2014-01-01 00:09:00     0</span>
<span class="go">2014-01-01 00:12:00     0</span>
<span class="go">                       ..</span>
<span class="go">2014-04-09 23:48:00     0</span>
<span class="go">2014-04-09 23:51:00     0</span>
<span class="go">2014-04-09 23:54:00     0</span>
<span class="go">2014-04-09 23:57:00     0</span>
<span class="go">2014-04-10 00:00:00    99</span>
<span class="go">Freq: 3T, Length: 47521, dtype: int64</span>
</pre></div>
</div>
<p>We can instead only resample those groups where we have points as follows:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [308]: </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="gp">In [309]: </span><span class="kn">from</span> <span class="nn">pandas.tseries.frequencies</span> <span class="kn">import</span> <span class="n">to_offset</span>

<span class="gp">In [310]: </span><span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
<span class="gp">   .....: </span>    <span class="n">freq</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
<span class="gp">   .....: </span>    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">((</span><span class="n">t</span><span class="o">.</span><span class="n">value</span> <span class="o">//</span> <span class="n">freq</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="n">freq</span><span class="o">.</span><span class="n">delta</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="gp">   .....: </span>

<span class="gp">In [311]: </span><span class="n">ts</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="nb">round</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;3T&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gh">Out[311]: </span><span class="go"></span>
<span class="go">2014-01-01     0</span>
<span class="go">2014-01-02     1</span>
<span class="go">2014-01-03     2</span>
<span class="go">2014-01-04     3</span>
<span class="go">2014-01-05     4</span>
<span class="go">              ..</span>
<span class="go">2014-04-06    95</span>
<span class="go">2014-04-07    96</span>
<span class="go">2014-04-08    97</span>
<span class="go">2014-04-09    98</span>
<span class="go">2014-04-10    99</span>
<span class="go">Length: 100, dtype: int64</span>
</pre></div>
</div>
</div>
<div class="section" id="aggregation">
<span id="timeseries-aggregate"></span><h3>Aggregation<a class="headerlink" href="#aggregation" title="Permalink to this headline">¶</a></h3>
<p>Similar to the <a class="reference internal" href="../getting_started/basics.html#basics-aggregate"><span class="std std-ref">aggregating API</span></a>, <a class="reference internal" href="groupby.html#groupby-aggregate"><span class="std std-ref">groupby API</span></a>, and the <a class="reference internal" href="computation.html#stats-aggregate"><span class="std std-ref">window functions API</span></a>,
a <code class="docutils literal notranslate"><span class="pre">Resampler</span></code> can be selectively resampled.</p>
<p>Resampling a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>, the default will be to act on all columns with the same function.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [312]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
<span class="gp">   .....: </span>                  <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;1/1/2012&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1000</span><span class="p">),</span>
<span class="gp">   .....: </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>
<span class="gp">   .....: </span>

<span class="gp">In [313]: </span><span class="n">r</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;3T&#39;</span><span class="p">)</span>

<span class="gp">In [314]: </span><span class="n">r</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="gh">Out[314]: </span><span class="go"></span>
<span class="go">                            A         B         C</span>
<span class="go">2012-01-01 00:00:00 -0.033823 -0.121514 -0.081447</span>
<span class="go">2012-01-01 00:03:00  0.056909  0.146731 -0.024320</span>
<span class="go">2012-01-01 00:06:00 -0.058837  0.047046 -0.052021</span>
<span class="go">2012-01-01 00:09:00  0.063123 -0.026158 -0.066533</span>
<span class="go">2012-01-01 00:12:00  0.186340 -0.003144  0.074752</span>
<span class="go">2012-01-01 00:15:00 -0.085954 -0.016287 -0.050046</span>
</pre></div>
</div>
<p>We can select a specific column or columns using standard getitem.</p>
<pre class="literal-block">In [315]: r['A'].mean()
Out[315]: 
2012-01-01 00:00:00   -0.033823
2012-01-01 00:03:00    0.056909
2012-01-01 00:06:00   -0.058837
2012-01-01 00:09:00    0.063123
2012-01-01 00:12:00    0.186340
2012-01-01 00:15:00   -0.085954
Freq: 3T, Name: A, dtype: float64

In [316]: r[['A', 'B']].mean()
Out[316]: 
                            A         B
2012-01-01 00:00:00 -0.033823 -0.121514
2012-01-01 00:03:00  0.056909  0.146731
2012-01-01 00:06:00 -0.058837  0.047046
2012-01-01 00:09:00  0.063123 -0.026158
2012-01-01 00:12:00  0.186340 -0.003144
2012-01-01 00:15:00 -0.085954 -0.016287</pre>
<p>You can pass a list or dict of functions to do aggregation with, outputting a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [317]: </span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">])</span>
<span class="gh">Out[317]: </span><span class="go"></span>
<span class="go">                           sum      mean       std</span>
<span class="go">2012-01-01 00:00:00  -6.088060 -0.033823  1.043263</span>
<span class="go">2012-01-01 00:03:00  10.243678  0.056909  1.058534</span>
<span class="go">2012-01-01 00:06:00 -10.590584 -0.058837  0.949264</span>
<span class="go">2012-01-01 00:09:00  11.362228  0.063123  1.028096</span>
<span class="go">2012-01-01 00:12:00  33.541257  0.186340  0.884586</span>
<span class="go">2012-01-01 00:15:00  -8.595393 -0.085954  1.035476</span>
</pre></div>
</div>
<p>On a resampled <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>, you can pass a list of functions to apply to each
column, which produces an aggregated result with a hierarchical index:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [318]: </span><span class="n">r</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">])</span>
<span class="gh">Out[318]: </span><span class="go"></span>
<span class="go">                             A            ...          C          </span>
<span class="go">                           sum      mean  ...        sum      mean</span>
<span class="go">2012-01-01 00:00:00  -6.088060 -0.033823  ... -14.660515 -0.081447</span>
<span class="go">2012-01-01 00:03:00  10.243678  0.056909  ...  -4.377642 -0.024320</span>
<span class="go">2012-01-01 00:06:00 -10.590584 -0.058837  ...  -9.363825 -0.052021</span>
<span class="go">2012-01-01 00:09:00  11.362228  0.063123  ... -11.975895 -0.066533</span>
<span class="go">2012-01-01 00:12:00  33.541257  0.186340  ...  13.455299  0.074752</span>
<span class="go">2012-01-01 00:15:00  -8.595393 -0.085954  ...  -5.004580 -0.050046</span>

<span class="go">[6 rows x 6 columns]</span>
</pre></div>
</div>
<p>By passing a dict to <code class="docutils literal notranslate"><span class="pre">aggregate</span></code> you can apply a different aggregation to the
columns of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [319]: </span><span class="n">r</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span>
<span class="gp">   .....: </span>       <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)})</span>
<span class="gp">   .....: </span>
<span class="gh">Out[319]: </span><span class="go"></span>
<span class="go">                             A         B</span>
<span class="go">2012-01-01 00:00:00  -6.088060  1.001294</span>
<span class="go">2012-01-01 00:03:00  10.243678  1.074597</span>
<span class="go">2012-01-01 00:06:00 -10.590584  0.987309</span>
<span class="go">2012-01-01 00:09:00  11.362228  0.944953</span>
<span class="go">2012-01-01 00:12:00  33.541257  1.095025</span>
<span class="go">2012-01-01 00:15:00  -8.595393  1.035312</span>
</pre></div>
</div>
<p>The function names can also be strings. In order for a string to be valid it
must be implemented on the resampled object:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [320]: </span><span class="n">r</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="s1">&#39;std&#39;</span><span class="p">})</span>
<span class="gh">Out[320]: </span><span class="go"></span>
<span class="go">                             A         B</span>
<span class="go">2012-01-01 00:00:00  -6.088060  1.001294</span>
<span class="go">2012-01-01 00:03:00  10.243678  1.074597</span>
<span class="go">2012-01-01 00:06:00 -10.590584  0.987309</span>
<span class="go">2012-01-01 00:09:00  11.362228  0.944953</span>
<span class="go">2012-01-01 00:12:00  33.541257  1.095025</span>
<span class="go">2012-01-01 00:15:00  -8.595393  1.035312</span>
</pre></div>
</div>
<p>Furthermore, you can also specify multiple aggregation functions for each column separately.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [321]: </span><span class="n">r</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">],</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">]})</span>
<span class="gh">Out[321]: </span><span class="go"></span>
<span class="go">                             A                   B          </span>
<span class="go">                           sum       std      mean       std</span>
<span class="go">2012-01-01 00:00:00  -6.088060  1.043263 -0.121514  1.001294</span>
<span class="go">2012-01-01 00:03:00  10.243678  1.058534  0.146731  1.074597</span>
<span class="go">2012-01-01 00:06:00 -10.590584  0.949264  0.047046  0.987309</span>
<span class="go">2012-01-01 00:09:00  11.362228  1.028096 -0.026158  0.944953</span>
<span class="go">2012-01-01 00:12:00  33.541257  0.884586 -0.003144  1.095025</span>
<span class="go">2012-01-01 00:15:00  -8.595393  1.035476 -0.016287  1.035312</span>
</pre></div>
</div>
<p>If a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> does not have a datetimelike index, but instead you want
to resample based on datetimelike column in the frame, it can passed to the
<code class="docutils literal notranslate"><span class="pre">on</span></code> keyword.</p>
<pre class="literal-block">In [322]: df = pd.DataFrame({'date': pd.date_range('2015-01-01', freq='W', periods=5),
   .....:                    'a': np.arange(5)},
   .....:                   index=pd.MultiIndex.from_arrays([
   .....:                       [1, 2, 3, 4, 5],
   .....:                       pd.date_range('2015-01-01', freq='W', periods=5)],
   .....:                       names=['v', 'd']))
   .....: 

In [323]: df
Out[323]: 
                   date  a
v d                       
1 2015-01-04 2015-01-04  0
2 2015-01-11 2015-01-11  1
3 2015-01-18 2015-01-18  2
4 2015-01-25 2015-01-25  3
5 2015-02-01 2015-02-01  4

In [324]: df.resample('M', on='date').sum()
Out[324]: 
            a
date         
2015-01-31  6
2015-02-28  4</pre>
<p>Similarly, if you instead want to resample by a datetimelike
level of <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>, its name or location can be passed to the
<code class="docutils literal notranslate"><span class="pre">level</span></code> keyword.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [325]: </span><span class="n">df</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gh">Out[325]: </span><span class="go"></span>
<span class="go">            a</span>
<span class="go">d            </span>
<span class="go">2015-01-31  6</span>
<span class="go">2015-02-28  4</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="time-span-representation">
<span id="timeseries-periods"></span><h2>Time Span Representation<a class="headerlink" href="#time-span-representation" title="Permalink to this headline">¶</a></h2>
<p>Regular intervals of time are represented by <code class="docutils literal notranslate"><span class="pre">Period</span></code> objects in pandas while
sequences of <code class="docutils literal notranslate"><span class="pre">Period</span></code> objects are collected in a <code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code>, which can
be created with the convenience function <code class="docutils literal notranslate"><span class="pre">period_range</span></code>.</p>
<div class="section" id="period">
<h3>Period<a class="headerlink" href="#period" title="Permalink to this headline">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">Period</span></code> represents a span of time (e.g., a day, a month, a quarter, etc).
You can specify the span via <code class="docutils literal notranslate"><span class="pre">freq</span></code> keyword using a frequency alias like below.
Because <code class="docutils literal notranslate"><span class="pre">freq</span></code> represents a span of <code class="docutils literal notranslate"><span class="pre">Period</span></code>, it cannot be negative like “-3D”.</p>
<pre class="literal-block">In [326]: pd.Period('2012', freq='A-DEC')
Out[326]: Period('2012', 'A-DEC')

In [327]: pd.Period('2012-1-1', freq='D')
Out[327]: Period('2012-01-01', 'D')

In [328]: pd.Period('2012-1-1 19:00', freq='H')
Out[328]: Period('2012-01-01 19:00', 'H')

In [329]: pd.Period('2012-1-1 19:00', freq='5H')
Out[329]: Period('2012-01-01 19:00', '5H')</pre>
<p>Adding and subtracting integers from periods shifts the period by its own
frequency. Arithmetic is not allowed between <code class="docutils literal notranslate"><span class="pre">Period</span></code> with different <code class="docutils literal notranslate"><span class="pre">freq</span></code> (span).</p>
<pre class="literal-block">In [330]: p = pd.Period('2012', freq='A-DEC')

In [331]: p + 1
Out[331]: Period('2013', 'A-DEC')

In [332]: p - 3
Out[332]: Period('2009', 'A-DEC')

In [333]: p = pd.Period('2012-01', freq='2M')

In [334]: p + 2
Out[334]: Period('2012-05', '2M')

In [335]: p - 1
Out[335]: Period('2011-11', '2M')

In [336]: p == pd.Period('2012-01', freq='3M')
---------------------------------------------------------------------------
IncompatibleFrequency                     Traceback (most recent call last)
&lt;ipython-input-336-4b67dc0b596c&gt; in &lt;module&gt;
----&gt; 1 p == pd.Period('2012-01', freq='3M')

pandas/_libs/tslibs/period.pyx in pandas._libs.tslibs.period._Period.__richcmp__()

IncompatibleFrequency: Input has different freq=3M from Period(freq=2M)</pre>
<p>If <code class="docutils literal notranslate"><span class="pre">Period</span></code> freq is daily or higher (<code class="docutils literal notranslate"><span class="pre">D</span></code>, <code class="docutils literal notranslate"><span class="pre">H</span></code>, <code class="docutils literal notranslate"><span class="pre">T</span></code>, <code class="docutils literal notranslate"><span class="pre">S</span></code>, <code class="docutils literal notranslate"><span class="pre">L</span></code>, <code class="docutils literal notranslate"><span class="pre">U</span></code>, <code class="docutils literal notranslate"><span class="pre">N</span></code>), <code class="docutils literal notranslate"><span class="pre">offsets</span></code> and <code class="docutils literal notranslate"><span class="pre">timedelta</span></code>-like can be added if the result can have the same freq. Otherwise, <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> will be raised.</p>
<pre class="literal-block">In [337]: p = pd.Period('2014-07-01 09:00', freq='H')

In [338]: p + pd.offsets.Hour(2)
Out[338]: Period('2014-07-01 11:00', 'H')

In [339]: p + datetime.timedelta(minutes=120)
Out[339]: Period('2014-07-01 11:00', 'H')

In [340]: p + np.timedelta64(7200, 's')
Out[340]: Period('2014-07-01 11:00', 'H')</pre>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">p</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">offsets</span><span class="o">.</span><span class="n">Minute</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">Traceback</span>
<span class="go">   ...</span>
<span class="go">ValueError: Input has different freq from Period(freq=H)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">Period</span></code> has other frequencies, only the same <code class="docutils literal notranslate"><span class="pre">offsets</span></code> can be added. Otherwise, <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> will be raised.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [341]: </span><span class="n">p</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Period</span><span class="p">(</span><span class="s1">&#39;2014-07&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>

<span class="gp">In [342]: </span><span class="n">p</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">offsets</span><span class="o">.</span><span class="n">MonthEnd</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gh">Out[342]: </span><span class="go">Period(&#39;2014-10&#39;, &#39;M&#39;)</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">p</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">offsets</span><span class="o">.</span><span class="n">MonthBegin</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Traceback</span>
<span class="go">   ...</span>
<span class="go">ValueError: Input has different freq from Period(freq=M)</span>
</pre></div>
</div>
<p>Taking the difference of <code class="docutils literal notranslate"><span class="pre">Period</span></code> instances with the same frequency will
return the number of frequency units between them:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [343]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Period</span><span class="p">(</span><span class="s1">&#39;2012&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;A-DEC&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">pd</span><span class="o">.</span><span class="n">Period</span><span class="p">(</span><span class="s1">&#39;2002&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;A-DEC&#39;</span><span class="p">)</span>
<span class="gh">Out[343]: </span><span class="go">&lt;10 * YearEnds: month=12&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="periodindex-and-period-range">
<h3>PeriodIndex and period_range<a class="headerlink" href="#periodindex-and-period-range" title="Permalink to this headline">¶</a></h3>
<p>Regular sequences of <code class="docutils literal notranslate"><span class="pre">Period</span></code> objects can be collected in a <code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code>,
which can be constructed using the <code class="docutils literal notranslate"><span class="pre">period_range</span></code> convenience function:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [344]: </span><span class="n">prng</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">period_range</span><span class="p">(</span><span class="s1">&#39;1/1/2011&#39;</span><span class="p">,</span> <span class="s1">&#39;1/1/2012&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>

<span class="gp">In [345]: </span><span class="n">prng</span>
<span class="gh">Out[345]: </span><span class="go"></span>
<span class="go">PeriodIndex([&#39;2011-01&#39;, &#39;2011-02&#39;, &#39;2011-03&#39;, &#39;2011-04&#39;, &#39;2011-05&#39;, &#39;2011-06&#39;,</span>
<span class="go">             &#39;2011-07&#39;, &#39;2011-08&#39;, &#39;2011-09&#39;, &#39;2011-10&#39;, &#39;2011-11&#39;, &#39;2011-12&#39;,</span>
<span class="go">             &#39;2012-01&#39;],</span>
<span class="go">            dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code> constructor can also be used directly:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [346]: </span><span class="n">pd</span><span class="o">.</span><span class="n">PeriodIndex</span><span class="p">([</span><span class="s1">&#39;2011-1&#39;</span><span class="p">,</span> <span class="s1">&#39;2011-2&#39;</span><span class="p">,</span> <span class="s1">&#39;2011-3&#39;</span><span class="p">],</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
<span class="gh">Out[346]: </span><span class="go">PeriodIndex([&#39;2011-01&#39;, &#39;2011-02&#39;, &#39;2011-03&#39;], dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)</span>
</pre></div>
</div>
<p>Passing multiplied frequency outputs a sequence of <code class="docutils literal notranslate"><span class="pre">Period</span></code> which
has multiplied span.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [347]: </span><span class="n">pd</span><span class="o">.</span><span class="n">period_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="s1">&#39;2014-01&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;3M&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gh">Out[347]: </span><span class="go">PeriodIndex([&#39;2014-01&#39;, &#39;2014-04&#39;, &#39;2014-07&#39;, &#39;2014-10&#39;], dtype=&#39;period[3M]&#39;, freq=&#39;3M&#39;)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">end</span></code> are <code class="docutils literal notranslate"><span class="pre">Period</span></code> objects, they will be used as anchor
endpoints for a <code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code> with frequency matching that of the
<code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code> constructor.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [348]: </span><span class="n">pd</span><span class="o">.</span><span class="n">period_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Period</span><span class="p">(</span><span class="s1">&#39;2017Q1&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;Q&#39;</span><span class="p">),</span>
<span class="gp">   .....: </span>                <span class="n">end</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Period</span><span class="p">(</span><span class="s1">&#39;2017Q2&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;Q&#39;</span><span class="p">),</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
<span class="gp">   .....: </span>
<span class="gh">Out[348]: </span><span class="go">PeriodIndex([&#39;2017-03&#39;, &#39;2017-04&#39;, &#39;2017-05&#39;, &#39;2017-06&#39;], dtype=&#39;period[M]&#39;, freq=&#39;M&#39;)</span>
</pre></div>
</div>
<p>Just like <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>, a <code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code> can also be used to index pandas
objects:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [349]: </span><span class="n">ps</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prng</span><span class="p">)),</span> <span class="n">prng</span><span class="p">)</span>

<span class="gp">In [350]: </span><span class="n">ps</span>
<span class="gh">Out[350]: </span><span class="go"></span>
<span class="go">2011-01   -2.916901</span>
<span class="go">2011-02    0.514474</span>
<span class="go">2011-03    1.346470</span>
<span class="go">2011-04    0.816397</span>
<span class="go">2011-05    2.258648</span>
<span class="go">2011-06    0.494789</span>
<span class="go">2011-07    0.301239</span>
<span class="go">2011-08    0.464776</span>
<span class="go">2011-09   -1.393581</span>
<span class="go">2011-10    0.056780</span>
<span class="go">2011-11    0.197035</span>
<span class="go">2011-12    2.261385</span>
<span class="go">2012-01   -0.329583</span>
<span class="go">Freq: M, dtype: float64</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code> supports addition and subtraction with the same rule as <code class="docutils literal notranslate"><span class="pre">Period</span></code>.</p>
<pre class="literal-block">In [351]: idx = pd.period_range('2014-07-01 09:00', periods=5, freq='H')

In [352]: idx
Out[352]: 
PeriodIndex(['2014-07-01 09:00', '2014-07-01 10:00', '2014-07-01 11:00',
             '2014-07-01 12:00', '2014-07-01 13:00'],
            dtype='period[H]', freq='H')

In [353]: idx + pd.offsets.Hour(2)
Out[353]: 
PeriodIndex(['2014-07-01 11:00', '2014-07-01 12:00', '2014-07-01 13:00',
             '2014-07-01 14:00', '2014-07-01 15:00'],
            dtype='period[H]', freq='H')

In [354]: idx = pd.period_range('2014-07', periods=5, freq='M')

In [355]: idx
Out[355]: PeriodIndex(['2014-07', '2014-08', '2014-09', '2014-10', '2014-11'], dtype='period[M]', freq='M')

In [356]: idx + pd.offsets.MonthEnd(3)
Out[356]: PeriodIndex(['2014-10', '2014-11', '2014-12', '2015-01', '2015-02'], dtype='period[M]', freq='M')</pre>
<p><code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code> has its own dtype named <code class="docutils literal notranslate"><span class="pre">period</span></code>, refer to <a class="reference internal" href="#timeseries-period-dtype"><span class="std std-ref">Period Dtypes</span></a>.</p>
</div>
<div class="section" id="period-dtypes">
<span id="timeseries-period-dtype"></span><h3>Period Dtypes<a class="headerlink" href="#period-dtypes" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.19.0.</span></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code> has a custom <code class="docutils literal notranslate"><span class="pre">period</span></code> dtype. This is a pandas extension
dtype similar to the <a class="reference internal" href="#timeseries-timezone-series"><span class="std std-ref">timezone aware dtype</span></a> (<code class="docutils literal notranslate"><span class="pre">datetime64[ns,</span> <span class="pre">tz]</span></code>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">period</span></code> dtype holds the <code class="docutils literal notranslate"><span class="pre">freq</span></code> attribute and is represented with
<code class="docutils literal notranslate"><span class="pre">period[freq]</span></code> like <code class="docutils literal notranslate"><span class="pre">period[D]</span></code> or <code class="docutils literal notranslate"><span class="pre">period[M]</span></code>, using <a class="reference internal" href="#timeseries-offset-aliases"><span class="std std-ref">frequency strings</span></a>.</p>
<pre class="literal-block">In [357]: pi = pd.period_range('2016-01-01', periods=3, freq='M')

In [358]: pi
Out[358]: PeriodIndex(['2016-01', '2016-02', '2016-03'], dtype='period[M]', freq='M')

In [359]: pi.dtype
Out[359]: period[M]</pre>
<p>The <code class="docutils literal notranslate"><span class="pre">period</span></code> dtype can be used in <code class="docutils literal notranslate"><span class="pre">.astype(...)</span></code>. It allows one to change the
<code class="docutils literal notranslate"><span class="pre">freq</span></code> of a <code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code> like <code class="docutils literal notranslate"><span class="pre">.asfreq()</span></code> and convert a
<code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> to <code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code> like <code class="docutils literal notranslate"><span class="pre">to_period()</span></code>:</p>
<pre class="literal-block"># change monthly freq to daily freq
In [360]: pi.astype('period[D]')
Out[360]: PeriodIndex(['2016-01-31', '2016-02-29', '2016-03-31'], dtype='period[D]', freq='D')

# convert to DatetimeIndex
In [361]: pi.astype('datetime64[ns]')
Out[361]: DatetimeIndex(['2016-01-01', '2016-02-01', '2016-03-01'], dtype='datetime64[ns]', freq='MS')

# convert to PeriodIndex
In [362]: dti = pd.date_range('2011-01-01', freq='M', periods=3)

In [363]: dti
Out[363]: DatetimeIndex(['2011-01-31', '2011-02-28', '2011-03-31'], dtype='datetime64[ns]', freq='M')

In [364]: dti.astype('period[M]')
Out[364]: PeriodIndex(['2011-01', '2011-02', '2011-03'], dtype='period[M]', freq='M')</pre>
</div>
<div class="section" id="periodindex-partial-string-indexing">
<h3>PeriodIndex Partial String Indexing<a class="headerlink" href="#periodindex-partial-string-indexing" title="Permalink to this headline">¶</a></h3>
<p>You can pass in dates and strings to <code class="docutils literal notranslate"><span class="pre">Series</span></code> and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> with <code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code>, in the same manner as <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>. For details, refer to <a class="reference internal" href="#timeseries-partialindexing"><span class="std std-ref">DatetimeIndex Partial String Indexing</span></a>.</p>
<pre class="literal-block">In [365]: ps['2011-01']
Out[365]: -2.9169013294054507

In [366]: ps[datetime.datetime(2011, 12, 25):]
Out[366]: 
2011-12    2.261385
2012-01   -0.329583
Freq: M, dtype: float64

In [367]: ps['10/31/2011':'12/31/2011']
Out[367]: 
2011-10    0.056780
2011-11    0.197035
2011-12    2.261385
Freq: M, dtype: float64</pre>
<p>Passing a string representing a lower frequency than <code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code> returns partial sliced data.</p>
<pre class="literal-block">In [368]: ps['2011']
Out[368]: 
2011-01   -2.916901
2011-02    0.514474
2011-03    1.346470
2011-04    0.816397
2011-05    2.258648
2011-06    0.494789
2011-07    0.301239
2011-08    0.464776
2011-09   -1.393581
2011-10    0.056780
2011-11    0.197035
2011-12    2.261385
Freq: M, dtype: float64

In [369]: dfp = pd.DataFrame(np.random.randn(600, 1),
   .....:                    columns=['A'],
   .....:                    index=pd.period_range('2013-01-01 9:00',
   .....:                                          periods=600,
   .....:                                          freq='T'))
   .....: 

In [370]: dfp
Out[370]: 
                         A
2013-01-01 09:00 -0.538468
2013-01-01 09:01 -1.365819
2013-01-01 09:02 -0.969051
2013-01-01 09:03 -0.331152
2013-01-01 09:04 -0.245334
...                    ...
2013-01-01 18:55  0.522460
2013-01-01 18:56  0.118710
2013-01-01 18:57  0.167517
2013-01-01 18:58  0.922883
2013-01-01 18:59  1.721104

[600 rows x 1 columns]

In [371]: dfp['2013-01-01 10H']
Out[371]: 
                         A
2013-01-01 10:00 -0.308975
2013-01-01 10:01  0.542520
2013-01-01 10:02  1.061068
2013-01-01 10:03  0.754005
2013-01-01 10:04  0.352933
...                    ...
2013-01-01 10:55 -0.865621
2013-01-01 10:56 -1.167818
2013-01-01 10:57 -2.081748
2013-01-01 10:58 -0.527146
2013-01-01 10:59  0.802298

[60 rows x 1 columns]</pre>
<p>As with <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>, the endpoints will be included in the result. The example below slices data starting from 10:00 to 11:59.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [372]: </span><span class="n">dfp</span><span class="p">[</span><span class="s1">&#39;2013-01-01 10H&#39;</span><span class="p">:</span><span class="s1">&#39;2013-01-01 11H&#39;</span><span class="p">]</span>
<span class="gh">Out[372]: </span><span class="go"></span>
<span class="go">                         A</span>
<span class="go">2013-01-01 10:00 -0.308975</span>
<span class="go">2013-01-01 10:01  0.542520</span>
<span class="go">2013-01-01 10:02  1.061068</span>
<span class="go">2013-01-01 10:03  0.754005</span>
<span class="go">2013-01-01 10:04  0.352933</span>
<span class="go">...                    ...</span>
<span class="go">2013-01-01 11:55 -0.590204</span>
<span class="go">2013-01-01 11:56  1.539990</span>
<span class="go">2013-01-01 11:57 -1.224826</span>
<span class="go">2013-01-01 11:58  0.578798</span>
<span class="go">2013-01-01 11:59 -0.685496</span>

<span class="go">[120 rows x 1 columns]</span>
</pre></div>
</div>
</div>
<div class="section" id="frequency-conversion-and-resampling-with-periodindex">
<h3>Frequency Conversion and Resampling with PeriodIndex<a class="headerlink" href="#frequency-conversion-and-resampling-with-periodindex" title="Permalink to this headline">¶</a></h3>
<p>The frequency of <code class="docutils literal notranslate"><span class="pre">Period</span></code> and <code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code> can be converted via the <code class="docutils literal notranslate"><span class="pre">asfreq</span></code>
method. Let’s start with the fiscal year 2011, ending in December:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [373]: </span><span class="n">p</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Period</span><span class="p">(</span><span class="s1">&#39;2011&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;A-DEC&#39;</span><span class="p">)</span>

<span class="gp">In [374]: </span><span class="n">p</span>
<span class="gh">Out[374]: </span><span class="go">Period(&#39;2011&#39;, &#39;A-DEC&#39;)</span>
</pre></div>
</div>
<p>We can convert it to a monthly frequency. Using the <code class="docutils literal notranslate"><span class="pre">how</span></code> parameter, we can
specify whether to return the starting or ending month:</p>
<pre class="literal-block">In [375]: p.asfreq('M', how='start')
Out[375]: Period('2011-01', 'M')

In [376]: p.asfreq('M', how='end')
Out[376]: Period('2011-12', 'M')</pre>
<p>The shorthands ‘s’ and ‘e’ are provided for convenience:</p>
<pre class="literal-block">In [377]: p.asfreq('M', 's')
Out[377]: Period('2011-01', 'M')

In [378]: p.asfreq('M', 'e')
Out[378]: Period('2011-12', 'M')</pre>
<p>Converting to a “super-period” (e.g., annual frequency is a super-period of
quarterly frequency) automatically returns the super-period that includes the
input period:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [379]: </span><span class="n">p</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Period</span><span class="p">(</span><span class="s1">&#39;2011-12&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>

<span class="gp">In [380]: </span><span class="n">p</span><span class="o">.</span><span class="n">asfreq</span><span class="p">(</span><span class="s1">&#39;A-NOV&#39;</span><span class="p">)</span>
<span class="gh">Out[380]: </span><span class="go">Period(&#39;2012&#39;, &#39;A-NOV&#39;)</span>
</pre></div>
</div>
<p>Note that since we converted to an annual frequency that ends the year in
November, the monthly period of December 2011 is actually in the 2012 A-NOV
period.</p>
<p id="timeseries-quarterly">Period conversions with anchored frequencies are particularly useful for
working with various quarterly data common to economics, business, and other
fields. Many organizations define quarters relative to the month in which their
fiscal year starts and ends. Thus, first quarter of 2011 could start in 2010 or
a few months into 2011. Via anchored frequencies, pandas works for all quarterly
frequencies <code class="docutils literal notranslate"><span class="pre">Q-JAN</span></code> through <code class="docutils literal notranslate"><span class="pre">Q-DEC</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">Q-DEC</span></code> define regular calendar quarters:</p>
<pre class="literal-block">In [381]: p = pd.Period('2012Q1', freq='Q-DEC')

In [382]: p.asfreq('D', 's')
Out[382]: Period('2012-01-01', 'D')

In [383]: p.asfreq('D', 'e')
Out[383]: Period('2012-03-31', 'D')</pre>
<p><code class="docutils literal notranslate"><span class="pre">Q-MAR</span></code> defines fiscal year end in March:</p>
<pre class="literal-block">In [384]: p = pd.Period('2011Q4', freq='Q-MAR')

In [385]: p.asfreq('D', 's')
Out[385]: Period('2011-01-01', 'D')

In [386]: p.asfreq('D', 'e')
Out[386]: Period('2011-03-31', 'D')</pre>
</div>
</div>
<div class="section" id="converting-between-representations">
<span id="timeseries-interchange"></span><h2>Converting Between Representations<a class="headerlink" href="#converting-between-representations" title="Permalink to this headline">¶</a></h2>
<p>Timestamped data can be converted to PeriodIndex-ed data using <code class="docutils literal notranslate"><span class="pre">to_period</span></code>
and vice-versa using <code class="docutils literal notranslate"><span class="pre">to_timestamp</span></code>:</p>
<pre class="literal-block">In [387]: rng = pd.date_range('1/1/2012', periods=5, freq='M')

In [388]: ts = pd.Series(np.random.randn(len(rng)), index=rng)

In [389]: ts
Out[389]: 
2012-01-31    1.931253
2012-02-29   -0.184594
2012-03-31    0.249656
2012-04-30   -0.978151
2012-05-31   -0.873389
Freq: M, dtype: float64

In [390]: ps = ts.to_period()

In [391]: ps
Out[391]: 
2012-01    1.931253
2012-02   -0.184594
2012-03    0.249656
2012-04   -0.978151
2012-05   -0.873389
Freq: M, dtype: float64

In [392]: ps.to_timestamp()
Out[392]: 
2012-01-01    1.931253
2012-02-01   -0.184594
2012-03-01    0.249656
2012-04-01   -0.978151
2012-05-01   -0.873389
Freq: MS, dtype: float64</pre>
<p>Remember that ‘s’ and ‘e’ can be used to return the timestamps at the start or
end of the period:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [393]: </span><span class="n">ps</span><span class="o">.</span><span class="n">to_timestamp</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
<span class="gh">Out[393]: </span><span class="go"></span>
<span class="go">2012-01-01    1.931253</span>
<span class="go">2012-02-01   -0.184594</span>
<span class="go">2012-03-01    0.249656</span>
<span class="go">2012-04-01   -0.978151</span>
<span class="go">2012-05-01   -0.873389</span>
<span class="go">Freq: MS, dtype: float64</span>
</pre></div>
</div>
<p>Converting between period and timestamp enables some convenient arithmetic
functions to be used. In the following example, we convert a quarterly
frequency with year ending in November to 9am of the end of the month following
the quarter end:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [394]: </span><span class="n">prng</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">period_range</span><span class="p">(</span><span class="s1">&#39;1990Q1&#39;</span><span class="p">,</span> <span class="s1">&#39;2000Q4&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;Q-NOV&#39;</span><span class="p">)</span>

<span class="gp">In [395]: </span><span class="n">ts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prng</span><span class="p">)),</span> <span class="n">prng</span><span class="p">)</span>

<span class="gp">In [396]: </span><span class="n">ts</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">prng</span><span class="o">.</span><span class="n">asfreq</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">asfreq</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">9</span>

<span class="gp">In [397]: </span><span class="n">ts</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
<span class="gh">Out[397]: </span><span class="go"></span>
<span class="go">1990-03-01 09:00   -0.109291</span>
<span class="go">1990-06-01 09:00   -0.637235</span>
<span class="go">1990-09-01 09:00   -1.735925</span>
<span class="go">1990-12-01 09:00    2.096946</span>
<span class="go">1991-03-01 09:00   -1.039926</span>
<span class="go">Freq: H, dtype: float64</span>
</pre></div>
</div>
</div>
<div class="section" id="representing-out-of-bounds-spans">
<span id="timeseries-oob"></span><h2>Representing Out-of-Bounds Spans<a class="headerlink" href="#representing-out-of-bounds-spans" title="Permalink to this headline">¶</a></h2>
<p>If you have data that is outside of the <code class="docutils literal notranslate"><span class="pre">Timestamp</span></code> bounds, see <a class="reference internal" href="#timeseries-timestamp-limits"><span class="std std-ref">Timestamp limitations</span></a>,
then you can use a <code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code> and/or <code class="docutils literal notranslate"><span class="pre">Series</span></code> of <code class="docutils literal notranslate"><span class="pre">Periods</span></code> to do computations.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [398]: </span><span class="n">span</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">period_range</span><span class="p">(</span><span class="s1">&#39;1215-01-01&#39;</span><span class="p">,</span> <span class="s1">&#39;1381-01-01&#39;</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>

<span class="gp">In [399]: </span><span class="n">span</span>
<span class="gh">Out[399]: </span><span class="go"></span>
<span class="go">PeriodIndex([&#39;1215-01-01&#39;, &#39;1215-01-02&#39;, &#39;1215-01-03&#39;, &#39;1215-01-04&#39;,</span>
<span class="go">             &#39;1215-01-05&#39;, &#39;1215-01-06&#39;, &#39;1215-01-07&#39;, &#39;1215-01-08&#39;,</span>
<span class="go">             &#39;1215-01-09&#39;, &#39;1215-01-10&#39;,</span>
<span class="go">             ...</span>
<span class="go">             &#39;1380-12-23&#39;, &#39;1380-12-24&#39;, &#39;1380-12-25&#39;, &#39;1380-12-26&#39;,</span>
<span class="go">             &#39;1380-12-27&#39;, &#39;1380-12-28&#39;, &#39;1380-12-29&#39;, &#39;1380-12-30&#39;,</span>
<span class="go">             &#39;1380-12-31&#39;, &#39;1381-01-01&#39;],</span>
<span class="go">            dtype=&#39;period[D]&#39;, length=60632, freq=&#39;D&#39;)</span>
</pre></div>
</div>
<p>To convert from an <code class="docutils literal notranslate"><span class="pre">int64</span></code> based YYYYMMDD representation.</p>
<pre class="literal-block">In [400]: s = pd.Series([20121231, 20141130, 99991231])

In [401]: s
Out[401]: 
0    20121231
1    20141130
2    99991231
dtype: int64

In [402]: def conv(x):
   .....:     return pd.Period(year=x // 10000, month=x // 100 % 100,
   .....:                      day=x % 100, freq='D')
   .....: 

In [403]: s.apply(conv)
Out[403]: 
0    2012-12-31
1    2014-11-30
2    9999-12-31
dtype: period[D]

In [404]: s.apply(conv)[2]
Out[404]: Period('9999-12-31', 'D')</pre>
<p>These can easily be converted to a <code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [405]: </span><span class="n">span</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">PeriodIndex</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">conv</span><span class="p">))</span>

<span class="gp">In [406]: </span><span class="n">span</span>
<span class="gh">Out[406]: </span><span class="go">PeriodIndex([&#39;2012-12-31&#39;, &#39;2014-11-30&#39;, &#39;9999-12-31&#39;], dtype=&#39;period[D]&#39;, freq=&#39;D&#39;)</span>
</pre></div>
</div>
</div>
<div class="section" id="time-zone-handling">
<span id="timeseries-timezone"></span><h2>Time Zone Handling<a class="headerlink" href="#time-zone-handling" title="Permalink to this headline">¶</a></h2>
<p>pandas provides rich support for working with timestamps in different time
zones using the <code class="docutils literal notranslate"><span class="pre">pytz</span></code> and <code class="docutils literal notranslate"><span class="pre">dateutil</span></code> libraries or class:<cite>datetime.timezone</cite>
objects from the standard library.</p>
<div class="section" id="working-with-time-zones">
<h3>Working with Time Zones<a class="headerlink" href="#working-with-time-zones" title="Permalink to this headline">¶</a></h3>
<p>By default, pandas objects are time zone unaware:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [407]: </span><span class="n">rng</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;3/6/2012 00:00&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>

<span class="gp">In [408]: </span><span class="n">rng</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="gh">Out[408]: </span><span class="go">True</span>
</pre></div>
</div>
<p>To localize these dates to a time zone (assign a particular time zone to a naive date),
you can use the <code class="docutils literal notranslate"><span class="pre">tz_localize</span></code> method or the <code class="docutils literal notranslate"><span class="pre">tz</span></code> keyword argument in
<a class="reference internal" href="../reference/api/pandas.date_range.html#pandas.date_range" title="pandas.date_range"><code class="xref py py-func docutils literal notranslate"><span class="pre">date_range()</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Timestamp</span></code>, or <code class="xref py py-class docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>.
You can either pass <code class="docutils literal notranslate"><span class="pre">pytz</span></code> or <code class="docutils literal notranslate"><span class="pre">dateutil</span></code> time zone objects or Olson time zone database strings.
Olson time zone strings will return <code class="docutils literal notranslate"><span class="pre">pytz</span></code> time zone objects by default.
To return <code class="docutils literal notranslate"><span class="pre">dateutil</span></code> time zone objects, append <code class="docutils literal notranslate"><span class="pre">dateutil/</span></code> before the string.</p>
<ul class="simple">
<li><p>In <code class="docutils literal notranslate"><span class="pre">pytz</span></code> you can find a list of common (and less common) time zones using
<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">pytz</span> <span class="pre">import</span> <span class="pre">common_timezones,</span> <span class="pre">all_timezones</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dateutil</span></code> uses the OS time zones so there isn’t a fixed list available. For
common zones, the names are the same as <code class="docutils literal notranslate"><span class="pre">pytz</span></code>.</p></li>
</ul>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [409]: </span><span class="kn">import</span> <span class="nn">dateutil</span>

<span class="go"># pytz</span>
<span class="gp">In [410]: </span><span class="n">rng_pytz</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;3/6/2012 00:00&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">,</span>
<span class="gp">   .....: </span>                         <span class="n">tz</span><span class="o">=</span><span class="s1">&#39;Europe/London&#39;</span><span class="p">)</span>
<span class="gp">   .....: </span>

<span class="gp">In [411]: </span><span class="n">rng_pytz</span><span class="o">.</span><span class="n">tz</span>
<span class="gh">Out[411]: </span><span class="go">&lt;DstTzInfo &#39;Europe/London&#39; LMT-1 day, 23:59:00 STD&gt;</span>

<span class="go"># dateutil</span>
<span class="gp">In [412]: </span><span class="n">rng_dateutil</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;3/6/2012 00:00&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>

<span class="gp">In [413]: </span><span class="n">rng_dateutil</span> <span class="o">=</span> <span class="n">rng_dateutil</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="s1">&#39;dateutil/Europe/London&#39;</span><span class="p">)</span>

<span class="gp">In [414]: </span><span class="n">rng_dateutil</span><span class="o">.</span><span class="n">tz</span>
<span class="gh">Out[414]: </span><span class="go">tzfile(&#39;/usr/share/zoneinfo/Europe/London&#39;)</span>

<span class="go"># dateutil - utc special case</span>
<span class="gp">In [415]: </span><span class="n">rng_utc</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;3/6/2012 00:00&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">,</span>
<span class="gp">   .....: </span>                        <span class="n">tz</span><span class="o">=</span><span class="n">dateutil</span><span class="o">.</span><span class="n">tz</span><span class="o">.</span><span class="n">tzutc</span><span class="p">())</span>
<span class="gp">   .....: </span>

<span class="gp">In [416]: </span><span class="n">rng_utc</span><span class="o">.</span><span class="n">tz</span>
<span class="gh">Out[416]: </span><span class="go">tzutc()</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.25.0.</span></p>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># datetime.timezone</span>
<span class="gp">In [417]: </span><span class="n">rng_utc</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;3/6/2012 00:00&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">,</span>
<span class="gp">   .....: </span>                        <span class="n">tz</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>
<span class="gp">   .....: </span>

<span class="gp">In [418]: </span><span class="n">rng_utc</span><span class="o">.</span><span class="n">tz</span>
<span class="gh">Out[418]: </span><span class="go">datetime.timezone.utc</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">UTC</span></code> time zone is a special case in <code class="docutils literal notranslate"><span class="pre">dateutil</span></code> and should be constructed explicitly
as an instance of <code class="docutils literal notranslate"><span class="pre">dateutil.tz.tzutc</span></code>. You can also construct other time
zones objects explicitly first.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [419]: </span><span class="kn">import</span> <span class="nn">pytz</span>

<span class="go"># pytz</span>
<span class="gp">In [420]: </span><span class="n">tz_pytz</span> <span class="o">=</span> <span class="n">pytz</span><span class="o">.</span><span class="n">timezone</span><span class="p">(</span><span class="s1">&#39;Europe/London&#39;</span><span class="p">)</span>

<span class="gp">In [421]: </span><span class="n">rng_pytz</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;3/6/2012 00:00&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>

<span class="gp">In [422]: </span><span class="n">rng_pytz</span> <span class="o">=</span> <span class="n">rng_pytz</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">tz_pytz</span><span class="p">)</span>

<span class="gp">In [423]: </span><span class="n">rng_pytz</span><span class="o">.</span><span class="n">tz</span> <span class="o">==</span> <span class="n">tz_pytz</span>
<span class="gh">Out[423]: </span><span class="go">True</span>

<span class="go"># dateutil</span>
<span class="gp">In [424]: </span><span class="n">tz_dateutil</span> <span class="o">=</span> <span class="n">dateutil</span><span class="o">.</span><span class="n">tz</span><span class="o">.</span><span class="n">gettz</span><span class="p">(</span><span class="s1">&#39;Europe/London&#39;</span><span class="p">)</span>

<span class="gp">In [425]: </span><span class="n">rng_dateutil</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;3/6/2012 00:00&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">,</span>
<span class="gp">   .....: </span>                             <span class="n">tz</span><span class="o">=</span><span class="n">tz_dateutil</span><span class="p">)</span>
<span class="gp">   .....: </span>

<span class="gp">In [426]: </span><span class="n">rng_dateutil</span><span class="o">.</span><span class="n">tz</span> <span class="o">==</span> <span class="n">tz_dateutil</span>
<span class="gh">Out[426]: </span><span class="go">True</span>
</pre></div>
</div>
<p>To convert a time zone aware pandas object from one time zone to another,
you can use the <code class="docutils literal notranslate"><span class="pre">tz_convert</span></code> method.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [427]: </span><span class="n">rng_pytz</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="s1">&#39;US/Eastern&#39;</span><span class="p">)</span>
<span class="gh">Out[427]: </span><span class="go"></span>
<span class="go">DatetimeIndex([&#39;2012-03-05 19:00:00-05:00&#39;, &#39;2012-03-06 19:00:00-05:00&#39;,</span>
<span class="go">               &#39;2012-03-07 19:00:00-05:00&#39;],</span>
<span class="go">              dtype=&#39;datetime64[ns, US/Eastern]&#39;, freq=&#39;D&#39;)</span>
</pre></div>
</div>
<div class="alert alert-info">
<p class="admonition-title">Note</p>
<p>When using <code class="docutils literal notranslate"><span class="pre">pytz</span></code> time zones, <code class="xref py py-class docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> will construct a different
time zone object than a <code class="xref py py-class docutils literal notranslate"><span class="pre">Timestamp</span></code> for the same time zone input. A <code class="xref py py-class docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>
can hold a collection of <code class="xref py py-class docutils literal notranslate"><span class="pre">Timestamp</span></code> objects that may have different UTC offsets and cannot be
succinctly represented by one <code class="docutils literal notranslate"><span class="pre">pytz</span></code> time zone instance while one <code class="xref py py-class docutils literal notranslate"><span class="pre">Timestamp</span></code>
represents one point in time with a specific UTC offset.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [428]: </span><span class="n">dti</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;2019-01-01&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="s1">&#39;US/Pacific&#39;</span><span class="p">)</span>

<span class="gp">In [429]: </span><span class="n">dti</span><span class="o">.</span><span class="n">tz</span>
<span class="gh">Out[429]: </span><span class="go">&lt;DstTzInfo &#39;US/Pacific&#39; LMT-1 day, 16:07:00 STD&gt;</span>

<span class="gp">In [430]: </span><span class="n">ts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;2019-01-01&#39;</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="s1">&#39;US/Pacific&#39;</span><span class="p">)</span>

<span class="gp">In [431]: </span><span class="n">ts</span><span class="o">.</span><span class="n">tz</span>
<span class="gh">Out[431]: </span><span class="go">&lt;DstTzInfo &#39;US/Pacific&#39; PST-1 day, 16:00:00 STD&gt;</span>
</pre></div>
</div>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Be wary of conversions between libraries. For some time zones, <code class="docutils literal notranslate"><span class="pre">pytz</span></code> and <code class="docutils literal notranslate"><span class="pre">dateutil</span></code> have different
definitions of the zone. This is more of a problem for unusual time zones than for
‘standard’ zones like <code class="docutils literal notranslate"><span class="pre">US/Eastern</span></code>.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Be aware that a time zone definition across versions of time zone libraries may not
be considered equal.  This may cause problems when working with stored data that
is localized using one version and operated on with a different version.
See <a class="reference internal" href="io.html#io-hdf5-notes"><span class="std std-ref">here</span></a> for how to handle such a situation.</p>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>For <code class="docutils literal notranslate"><span class="pre">pytz</span></code> time zones, it is incorrect to pass a time zone object directly into
the <code class="docutils literal notranslate"><span class="pre">datetime.datetime</span></code> constructor
(e.g., <code class="docutils literal notranslate"><span class="pre">datetime.datetime(2011,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">tz=pytz.timezone('US/Eastern'))</span></code>.
Instead, the datetime needs to be localized using the <code class="docutils literal notranslate"><span class="pre">localize</span></code> method
on the <code class="docutils literal notranslate"><span class="pre">pytz</span></code> time zone object.</p>
</div>
<p>Under the hood, all timestamps are stored in UTC. Values from a time zone aware
<code class="xref py py-class docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">Timestamp</span></code> will have their fields (day, hour, minute, etc.)
localized to the time zone. However, timestamps with the same UTC value are
still considered to be equal even if they are in different time zones:</p>
<pre class="literal-block">In [432]: rng_eastern = rng_utc.tz_convert('US/Eastern')

In [433]: rng_berlin = rng_utc.tz_convert('Europe/Berlin')

In [434]: rng_eastern[2]
Out[434]: Timestamp('2012-03-07 19:00:00-0500', tz='US/Eastern', freq='D')

In [435]: rng_berlin[2]
Out[435]: Timestamp('2012-03-08 01:00:00+0100', tz='Europe/Berlin', freq='D')

In [436]: rng_eastern[2] == rng_berlin[2]
Out[436]: True</pre>
<p>Operations between <code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code> in different time zones will yield UTC
<code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code>, aligning the data on the UTC timestamps:</p>
<pre class="literal-block">In [437]: ts_utc = pd.Series(range(3), pd.date_range('20130101', periods=3, tz='UTC'))

In [438]: eastern = ts_utc.tz_convert('US/Eastern')

In [439]: berlin = ts_utc.tz_convert('Europe/Berlin')

In [440]: result = eastern + berlin

In [441]: result
Out[441]: 
2013-01-01 00:00:00+00:00    0
2013-01-02 00:00:00+00:00    2
2013-01-03 00:00:00+00:00    4
Freq: D, dtype: int64

In [442]: result.index
Out[442]: 
DatetimeIndex(['2013-01-01 00:00:00+00:00', '2013-01-02 00:00:00+00:00',
               '2013-01-03 00:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='D')</pre>
<p>To remove time zone information, use <code class="docutils literal notranslate"><span class="pre">tz_localize(None)</span></code> or <code class="docutils literal notranslate"><span class="pre">tz_convert(None)</span></code>.
<code class="docutils literal notranslate"><span class="pre">tz_localize(None)</span></code> will remove the time zone yielding the local time representation.
<code class="docutils literal notranslate"><span class="pre">tz_convert(None)</span></code> will remove the time zone after converting to UTC time.</p>
<pre class="literal-block">In [443]: didx = pd.date_range(start='2014-08-01 09:00', freq='H',
   .....:                      periods=3, tz='US/Eastern')
   .....: 

In [444]: didx
Out[444]: 
DatetimeIndex(['2014-08-01 09:00:00-04:00', '2014-08-01 10:00:00-04:00',
               '2014-08-01 11:00:00-04:00'],
              dtype='datetime64[ns, US/Eastern]', freq='H')

In [445]: didx.tz_localize(None)
Out[445]: 
DatetimeIndex(['2014-08-01 09:00:00', '2014-08-01 10:00:00',
               '2014-08-01 11:00:00'],
              dtype='datetime64[ns]', freq='H')

In [446]: didx.tz_convert(None)
Out[446]: 
DatetimeIndex(['2014-08-01 13:00:00', '2014-08-01 14:00:00',
               '2014-08-01 15:00:00'],
              dtype='datetime64[ns]', freq='H')

# tz_convert(None) is identical to tz_convert('UTC').tz_localize(None)
In [447]: didx.tz_convert('UTC').tz_localize(None)
Out[447]: 
DatetimeIndex(['2014-08-01 13:00:00', '2014-08-01 14:00:00',
               '2014-08-01 15:00:00'],
              dtype='datetime64[ns]', freq='H')</pre>
</div>
<div class="section" id="ambiguous-times-when-localizing">
<span id="timeseries-timezone-ambiguous"></span><h3>Ambiguous Times when Localizing<a class="headerlink" href="#ambiguous-times-when-localizing" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">tz_localize</span></code> may not be able to determine the UTC offset of a timestamp
because daylight savings time (DST) in a local time zone causes some times to occur
twice within one day (“clocks fall back”). The following options are available:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'raise'</span></code>: Raises a <code class="docutils literal notranslate"><span class="pre">pytz.AmbiguousTimeError</span></code> (the default behavior)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'infer'</span></code>: Attempt to determine the correct offset base on the monotonicity of the timestamps</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'NaT'</span></code>: Replaces ambiguous times with <code class="docutils literal notranslate"><span class="pre">NaT</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span></code>: <code class="docutils literal notranslate"><span class="pre">True</span></code> represents a DST time, <code class="docutils literal notranslate"><span class="pre">False</span></code> represents non-DST time. An array-like of <code class="docutils literal notranslate"><span class="pre">bool</span></code> values is supported for a sequence of times.</p></li>
</ul>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [448]: </span><span class="n">rng_hourly</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">([</span><span class="s1">&#39;11/06/2011 00:00&#39;</span><span class="p">,</span> <span class="s1">&#39;11/06/2011 01:00&#39;</span><span class="p">,</span>
<span class="gp">   .....: </span>                               <span class="s1">&#39;11/06/2011 01:00&#39;</span><span class="p">,</span> <span class="s1">&#39;11/06/2011 02:00&#39;</span><span class="p">])</span>
<span class="gp">   .....: </span>
</pre></div>
</div>
<p>This will fail as there are ambiguous times (<code class="docutils literal notranslate"><span class="pre">'11/06/2011</span> <span class="pre">01:00'</span></code>)</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [2]: </span><span class="n">rng_hourly</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="s1">&#39;US/Eastern&#39;</span><span class="p">)</span>
<span class="go">AmbiguousTimeError: Cannot infer dst time from Timestamp(&#39;2011-11-06 01:00:00&#39;), try using the &#39;ambiguous&#39; argument</span>
</pre></div>
</div>
<p>Handle these ambiguous times by specifying the following.</p>
<pre class="literal-block">In [449]: rng_hourly.tz_localize('US/Eastern', ambiguous='infer')
Out[449]: 
DatetimeIndex(['2011-11-06 00:00:00-04:00', '2011-11-06 01:00:00-04:00',
               '2011-11-06 01:00:00-05:00', '2011-11-06 02:00:00-05:00'],
              dtype='datetime64[ns, US/Eastern]', freq=None)

In [450]: rng_hourly.tz_localize('US/Eastern', ambiguous='NaT')
Out[450]: 
DatetimeIndex(['2011-11-06 00:00:00-04:00', 'NaT', 'NaT',
               '2011-11-06 02:00:00-05:00'],
              dtype='datetime64[ns, US/Eastern]', freq=None)

In [451]: rng_hourly.tz_localize('US/Eastern', ambiguous=[True, True, False, False])
Out[451]: 
DatetimeIndex(['2011-11-06 00:00:00-04:00', '2011-11-06 01:00:00-04:00',
               '2011-11-06 01:00:00-05:00', '2011-11-06 02:00:00-05:00'],
              dtype='datetime64[ns, US/Eastern]', freq=None)</pre>
</div>
<div class="section" id="nonexistent-times-when-localizing">
<span id="timeseries-timezone-nonexistent"></span><h3>Nonexistent Times when Localizing<a class="headerlink" href="#nonexistent-times-when-localizing" title="Permalink to this headline">¶</a></h3>
<p>A DST transition may also shift the local time ahead by 1 hour creating nonexistent
local times (“clocks spring forward”). The behavior of localizing a timeseries with nonexistent times
can be controlled by the <code class="docutils literal notranslate"><span class="pre">nonexistent</span></code> argument. The following options are available:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'raise'</span></code>: Raises a <code class="docutils literal notranslate"><span class="pre">pytz.NonExistentTimeError</span></code> (the default behavior)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'NaT'</span></code>: Replaces nonexistent times with <code class="docutils literal notranslate"><span class="pre">NaT</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'shift_forward'</span></code>: Shifts nonexistent times forward to the closest real time</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'shift_backward'</span></code>: Shifts nonexistent times backward to the closest real time</p></li>
<li><p>timedelta object: Shifts nonexistent times by the timedelta duration</p></li>
</ul>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [452]: </span><span class="n">dti</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="s1">&#39;2015-03-29 02:30:00&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>

<span class="go"># 2:30 is a nonexistent time</span>
</pre></div>
</div>
<p>Localization of nonexistent times will raise an error by default.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [2]: </span><span class="n">dti</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="s1">&#39;Europe/Warsaw&#39;</span><span class="p">)</span>
<span class="go">NonExistentTimeError: 2015-03-29 02:30:00</span>
</pre></div>
</div>
<p>Transform nonexistent times to <code class="docutils literal notranslate"><span class="pre">NaT</span></code> or shift the times.</p>
<pre class="literal-block">In [453]: dti
Out[453]: 
DatetimeIndex(['2015-03-29 02:30:00', '2015-03-29 03:30:00',
               '2015-03-29 04:30:00'],
              dtype='datetime64[ns]', freq='H')

In [454]: dti.tz_localize('Europe/Warsaw', nonexistent='shift_forward')
Out[454]: 
DatetimeIndex(['2015-03-29 03:00:00+02:00', '2015-03-29 03:30:00+02:00',
               '2015-03-29 04:30:00+02:00'],
              dtype='datetime64[ns, Europe/Warsaw]', freq='H')

In [455]: dti.tz_localize('Europe/Warsaw', nonexistent='shift_backward')
Out[455]: 
DatetimeIndex(['2015-03-29 01:59:59.999999999+01:00',
                         '2015-03-29 03:30:00+02:00',
                         '2015-03-29 04:30:00+02:00'],
              dtype='datetime64[ns, Europe/Warsaw]', freq='H')

In [456]: dti.tz_localize('Europe/Warsaw', nonexistent=pd.Timedelta(1, unit='H'))
Out[456]: 
DatetimeIndex(['2015-03-29 03:30:00+02:00', '2015-03-29 03:30:00+02:00',
               '2015-03-29 04:30:00+02:00'],
              dtype='datetime64[ns, Europe/Warsaw]', freq='H')

In [457]: dti.tz_localize('Europe/Warsaw', nonexistent='NaT')
Out[457]: 
DatetimeIndex(['NaT', '2015-03-29 03:30:00+02:00',
               '2015-03-29 04:30:00+02:00'],
              dtype='datetime64[ns, Europe/Warsaw]', freq='H')</pre>
</div>
<div class="section" id="time-zone-series-operations">
<span id="timeseries-timezone-series"></span><h3>Time Zone Series Operations<a class="headerlink" href="#time-zone-series-operations" title="Permalink to this headline">¶</a></h3>
<p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code> with time zone <strong>naive</strong> values is
represented with a dtype of <code class="docutils literal notranslate"><span class="pre">datetime64[ns]</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [458]: </span><span class="n">s_naive</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;20130101&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>

<span class="gp">In [459]: </span><span class="n">s_naive</span>
<span class="gh">Out[459]: </span><span class="go"></span>
<span class="go">0   2013-01-01</span>
<span class="go">1   2013-01-02</span>
<span class="go">2   2013-01-03</span>
<span class="go">dtype: datetime64[ns]</span>
</pre></div>
</div>
<p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code> with a time zone <strong>aware</strong> values is
represented with a dtype of <code class="docutils literal notranslate"><span class="pre">datetime64[ns,</span> <span class="pre">tz]</span></code> where <code class="docutils literal notranslate"><span class="pre">tz</span></code> is the time zone</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [460]: </span><span class="n">s_aware</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span><span class="s1">&#39;20130101&#39;</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="s1">&#39;US/Eastern&#39;</span><span class="p">))</span>

<span class="gp">In [461]: </span><span class="n">s_aware</span>
<span class="gh">Out[461]: </span><span class="go"></span>
<span class="go">0   2013-01-01 00:00:00-05:00</span>
<span class="go">1   2013-01-02 00:00:00-05:00</span>
<span class="go">2   2013-01-03 00:00:00-05:00</span>
<span class="go">dtype: datetime64[ns, US/Eastern]</span>
</pre></div>
</div>
<p>Both of these <code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code> time zone information
can be manipulated via the <code class="docutils literal notranslate"><span class="pre">.dt</span></code> accessor, see <a class="reference internal" href="../getting_started/basics.html#basics-dt-accessors"><span class="std std-ref">the dt accessor section</span></a>.</p>
<p>For example, to localize and convert a naive stamp to time zone aware.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [462]: </span><span class="n">s_naive</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="s1">&#39;UTC&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="s1">&#39;US/Eastern&#39;</span><span class="p">)</span>
<span class="gh">Out[462]: </span><span class="go"></span>
<span class="go">0   2012-12-31 19:00:00-05:00</span>
<span class="go">1   2013-01-01 19:00:00-05:00</span>
<span class="go">2   2013-01-02 19:00:00-05:00</span>
<span class="go">dtype: datetime64[ns, US/Eastern]</span>
</pre></div>
</div>
<p>Time zone information can also be manipulated using the <code class="docutils literal notranslate"><span class="pre">astype</span></code> method.
This method can localize and convert time zone naive timestamps or
convert time zone aware timestamps.</p>
<pre class="literal-block"># localize and convert a naive time zone
In [463]: s_naive.astype('datetime64[ns, US/Eastern]')
Out[463]: 
0   2012-12-31 19:00:00-05:00
1   2013-01-01 19:00:00-05:00
2   2013-01-02 19:00:00-05:00
dtype: datetime64[ns, US/Eastern]

# make an aware tz naive
In [464]: s_aware.astype('datetime64[ns]')
Out[464]: 
0   2013-01-01 05:00:00
1   2013-01-02 05:00:00
2   2013-01-03 05:00:00
dtype: datetime64[ns]

# convert to a new time zone
In [465]: s_aware.astype('datetime64[ns, CET]')
Out[465]: 
0   2013-01-01 06:00:00+01:00
1   2013-01-02 06:00:00+01:00
2   2013-01-03 06:00:00+01:00
dtype: datetime64[ns, CET]</pre>
<div class="alert alert-info">
<p class="admonition-title">Note</p>
<p>Using <code class="xref py py-meth docutils literal notranslate"><span class="pre">Series.to_numpy()</span></code> on a <code class="docutils literal notranslate"><span class="pre">Series</span></code>, returns a NumPy array of the data.
NumPy does not currently support time zones (even though it is <em>printing</em> in the local time zone!),
therefore an object array of Timestamps is returned for time zone aware data:</p>
<pre class="literal-block">In [466]: s_naive.to_numpy()
Out[466]: 
array(['2013-01-01T00:00:00.000000000', '2013-01-02T00:00:00.000000000',
       '2013-01-03T00:00:00.000000000'], dtype='datetime64[ns]')

In [467]: s_aware.to_numpy()
Out[467]: 
array([Timestamp('2013-01-01 00:00:00-0500', tz='US/Eastern', freq='D'),
       Timestamp('2013-01-02 00:00:00-0500', tz='US/Eastern', freq='D'),
       Timestamp('2013-01-03 00:00:00-0500', tz='US/Eastern', freq='D')],
      dtype=object)</pre>
<p>By converting to an object array of Timestamps, it preserves the time zone
information. For example, when converting back to a Series:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [468]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">s_aware</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
<span class="gh">Out[468]: </span><span class="go"></span>
<span class="go">0   2013-01-01 00:00:00-05:00</span>
<span class="go">1   2013-01-02 00:00:00-05:00</span>
<span class="go">2   2013-01-03 00:00:00-05:00</span>
<span class="go">dtype: datetime64[ns, US/Eastern]</span>
</pre></div>
</div>
<p>However, if you want an actual NumPy <code class="docutils literal notranslate"><span class="pre">datetime64[ns]</span></code> array (with the values
converted to UTC) instead of an array of objects, you can specify the
<code class="docutils literal notranslate"><span class="pre">dtype</span></code> argument:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [469]: </span><span class="n">s_aware</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span>
<span class="gh">Out[469]: </span><span class="go"></span>
<span class="go">array([&#39;2013-01-01T05:00:00.000000000&#39;, &#39;2013-01-02T05:00:00.000000000&#39;,</span>
<span class="go">       &#39;2013-01-03T05:00:00.000000000&#39;], dtype=&#39;datetime64[ns]&#39;)</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>


              </div>
              <div class='prev-next-bottom'>
                
    <a class='left-prev' id="prev-link" href="groupby.html" title="previous page">Group By: split-apply-combine</a>
    <a class='right-next' id="next-link" href="timedeltas.html" title="next page">Time Deltas</a>

              </div>
          </main>

      </div>
    </div><script>
    // TOC sidebar - add "active" class to parent list
    //
    // Bootstrap's scrollspy adds the active class to the <a> link,
    // but for the automatic collapsing we need this on the parent list item.
    //
    // The event is triggered on "window" (and not the nav item as documented),
    // see https://github.com/twbs/bootstrap/issues/20086
    $(window).on("activate.bs.scrollspy", function(){
    var navLinks = document.querySelectorAll('#bd-toc-nav a');
    for (var i = 0; i < navLinks.length; i++) {
        var navLink = navLinks[i];
        navLink.parentElement.classList.remove('active');
    }
    var navLinks = document.querySelectorAll('#bd-toc-nav a.active');
    for (var i = 0; i < navLinks.length; i++) {
        var navLink = navLinks[i];
        navLink.parentElement.classList.add('active');
    }
    });

    /**
     * Use left and right arrow keys to navigate forward and backwards.
    */
    const LEFT_ARROW_KEYCODE = 37
    const RIGHT_ARROW_KEYCODE = 39

    const getPrevUrl = () => document.getElementById('prev-link').href
    const getNextUrl = () => document.getElementById('next-link').href
    const initPageNav = (event) => {
        const keycode = event.which

        if (keycode === LEFT_ARROW_KEYCODE) {
            window.location.href = getPrevUrl();
        } else if (keycode === RIGHT_ARROW_KEYCODE) {
            window.location.href = getNextUrl();
        }
    };

    var keyboardListener = false;
    $( document ).ready(() => {
        if (keyboardListener === false) {
            document.addEventListener('keydown', initPageNav)
            keyboardListener = true;
        }
    });
</script>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2008-2014, the pandas development team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.1.
    </div>
  </body>
</html>