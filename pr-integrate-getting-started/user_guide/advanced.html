

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>MultiIndex / Advanced Indexing &#8212; pandas 0.25.3 documentation</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="../_static/sphinx-bootstrap.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/getting_started.css" />
    <link href="../_static/css/custom.css" rel="stylesheet">
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Merge, join, and concatenate" href="merging.html" />
    <link rel="prev" title="Indexing and Selecting Data" href="indexing.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main">

<a class="navbar-brand" href="../index.html">
  <img src="../_static/pandas.svg" class="logo" alt="logo">
</a>

<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
</button>

<div id="navbar-menu" class="collapse navbar-collapse">
  <ul id="navbar-main-elements" class="navbar-nav mr-auto">
    <li class="nav-item">
        <a class="nav-link" href="../index.html">Home</a>
    </li>
    
    
    <li class="nav-item ">
        <a class="nav-link" href="../getting_started/index.html">Getting started</a>
    </li>
    
    <li class="nav-item active">
        <a class="nav-link" href="index.html">User Guide</a>
    </li>
    
    <li class="nav-item ">
        <a class="nav-link" href="../reference/index.html">API Reference</a>
    </li>
    
    <li class="nav-item ">
        <a class="nav-link" href="../development/index.html">Development</a>
    </li>
    
    <li class="nav-item ">
        <a class="nav-link" href="../whatsnew/index.html">Release Notes</a>
    </li>
    
    <li class="nav-item ">
        <a class="nav-link" href="../development/index.html">Development</a>
    </li>
    
  </ul>
  <ul class="navbar-nav ml-auto">
    <li class="nav-item">
      <a class="nav-link" href="https://github.com/pandas-dev/pandas" target="_blank" rel="noopener">
        <span><i class="fab fa-github-alt" style="color:#333;font-size:1rem;line-height:1.25"></i></span>
      </a>
    </li>
    <li class="nav-item">
      <a class="nav-link" href="https://twitter.com/pandas_dev" target="_blank" rel="noopener">
        <span><i class="fab fa-twitter" style="color:#55acee;font-size:1rem;line-height:1.25"></i></span>
      </a>
    </li>
  </ul>
</div>
    </nav>

    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
          <div class="col-12 col-md-3 col-xl-2 bd-sidebar">
              

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">

  <div class="bd-toc-item active">
  

  <ul class="nav bd-sidenav">
      
      
      
      
        
          
              <li class="">
                  <a href="io.html">IO Tools (Text, CSV, HDF5, …)</a>
              </li>
          
        
          
              <li class="">
                  <a href="indexing.html">Indexing and Selecting Data</a>
              </li>
          
        
          
              <li class="active">
                  <a href="">MultiIndex / Advanced Indexing</a>
              </li>
          
        
          
              <li class="">
                  <a href="merging.html">Merge, join, and concatenate</a>
              </li>
          
        
          
              <li class="">
                  <a href="reshaping.html">Reshaping and Pivot Tables</a>
              </li>
          
        
          
              <li class="">
                  <a href="text.html">Working with Text Data</a>
              </li>
          
        
          
              <li class="">
                  <a href="missing_data.html">Working with missing data</a>
              </li>
          
        
          
              <li class="">
                  <a href="categorical.html">Categorical Data</a>
              </li>
          
        
          
              <li class="">
                  <a href="integer_na.html">Nullable Integer Data Type</a>
              </li>
          
        
          
              <li class="">
                  <a href="visualization.html">Visualization</a>
              </li>
          
        
          
              <li class="">
                  <a href="computation.html">Computational tools</a>
              </li>
          
        
          
              <li class="">
                  <a href="groupby.html">Group By: split-apply-combine</a>
              </li>
          
        
          
              <li class="">
                  <a href="timeseries.html">Time Series / Date functionality</a>
              </li>
          
        
          
              <li class="">
                  <a href="timedeltas.html">Time Deltas</a>
              </li>
          
        
          
              <li class="">
                  <a href="options.html">Options and Settings</a>
              </li>
          
        
          
              <li class="">
                  <a href="enhancingperf.html">Enhancing Performance</a>
              </li>
          
        
          
              <li class="">
                  <a href="sparse.html">Sparse data structures</a>
              </li>
          
        
          
              <li class="">
                  <a href="gotchas.html">Frequently Asked Questions (FAQ)</a>
              </li>
          
        
          
              <li class="">
                  <a href="cookbook.html">Cookbook</a>
              </li>
          
        
      
      
      
      
      
      
      
      
      
      
    </ul>

</nav>


              
          </div>

          <div class="d-none d-xl-block col-xl-2 bd-toc">
              

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#hierarchical-indexing-multiindex" class="nav-link">Hierarchical indexing (MultiIndex)</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#creating-a-multiindex-hierarchical-index-object" class="nav-link">Creating a MultiIndex (hierarchical index) object</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#reconstructing-the-level-labels" class="nav-link">Reconstructing the level labels</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#basic-indexing-on-axis-with-multiindex" class="nav-link">Basic indexing on axis with MultiIndex</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#defined-levels" class="nav-link">Defined Levels</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#data-alignment-and-using-reindex" class="nav-link">Data alignment and using reindex</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#advanced-indexing-with-hierarchical-index" class="nav-link">Advanced indexing with hierarchical index</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#using-slicers" class="nav-link">Using slicers</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#cross-section" class="nav-link">Cross-section</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#advanced-reindexing-and-alignment" class="nav-link">Advanced reindexing and alignment</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#swapping-levels-with-swaplevel" class="nav-link">Swapping levels with swaplevel</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#reordering-levels-with-reorder-levels" class="nav-link">Reordering levels with reorder_levels</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#renaming-names-of-an-index-or-multiindex" class="nav-link">Renaming names of an Index or MultiIndex</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#sorting-a-multiindex" class="nav-link">Sorting a MultiIndex</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#take-methods" class="nav-link">Take Methods</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#index-types" class="nav-link">Index Types</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#categoricalindex" class="nav-link">CategoricalIndex</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#int64index-and-rangeindex" class="nav-link">Int64Index and RangeIndex</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#float64index" class="nav-link">Float64Index</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#intervalindex" class="nav-link">IntervalIndex</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h4">
            <a href="#generating-ranges-of-intervals" class="nav-link">Generating Ranges of Intervals</a>
        </li>
    
            </ul>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#miscellaneous-indexing-faq" class="nav-link">Miscellaneous indexing FAQ</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#integer-indexing" class="nav-link">Integer indexing</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#non-monotonic-indexes-require-exact-matches" class="nav-link">Non-monotonic indexes require exact matches</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#endpoints-are-inclusive" class="nav-link">Endpoints are inclusive</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#indexing-potentially-changes-underlying-series-dtype" class="nav-link">Indexing potentially changes underlying Series dtype</a>
        </li>
    
            </ul>
        </li>
    
    </ul>
</nav>
              
            </div>

          <main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content" role="main">
              <div>
                
  <div class="section" id="multiindex-advanced-indexing">
<span id="advanced"></span><h1>MultiIndex / Advanced Indexing<a class="headerlink" href="#multiindex-advanced-indexing" title="Permalink to this headline">¶</a></h1>
<p>This section covers <a class="reference internal" href="#advanced-hierarchical"><span class="std std-ref">indexing with a MultiIndex</span></a>
and <a class="reference internal" href="#indexing-index-types"><span class="std std-ref">other advanced indexing features</span></a>.</p>
<p>See the <a class="reference internal" href="indexing.html#indexing"><span class="std std-ref">Indexing and Selecting Data</span></a> for general indexing documentation.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Whether a copy or a reference is returned for a setting operation may
depend on the context.  This is sometimes called <code class="docutils literal notranslate"><span class="pre">chained</span> <span class="pre">assignment</span></code> and
should be avoided.  See <a class="reference internal" href="indexing.html#indexing-view-versus-copy"><span class="std std-ref">Returning a View versus Copy</span></a>.</p>
</div>
<p>See the <a class="reference internal" href="cookbook.html#cookbook-selection"><span class="std std-ref">cookbook</span></a> for some advanced strategies.</p>
<div class="section" id="hierarchical-indexing-multiindex">
<span id="advanced-hierarchical"></span><h2>Hierarchical indexing (MultiIndex)<a class="headerlink" href="#hierarchical-indexing-multiindex" title="Permalink to this headline">¶</a></h2>
<p>Hierarchical / Multi-level indexing is very exciting as it opens the door to some
quite sophisticated data analysis and manipulation, especially for working with
higher dimensional data. In essence, it enables you to store and manipulate
data with an arbitrary number of dimensions in lower dimensional data
structures like <code class="docutils literal notranslate"><span class="pre">Series</span></code> (1d) and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> (2d).</p>
<p>In this section, we will show what exactly we mean by “hierarchical” indexing
and how it integrates with all of the pandas indexing functionality
described above and in prior sections. Later, when discussing <a class="reference internal" href="groupby.html#groupby"><span class="std std-ref">group by</span></a> and <a class="reference internal" href="reshaping.html#reshaping"><span class="std std-ref">pivoting and reshaping data</span></a>, we’ll show
non-trivial applications to illustrate how it aids in structuring data for
analysis.</p>
<p>See the <a class="reference internal" href="cookbook.html#cookbook-multi-index"><span class="std std-ref">cookbook</span></a> for some advanced strategies.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.24.0: </span><code class="xref py py-attr docutils literal notranslate"><span class="pre">MultiIndex.labels</span></code> has been renamed to <code class="xref py py-attr docutils literal notranslate"><span class="pre">MultiIndex.codes</span></code>
and <code class="xref py py-attr docutils literal notranslate"><span class="pre">MultiIndex.set_labels</span></code> to <code class="xref py py-attr docutils literal notranslate"><span class="pre">MultiIndex.set_codes</span></code>.</p>
</div>
<div class="section" id="creating-a-multiindex-hierarchical-index-object">
<h3>Creating a MultiIndex (hierarchical index) object<a class="headerlink" href="#creating-a-multiindex-hierarchical-index-object" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">MultiIndex</span></code> object is the hierarchical analogue of the standard
<code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code> object which typically stores the axis labels in pandas objects. You
can think of <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> as an array of tuples where each tuple is unique. A
<code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> can be created from a list of arrays (using
<code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_arrays()</span></code>), an array of tuples (using
<code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_tuples()</span></code>), a crossed set of iterables (using
<code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_product()</span></code>), or a <a class="reference internal" href="../reference/api/pandas.DataFrame.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> (using
<code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_frame()</span></code>).  The <code class="docutils literal notranslate"><span class="pre">Index</span></code> constructor will attempt to return
a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> when it is passed a list of tuples.  The following examples
demonstrate different ways to initialize MultiIndexes.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">arrays</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">],</span>
<span class="gp">   ...: </span>          <span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">]]</span>
<span class="gp">   ...: </span>

<span class="gp">In [2]: </span><span class="n">tuples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">))</span>

<span class="gp">In [3]: </span><span class="n">tuples</span>
<span class="gh">Out[3]: </span><span class="go"></span>
<span class="go">[(&#39;bar&#39;, &#39;one&#39;),</span>
<span class="go"> (&#39;bar&#39;, &#39;two&#39;),</span>
<span class="go"> (&#39;baz&#39;, &#39;one&#39;),</span>
<span class="go"> (&#39;baz&#39;, &#39;two&#39;),</span>
<span class="go"> (&#39;foo&#39;, &#39;one&#39;),</span>
<span class="go"> (&#39;foo&#39;, &#39;two&#39;),</span>
<span class="go"> (&#39;qux&#39;, &#39;one&#39;),</span>
<span class="go"> (&#39;qux&#39;, &#39;two&#39;)]</span>

<span class="gp">In [4]: </span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">tuples</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;second&#39;</span><span class="p">])</span>

<span class="gp">In [5]: </span><span class="n">index</span>
<span class="gh">Out[5]: </span><span class="go"></span>
<span class="go">MultiIndex([(&#39;bar&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;bar&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;baz&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;baz&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;qux&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;qux&#39;, &#39;two&#39;)],</span>
<span class="go">           names=[&#39;first&#39;, &#39;second&#39;])</span>

<span class="gp">In [6]: </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

<span class="gp">In [7]: </span><span class="n">s</span>
<span class="gh">Out[7]: </span><span class="go"></span>
<span class="go">first  second</span>
<span class="go">bar    one       0.469112</span>
<span class="go">       two      -0.282863</span>
<span class="go">baz    one      -1.509059</span>
<span class="go">       two      -1.135632</span>
<span class="go">foo    one       1.212112</span>
<span class="go">       two      -0.173215</span>
<span class="go">qux    one       0.119209</span>
<span class="go">       two      -1.044236</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>When you want every pairing of the elements in two iterables, it can be easier
to use the <code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_product()</span></code> method:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [8]: </span><span class="n">iterables</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">]]</span>

<span class="gp">In [9]: </span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">(</span><span class="n">iterables</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;second&#39;</span><span class="p">])</span>
<span class="gh">Out[9]: </span><span class="go"></span>
<span class="go">MultiIndex([(&#39;bar&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;bar&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;baz&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;baz&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;qux&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;qux&#39;, &#39;two&#39;)],</span>
<span class="go">           names=[&#39;first&#39;, &#39;second&#39;])</span>
</pre></div>
</div>
<p>You can also construct a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> from a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> directly, using
the method <code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_frame()</span></code>. This is a complementary method to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.to_frame()</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.24.0.</span></p>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [10]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">],</span>
<span class="gp">   ....: </span>                   <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">]],</span>
<span class="gp">   ....: </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;second&#39;</span><span class="p">])</span>
<span class="gp">   ....: </span>

<span class="gp">In [11]: </span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_frame</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="gh">Out[11]: </span><span class="go"></span>
<span class="go">MultiIndex([(&#39;bar&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;bar&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;two&#39;)],</span>
<span class="go">           names=[&#39;first&#39;, &#39;second&#39;])</span>
</pre></div>
</div>
<p>As a convenience, you can pass a list of arrays directly into <code class="docutils literal notranslate"><span class="pre">Series</span></code> or
<code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> to construct a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> automatically:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [12]: </span><span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">]),</span>
<span class="gp">   ....: </span>          <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">])]</span>
<span class="gp">   ....: </span>

<span class="gp">In [13]: </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">arrays</span><span class="p">)</span>

<span class="gp">In [14]: </span><span class="n">s</span>
<span class="gh">Out[14]: </span><span class="go"></span>
<span class="go">bar  one   -0.861849</span>
<span class="go">     two   -2.104569</span>
<span class="go">baz  one   -0.494929</span>
<span class="go">     two    1.071804</span>
<span class="go">foo  one    0.721555</span>
<span class="go">     two   -0.706771</span>
<span class="go">qux  one   -1.039575</span>
<span class="go">     two    0.271860</span>
<span class="go">dtype: float64</span>

<span class="gp">In [15]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">arrays</span><span class="p">)</span>

<span class="gp">In [16]: </span><span class="n">df</span>
<span class="gh">Out[16]: </span><span class="go"></span>
<span class="go">                0         1         2         3</span>
<span class="go">bar one -0.424972  0.567020  0.276232 -1.087401</span>
<span class="go">    two -0.673690  0.113648 -1.478427  0.524988</span>
<span class="go">baz one  0.404705  0.577046 -1.715002 -1.039268</span>
<span class="go">    two -0.370647 -1.157892 -1.344312  0.844885</span>
<span class="go">foo one  1.075770 -0.109050  1.643563 -1.469388</span>
<span class="go">    two  0.357021 -0.674600 -1.776904 -0.968914</span>
<span class="go">qux one -1.294524  0.413738  0.276662 -0.472035</span>
<span class="go">    two -0.013960 -0.362543 -0.006154 -0.923061</span>
</pre></div>
</div>
<p>All of the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> constructors accept a <code class="docutils literal notranslate"><span class="pre">names</span></code> argument which stores
string names for the levels themselves. If no names are provided, <code class="docutils literal notranslate"><span class="pre">None</span></code> will
be assigned:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [17]: </span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span>
<span class="gh">Out[17]: </span><span class="go">FrozenList([None, None])</span>
</pre></div>
</div>
<p>This index can back any axis of a pandas object, and the number of <strong>levels</strong>
of the index is up to you:</p>
<pre class="literal-block">In [18]: df = pd.DataFrame(np.random.randn(3, 8), index=['A', 'B', 'C'], columns=index)

In [19]: df
Out[19]: 
first        bar                 baz  ...       foo       qux          
second       one       two       one  ...       two       one       two
A       0.895717  0.805244 -1.206412  ...  1.340309 -1.170299 -0.226169
B       0.410835  0.813850  0.132003  ... -1.187678  1.130127 -1.436737
C      -1.413681  1.607920  1.024180  ... -2.211372  0.974466 -2.006747

[3 rows x 8 columns]

In [20]: pd.DataFrame(np.random.randn(6, 6), index=index[:6], columns=index[:6])
Out[20]: 
first              bar                 baz                 foo          
second             one       two       one       two       one       two
first second                                                            
bar   one    -0.410001 -0.078638  0.545952 -1.219217 -1.226825  0.769804
      two    -1.281247 -0.727707 -0.121306 -0.097883  0.695775  0.341734
baz   one     0.959726 -1.110336 -0.619976  0.149748 -0.732339  0.687738
      two     0.176444  0.403310 -0.154951  0.301624 -2.179861 -1.369849
foo   one    -0.954208  1.462696 -1.743161 -0.826591 -0.345352  1.314232
      two     0.690579  0.995761  2.396780  0.014871  3.357427 -0.317441</pre>
<p>We’ve “sparsified” the higher levels of the indexes to make the console output a
bit easier on the eyes. Note that how the index is displayed can be controlled using the
<code class="docutils literal notranslate"><span class="pre">multi_sparse</span></code> option in <code class="docutils literal notranslate"><span class="pre">pandas.set_options()</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [21]: </span><span class="k">with</span> <span class="n">pd</span><span class="o">.</span><span class="n">option_context</span><span class="p">(</span><span class="s1">&#39;display.multi_sparse&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="n">df</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<p>It’s worth keeping in mind that there’s nothing preventing you from using
tuples as atomic labels on an axis:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [22]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">tuples</span><span class="p">)</span>
<span class="gh">Out[22]: </span><span class="go"></span>
<span class="go">(bar, one)   -1.236269</span>
<span class="go">(bar, two)    0.896171</span>
<span class="go">(baz, one)   -0.487602</span>
<span class="go">(baz, two)   -0.082240</span>
<span class="go">(foo, one)   -2.182937</span>
<span class="go">(foo, two)    0.380396</span>
<span class="go">(qux, one)    0.084844</span>
<span class="go">(qux, two)    0.432390</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>The reason that the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> matters is that it can allow you to do
grouping, selection, and reshaping operations as we will describe below and in
subsequent areas of the documentation. As you will see in later sections, you
can find yourself working with hierarchically-indexed data without creating a
<code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> explicitly yourself. However, when loading data from a file, you
may wish to generate your own <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> when preparing the data set.</p>
</div>
<div class="section" id="reconstructing-the-level-labels">
<span id="advanced-get-level-values"></span><h3>Reconstructing the level labels<a class="headerlink" href="#reconstructing-the-level-labels" title="Permalink to this headline">¶</a></h3>
<p>The method <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_level_values()</span></code> will return a vector of the labels for each
location at a particular level:</p>
<pre class="literal-block">In [23]: index.get_level_values(0)
Out[23]: Index(['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux'], dtype='object', name='first')

In [24]: index.get_level_values('second')
Out[24]: Index(['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two'], dtype='object', name='second')</pre>
</div>
<div class="section" id="basic-indexing-on-axis-with-multiindex">
<h3>Basic indexing on axis with MultiIndex<a class="headerlink" href="#basic-indexing-on-axis-with-multiindex" title="Permalink to this headline">¶</a></h3>
<p>One of the important features of hierarchical indexing is that you can select
data by a “partial” label identifying a subgroup in the data. <strong>Partial</strong>
selection “drops” levels of the hierarchical index in the result in a
completely analogous way to selecting a column in a regular DataFrame:</p>
<pre class="literal-block">In [25]: df['bar']
Out[25]: 
second       one       two
A       0.895717  0.805244
B       0.410835  0.813850
C      -1.413681  1.607920

In [26]: df['bar', 'one']
Out[26]: 
A    0.895717
B    0.410835
C   -1.413681
Name: (bar, one), dtype: float64

In [27]: df['bar']['one']
Out[27]: 
A    0.895717
B    0.410835
C   -1.413681
Name: one, dtype: float64

In [28]: s['qux']
Out[28]: 
one   -1.039575
two    0.271860
dtype: float64</pre>
<p>See <a class="reference internal" href="#advanced-xs"><span class="std std-ref">Cross-section with hierarchical index</span></a> for how to select
on a deeper level.</p>
</div>
<div class="section" id="defined-levels">
<span id="advanced-shown-levels"></span><h3>Defined Levels<a class="headerlink" href="#defined-levels" title="Permalink to this headline">¶</a></h3>
<p>The repr of a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> shows all the defined levels of an index, even
if they are not actually used. When slicing an index, you may notice this.
For example:</p>
<pre class="literal-block">In [29]: df.columns  # original MultiIndex
Out[29]: 
MultiIndex([('bar', 'one'),
            ('bar', 'two'),
            ('baz', 'one'),
            ('baz', 'two'),
            ('foo', 'one'),
            ('foo', 'two'),
            ('qux', 'one'),
            ('qux', 'two')],
           names=['first', 'second'])

In [30]: df[['foo','qux']].columns  # sliced
Out[30]: 
MultiIndex([('foo', 'one'),
            ('foo', 'two'),
            ('qux', 'one'),
            ('qux', 'two')],
           names=['first', 'second'])</pre>
<p>This is done to avoid a recomputation of the levels in order to make slicing
highly performant. If you want to see only the used levels, you can use the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_level_values()</span></code> method.</p>
<pre class="literal-block">In [31]: df[['foo', 'qux']].columns.to_numpy()
Out[31]: 
array([('foo', 'one'), ('foo', 'two'), ('qux', 'one'), ('qux', 'two')],
      dtype=object)

# for a specific level
In [32]: df[['foo', 'qux']].columns.get_level_values(0)
Out[32]: Index(['foo', 'foo', 'qux', 'qux'], dtype='object', name='first')</pre>
<p>To reconstruct the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> with only the used levels, the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">remove_unused_levels()</span></code> method may be used.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.0.</span></p>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [33]: </span><span class="n">df</span><span class="p">[[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;qux&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">remove_unused_levels</span><span class="p">()</span>
<span class="gh">Out[33]: </span><span class="go"></span>
<span class="go">MultiIndex([(&#39;foo&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;foo&#39;, &#39;two&#39;),</span>
<span class="go">            (&#39;qux&#39;, &#39;one&#39;),</span>
<span class="go">            (&#39;qux&#39;, &#39;two&#39;)],</span>
<span class="go">           names=[&#39;first&#39;, &#39;second&#39;])</span>
</pre></div>
</div>
</div>
<div class="section" id="data-alignment-and-using-reindex">
<h3>Data alignment and using <code class="docutils literal notranslate"><span class="pre">reindex</span></code><a class="headerlink" href="#data-alignment-and-using-reindex" title="Permalink to this headline">¶</a></h3>
<p>Operations between differently-indexed objects having <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> on the
axes will work as you expect; data alignment will work the same as an Index of
tuples:</p>
<pre class="literal-block">In [34]: s + s[:-2]
Out[34]: 
bar  one   -1.723698
     two   -4.209138
baz  one   -0.989859
     two    2.143608
foo  one    1.443110
     two   -1.413542
qux  one         NaN
     two         NaN
dtype: float64

In [35]: s + s[::2]
Out[35]: 
bar  one   -1.723698
     two         NaN
baz  one   -0.989859
     two         NaN
foo  one    1.443110
     two         NaN
qux  one   -2.079150
     two         NaN
dtype: float64</pre>
<p>The <a class="reference internal" href="../reference/api/pandas.DataFrame.reindex.html#pandas.DataFrame.reindex" title="pandas.DataFrame.reindex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reindex()</span></code></a> method of <code class="docutils literal notranslate"><span class="pre">Series</span></code>/<code class="docutils literal notranslate"><span class="pre">DataFrames</span></code> can be
called with another <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>, or even a list or array of tuples:</p>
<pre class="literal-block">In [36]: s.reindex(index[:3])
Out[36]: 
first  second
bar    one      -0.861849
       two      -2.104569
baz    one      -0.494929
dtype: float64

In [37]: s.reindex([('foo', 'two'), ('bar', 'one'), ('qux', 'one'), ('baz', 'one')])
Out[37]: 
foo  two   -0.706771
bar  one   -0.861849
qux  one   -1.039575
baz  one   -0.494929
dtype: float64</pre>
</div>
</div>
<div class="section" id="advanced-indexing-with-hierarchical-index">
<span id="advanced-advanced-hierarchical"></span><h2>Advanced indexing with hierarchical index<a class="headerlink" href="#advanced-indexing-with-hierarchical-index" title="Permalink to this headline">¶</a></h2>
<p>Syntactically integrating <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> in advanced indexing with <code class="docutils literal notranslate"><span class="pre">.loc</span></code> is a
bit challenging, but we’ve made every effort to do so. In general, MultiIndex
keys take the form of tuples. For example, the following works as you would expect:</p>
<pre class="literal-block">In [38]: df = df.T

In [39]: df
Out[39]: 
                     A         B         C
first second                              
bar   one     0.895717  0.410835 -1.413681
      two     0.805244  0.813850  1.607920
baz   one    -1.206412  0.132003  1.024180
      two     2.565646 -0.827317  0.569605
foo   one     1.431256 -0.076467  0.875906
      two     1.340309 -1.187678 -2.211372
qux   one    -1.170299  1.130127  0.974466
      two    -0.226169 -1.436737 -2.006747

In [40]: df.loc[('bar', 'two')]
Out[40]: 
A    0.805244
B    0.813850
C    1.607920
Name: (bar, two), dtype: float64</pre>
<p>Note that <code class="docutils literal notranslate"><span class="pre">df.loc['bar',</span> <span class="pre">'two']</span></code> would also work in this example, but this shorthand
notation can lead to ambiguity in general.</p>
<p>If you also want to index a specific column with <code class="docutils literal notranslate"><span class="pre">.loc</span></code>, you must use a tuple
like this:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [41]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">),</span> <span class="s1">&#39;A&#39;</span><span class="p">]</span>
<span class="gh">Out[41]: </span><span class="go">0.8052440253863785</span>
</pre></div>
</div>
<p>You don’t have to specify all levels of the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> by passing only the
first elements of the tuple. For example, you can use “partial” indexing to
get all elements with <code class="docutils literal notranslate"><span class="pre">bar</span></code> in the first level as follows:</p>
<p>df.loc[‘bar’]</p>
<p>This is a shortcut for the slightly more verbose notation <code class="docutils literal notranslate"><span class="pre">df.loc[('bar',),]</span></code> (equivalent
to <code class="docutils literal notranslate"><span class="pre">df.loc['bar',]</span></code> in this example).</p>
<p>“Partial” slicing also works quite nicely.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [42]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;baz&#39;</span><span class="p">:</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span>
<span class="gh">Out[42]: </span><span class="go"></span>
<span class="go">                     A         B         C</span>
<span class="go">first second                              </span>
<span class="go">baz   one    -1.206412  0.132003  1.024180</span>
<span class="go">      two     2.565646 -0.827317  0.569605</span>
<span class="go">foo   one     1.431256 -0.076467  0.875906</span>
<span class="go">      two     1.340309 -1.187678 -2.211372</span>
</pre></div>
</div>
<p>You can slice with a ‘range’ of values, by providing a slice of tuples.</p>
<pre class="literal-block">In [43]: df.loc[('baz', 'two'):('qux', 'one')]
Out[43]: 
                     A         B         C
first second                              
baz   two     2.565646 -0.827317  0.569605
foo   one     1.431256 -0.076467  0.875906
      two     1.340309 -1.187678 -2.211372
qux   one    -1.170299  1.130127  0.974466

In [44]: df.loc[('baz', 'two'):'foo']
Out[44]: 
                     A         B         C
first second                              
baz   two     2.565646 -0.827317  0.569605
foo   one     1.431256 -0.076467  0.875906
      two     1.340309 -1.187678 -2.211372</pre>
<p>Passing a list of labels or tuples works similar to reindexing:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [45]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[[(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;qux&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">)]]</span>
<span class="gh">Out[45]: </span><span class="go"></span>
<span class="go">                     A         B         C</span>
<span class="go">first second                              </span>
<span class="go">bar   two     0.805244  0.813850  1.607920</span>
<span class="go">qux   one    -1.170299  1.130127  0.974466</span>
</pre></div>
</div>
<div class="alert alert-info">
<p class="admonition-title">Note</p>
<p>It is important to note that tuples and lists are not treated identically
in pandas when it comes to indexing. Whereas a tuple is interpreted as one
multi-level key, a list is used to specify several keys. Or in other words,
tuples go horizontally (traversing levels), lists go vertically (scanning levels).</p>
</div>
<p>Importantly, a list of tuples indexes several complete <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> keys,
whereas a tuple of lists refer to several values within a level:</p>
<pre class="literal-block">In [46]: s = pd.Series([1, 2, 3, 4, 5, 6],
   ....:               index=pd.MultiIndex.from_product([[&quot;A&quot;, &quot;B&quot;], [&quot;c&quot;, &quot;d&quot;, &quot;e&quot;]]))
   ....: 

In [47]: s.loc[[(&quot;A&quot;, &quot;c&quot;), (&quot;B&quot;, &quot;d&quot;)]]  # list of tuples
Out[47]: 
A  c    1
B  d    5
dtype: int64

In [48]: s.loc[([&quot;A&quot;, &quot;B&quot;], [&quot;c&quot;, &quot;d&quot;])]  # tuple of lists
Out[48]: 
A  c    1
   d    2
B  c    4
   d    5
dtype: int64</pre>
<div class="section" id="using-slicers">
<span id="advanced-mi-slicers"></span><h3>Using slicers<a class="headerlink" href="#using-slicers" title="Permalink to this headline">¶</a></h3>
<p>You can slice a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> by providing multiple indexers.</p>
<p>You can provide any of the selectors as if you are indexing by label, see <a class="reference internal" href="indexing.html#indexing-label"><span class="std std-ref">Selection by Label</span></a>,
including slices, lists of labels, labels, and boolean indexers.</p>
<p>You can use <code class="docutils literal notranslate"><span class="pre">slice(None)</span></code> to select all the contents of <em>that</em> level. You do not need to specify all the
<em>deeper</em> levels, they will be implied as <code class="docutils literal notranslate"><span class="pre">slice(None)</span></code>.</p>
<p>As usual, <strong>both sides</strong> of the slicers are included as this is label indexing.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>You should specify all axes in the <code class="docutils literal notranslate"><span class="pre">.loc</span></code> specifier, meaning the indexer for the <strong>index</strong> and
for the <strong>columns</strong>. There are some ambiguous cases where the passed indexer could be mis-interpreted
as indexing <em>both</em> axes, rather than into say the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> for the rows.</p>
<p>You should do this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="s1">&#39;A1&#39;</span><span class="p">,</span> <span class="s1">&#39;A3&#39;</span><span class="p">),</span> <span class="o">...</span><span class="p">),</span> <span class="p">:]</span>             <span class="c1"># noqa: E999</span>
</pre></div>
</div>
<p>You should <strong>not</strong> do this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="s1">&#39;A1&#39;</span><span class="p">,</span> <span class="s1">&#39;A3&#39;</span><span class="p">),</span> <span class="o">...</span><span class="p">)]</span>                <span class="c1"># noqa: E999</span>
</pre></div>
</div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [49]: </span><span class="k">def</span> <span class="nf">mklbl</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
<span class="gp">   ....: </span>

<span class="gp">In [50]: </span><span class="n">miindex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="n">mklbl</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
<span class="gp">   ....: </span>                                      <span class="n">mklbl</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">   ....: </span>                                      <span class="n">mklbl</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
<span class="gp">   ....: </span>                                      <span class="n">mklbl</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">   ....: </span>

<span class="gp">In [51]: </span><span class="n">micolumns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">([(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">),</span>
<span class="gp">   ....: </span>                                       <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;bah&#39;</span><span class="p">)],</span>
<span class="gp">   ....: </span>                                      <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;lvl0&#39;</span><span class="p">,</span> <span class="s1">&#39;lvl1&#39;</span><span class="p">])</span>
<span class="gp">   ....: </span>

<span class="gp">In [52]: </span><span class="n">dfmi</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">miindex</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">micolumns</span><span class="p">))</span>
<span class="gp">   ....: </span>                      <span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">miindex</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">micolumns</span><span class="p">))),</span>
<span class="gp">   ....: </span>                    <span class="n">index</span><span class="o">=</span><span class="n">miindex</span><span class="p">,</span>
<span class="gp">   ....: </span>                    <span class="n">columns</span><span class="o">=</span><span class="n">micolumns</span><span class="p">)</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">   ....: </span>

<span class="gp">In [53]: </span><span class="n">dfmi</span>
<span class="gh">Out[53]: </span><span class="go"></span>
<span class="go">lvl0           a         b     </span>
<span class="go">lvl1         bar  foo  bah  foo</span>
<span class="go">A0 B0 C0 D0    1    0    3    2</span>
<span class="go">         D1    5    4    7    6</span>
<span class="go">      C1 D0    9    8   11   10</span>
<span class="go">         D1   13   12   15   14</span>
<span class="go">      C2 D0   17   16   19   18</span>
<span class="go">...          ...  ...  ...  ...</span>
<span class="go">A3 B1 C1 D1  237  236  239  238</span>
<span class="go">      C2 D0  241  240  243  242</span>
<span class="go">         D1  245  244  247  246</span>
<span class="go">      C3 D0  249  248  251  250</span>
<span class="go">         D1  253  252  255  254</span>

<span class="go">[64 rows x 4 columns]</span>
</pre></div>
</div>
<p>Basic MultiIndex slicing using slices, lists, and labels.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [54]: </span><span class="n">dfmi</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="s1">&#39;A1&#39;</span><span class="p">,</span> <span class="s1">&#39;A3&#39;</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">]),</span> <span class="p">:]</span>
<span class="gh">Out[54]: </span><span class="go"></span>
<span class="go">lvl0           a         b     </span>
<span class="go">lvl1         bar  foo  bah  foo</span>
<span class="go">A1 B0 C1 D0   73   72   75   74</span>
<span class="go">         D1   77   76   79   78</span>
<span class="go">      C3 D0   89   88   91   90</span>
<span class="go">         D1   93   92   95   94</span>
<span class="go">   B1 C1 D0  105  104  107  106</span>
<span class="go">...          ...  ...  ...  ...</span>
<span class="go">A3 B0 C3 D1  221  220  223  222</span>
<span class="go">   B1 C1 D0  233  232  235  234</span>
<span class="go">         D1  237  236  239  238</span>
<span class="go">      C3 D0  249  248  251  250</span>
<span class="go">         D1  253  252  255  254</span>

<span class="go">[24 rows x 4 columns]</span>
</pre></div>
</div>
<p>You can use <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.IndexSlice</span></code> to facilitate a more natural syntax
using <code class="docutils literal notranslate"><span class="pre">:</span></code>, rather than using <code class="docutils literal notranslate"><span class="pre">slice(None)</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [55]: </span><span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">IndexSlice</span>

<span class="gp">In [56]: </span><span class="n">dfmi</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">]],</span> <span class="n">idx</span><span class="p">[:,</span> <span class="s1">&#39;foo&#39;</span><span class="p">]]</span>
<span class="gh">Out[56]: </span><span class="go"></span>
<span class="go">lvl0           a    b</span>
<span class="go">lvl1         foo  foo</span>
<span class="go">A0 B0 C1 D0    8   10</span>
<span class="go">         D1   12   14</span>
<span class="go">      C3 D0   24   26</span>
<span class="go">         D1   28   30</span>
<span class="go">   B1 C1 D0   40   42</span>
<span class="go">...          ...  ...</span>
<span class="go">A3 B0 C3 D1  220  222</span>
<span class="go">   B1 C1 D0  232  234</span>
<span class="go">         D1  236  238</span>
<span class="go">      C3 D0  248  250</span>
<span class="go">         D1  252  254</span>

<span class="go">[32 rows x 2 columns]</span>
</pre></div>
</div>
<p>It is possible to perform quite complicated selections using this method on multiple
axes at the same time.</p>
<pre class="literal-block">In [57]: dfmi.loc['A1', (slice(None), 'foo')]
Out[57]: 
lvl0        a    b
lvl1      foo  foo
B0 C0 D0   64   66
      D1   68   70
   C1 D0   72   74
      D1   76   78
   C2 D0   80   82
...       ...  ...
B1 C1 D1  108  110
   C2 D0  112  114
      D1  116  118
   C3 D0  120  122
      D1  124  126

[16 rows x 2 columns]

In [58]: dfmi.loc[idx[:, :, ['C1', 'C3']], idx[:, 'foo']]
Out[58]: 
lvl0           a    b
lvl1         foo  foo
A0 B0 C1 D0    8   10
         D1   12   14
      C3 D0   24   26
         D1   28   30
   B1 C1 D0   40   42
...          ...  ...
A3 B0 C3 D1  220  222
   B1 C1 D0  232  234
         D1  236  238
      C3 D0  248  250
         D1  252  254

[32 rows x 2 columns]</pre>
<p>Using a boolean indexer you can provide selection related to the <em>values</em>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [59]: </span><span class="n">mask</span> <span class="o">=</span> <span class="n">dfmi</span><span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)]</span> <span class="o">&gt;</span> <span class="mi">200</span>

<span class="gp">In [60]: </span><span class="n">dfmi</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:,</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">]],</span> <span class="n">idx</span><span class="p">[:,</span> <span class="s1">&#39;foo&#39;</span><span class="p">]]</span>
<span class="gh">Out[60]: </span><span class="go"></span>
<span class="go">lvl0           a    b</span>
<span class="go">lvl1         foo  foo</span>
<span class="go">A3 B0 C1 D1  204  206</span>
<span class="go">      C3 D0  216  218</span>
<span class="go">         D1  220  222</span>
<span class="go">   B1 C1 D0  232  234</span>
<span class="go">         D1  236  238</span>
<span class="go">      C3 D0  248  250</span>
<span class="go">         D1  252  254</span>
</pre></div>
</div>
<p>You can also specify the <code class="docutils literal notranslate"><span class="pre">axis</span></code> argument to <code class="docutils literal notranslate"><span class="pre">.loc</span></code> to interpret the passed
slicers on a single axis.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [61]: </span><span class="n">dfmi</span><span class="o">.</span><span class="n">loc</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">]]</span>
<span class="gh">Out[61]: </span><span class="go"></span>
<span class="go">lvl0           a         b     </span>
<span class="go">lvl1         bar  foo  bah  foo</span>
<span class="go">A0 B0 C1 D0    9    8   11   10</span>
<span class="go">         D1   13   12   15   14</span>
<span class="go">      C3 D0   25   24   27   26</span>
<span class="go">         D1   29   28   31   30</span>
<span class="go">   B1 C1 D0   41   40   43   42</span>
<span class="go">...          ...  ...  ...  ...</span>
<span class="go">A3 B0 C3 D1  221  220  223  222</span>
<span class="go">   B1 C1 D0  233  232  235  234</span>
<span class="go">         D1  237  236  239  238</span>
<span class="go">      C3 D0  249  248  251  250</span>
<span class="go">         D1  253  252  255  254</span>

<span class="go">[32 rows x 4 columns]</span>
</pre></div>
</div>
<p>Furthermore, you can <em>set</em> the values using the following methods.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [62]: </span><span class="n">df2</span> <span class="o">=</span> <span class="n">dfmi</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="gp">In [63]: </span><span class="n">df2</span><span class="o">.</span><span class="n">loc</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span>

<span class="gp">In [64]: </span><span class="n">df2</span>
<span class="gh">Out[64]: </span><span class="go"></span>
<span class="go">lvl0           a         b     </span>
<span class="go">lvl1         bar  foo  bah  foo</span>
<span class="go">A0 B0 C0 D0    1    0    3    2</span>
<span class="go">         D1    5    4    7    6</span>
<span class="go">      C1 D0  -10  -10  -10  -10</span>
<span class="go">         D1  -10  -10  -10  -10</span>
<span class="go">      C2 D0   17   16   19   18</span>
<span class="go">...          ...  ...  ...  ...</span>
<span class="go">A3 B1 C1 D1  -10  -10  -10  -10</span>
<span class="go">      C2 D0  241  240  243  242</span>
<span class="go">         D1  245  244  247  246</span>
<span class="go">      C3 D0  -10  -10  -10  -10</span>
<span class="go">         D1  -10  -10  -10  -10</span>

<span class="go">[64 rows x 4 columns]</span>
</pre></div>
</div>
<p>You can use a right-hand-side of an alignable object as well.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [65]: </span><span class="n">df2</span> <span class="o">=</span> <span class="n">dfmi</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="gp">In [66]: </span><span class="n">df2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">[</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="s1">&#39;C3&#39;</span><span class="p">]],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">df2</span> <span class="o">*</span> <span class="mi">1000</span>

<span class="gp">In [67]: </span><span class="n">df2</span>
<span class="gh">Out[67]: </span><span class="go"></span>
<span class="go">lvl0              a               b        </span>
<span class="go">lvl1            bar     foo     bah     foo</span>
<span class="go">A0 B0 C0 D0       1       0       3       2</span>
<span class="go">         D1       5       4       7       6</span>
<span class="go">      C1 D0    9000    8000   11000   10000</span>
<span class="go">         D1   13000   12000   15000   14000</span>
<span class="go">      C2 D0      17      16      19      18</span>
<span class="go">...             ...     ...     ...     ...</span>
<span class="go">A3 B1 C1 D1  237000  236000  239000  238000</span>
<span class="go">      C2 D0     241     240     243     242</span>
<span class="go">         D1     245     244     247     246</span>
<span class="go">      C3 D0  249000  248000  251000  250000</span>
<span class="go">         D1  253000  252000  255000  254000</span>

<span class="go">[64 rows x 4 columns]</span>
</pre></div>
</div>
</div>
<div class="section" id="cross-section">
<span id="advanced-xs"></span><h3>Cross-section<a class="headerlink" href="#cross-section" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../reference/api/pandas.DataFrame.xs.html#pandas.DataFrame.xs" title="pandas.DataFrame.xs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">xs()</span></code></a> method of <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> additionally takes a level argument to make
selecting data at a particular level of a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> easier.</p>
<pre class="literal-block">In [68]: df
Out[68]: 
                     A         B         C
first second                              
bar   one     0.895717  0.410835 -1.413681
      two     0.805244  0.813850  1.607920
baz   one    -1.206412  0.132003  1.024180
      two     2.565646 -0.827317  0.569605
foo   one     1.431256 -0.076467  0.875906
      two     1.340309 -1.187678 -2.211372
qux   one    -1.170299  1.130127  0.974466
      two    -0.226169 -1.436737 -2.006747

In [69]: df.xs('one', level='second')
Out[69]: 
              A         B         C
first                              
bar    0.895717  0.410835 -1.413681
baz   -1.206412  0.132003  1.024180
foo    1.431256 -0.076467  0.875906
qux   -1.170299  1.130127  0.974466</pre>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># using the slicers</span>
<span class="gp">In [70]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="s1">&#39;one&#39;</span><span class="p">),</span> <span class="p">:]</span>
<span class="gh">Out[70]: </span><span class="go"></span>
<span class="go">                     A         B         C</span>
<span class="go">first second                              </span>
<span class="go">bar   one     0.895717  0.410835 -1.413681</span>
<span class="go">baz   one    -1.206412  0.132003  1.024180</span>
<span class="go">foo   one     1.431256 -0.076467  0.875906</span>
<span class="go">qux   one    -1.170299  1.130127  0.974466</span>
</pre></div>
</div>
<p>You can also select on the columns with <code class="docutils literal notranslate"><span class="pre">xs</span></code>, by
providing the axis argument.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [71]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">T</span>

<span class="gp">In [72]: </span><span class="n">df</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gh">Out[72]: </span><span class="go"></span>
<span class="go">first       bar       baz       foo       qux</span>
<span class="go">A      0.895717 -1.206412  1.431256 -1.170299</span>
<span class="go">B      0.410835  0.132003 -0.076467  1.130127</span>
<span class="go">C     -1.413681  1.024180  0.875906  0.974466</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># using the slicers</span>
<span class="gp">In [73]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="s1">&#39;one&#39;</span><span class="p">)]</span>
<span class="gh">Out[73]: </span><span class="go"></span>
<span class="go">first        bar       baz       foo       qux</span>
<span class="go">second       one       one       one       one</span>
<span class="go">A       0.895717 -1.206412  1.431256 -1.170299</span>
<span class="go">B       0.410835  0.132003 -0.076467  1.130127</span>
<span class="go">C      -1.413681  1.024180  0.875906  0.974466</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">xs</span></code> also allows selection with multiple keys.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [74]: </span><span class="n">df</span><span class="o">.</span><span class="n">xs</span><span class="p">((</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">),</span> <span class="n">level</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="s1">&#39;first&#39;</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gh">Out[74]: </span><span class="go"></span>
<span class="go">first        bar</span>
<span class="go">second       one</span>
<span class="go">A       0.895717</span>
<span class="go">B       0.410835</span>
<span class="go">C      -1.413681</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># using the slicers</span>
<span class="gp">In [75]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">)]</span>
<span class="gh">Out[75]: </span><span class="go"></span>
<span class="go">A    0.895717</span>
<span class="go">B    0.410835</span>
<span class="go">C   -1.413681</span>
<span class="go">Name: (bar, one), dtype: float64</span>
</pre></div>
</div>
<p>You can pass <code class="docutils literal notranslate"><span class="pre">drop_level=False</span></code> to <code class="docutils literal notranslate"><span class="pre">xs</span></code> to retain
the level that was selected.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [76]: </span><span class="n">df</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">drop_level</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gh">Out[76]: </span><span class="go"></span>
<span class="go">first        bar       baz       foo       qux</span>
<span class="go">second       one       one       one       one</span>
<span class="go">A       0.895717 -1.206412  1.431256 -1.170299</span>
<span class="go">B       0.410835  0.132003 -0.076467  1.130127</span>
<span class="go">C      -1.413681  1.024180  0.875906  0.974466</span>
</pre></div>
</div>
<p>Compare the above with the result using <code class="docutils literal notranslate"><span class="pre">drop_level=True</span></code> (the default value).</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [77]: </span><span class="n">df</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">drop_level</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gh">Out[77]: </span><span class="go"></span>
<span class="go">first       bar       baz       foo       qux</span>
<span class="go">A      0.895717 -1.206412  1.431256 -1.170299</span>
<span class="go">B      0.410835  0.132003 -0.076467  1.130127</span>
<span class="go">C     -1.413681  1.024180  0.875906  0.974466</span>
</pre></div>
</div>
</div>
<div class="section" id="advanced-reindexing-and-alignment">
<span id="advanced-advanced-reindex"></span><h3>Advanced reindexing and alignment<a class="headerlink" href="#advanced-reindexing-and-alignment" title="Permalink to this headline">¶</a></h3>
<p>Using the parameter <code class="docutils literal notranslate"><span class="pre">level</span></code> in the <a class="reference internal" href="../reference/api/pandas.DataFrame.reindex.html#pandas.DataFrame.reindex" title="pandas.DataFrame.reindex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reindex()</span></code></a> and
<a class="reference internal" href="../reference/api/pandas.DataFrame.align.html#pandas.DataFrame.align" title="pandas.DataFrame.align"><code class="xref py py-meth docutils literal notranslate"><span class="pre">align()</span></code></a> methods of pandas objects is useful to broadcast
values across a level. For instance:</p>
<pre class="literal-block">In [78]: midx = pd.MultiIndex(levels=[['zero', 'one'], ['x', 'y']],
   ....:                      codes=[[1, 1, 0, 0], [1, 0, 1, 0]])
   ....: 

In [79]: df = pd.DataFrame(np.random.randn(4, 2), index=midx)

In [80]: df
Out[80]: 
               0         1
one  y  1.519970 -0.493662
     x  0.600178  0.274230
zero y  0.132885 -0.023688
     x  2.410179  1.450520

In [81]: df2 = df.mean(level=0)

In [82]: df2
Out[82]: 
             0         1
one   1.060074 -0.109716
zero  1.271532  0.713416

In [83]: df2.reindex(df.index, level=0)
Out[83]: 
               0         1
one  y  1.060074 -0.109716
     x  1.060074 -0.109716
zero y  1.271532  0.713416
     x  1.271532  0.713416

# aligning
In [84]: df_aligned, df2_aligned = df.align(df2, level=0)

In [85]: df_aligned
Out[85]: 
               0         1
one  y  1.519970 -0.493662
     x  0.600178  0.274230
zero y  0.132885 -0.023688
     x  2.410179  1.450520

In [86]: df2_aligned
Out[86]: 
               0         1
one  y  1.060074 -0.109716
     x  1.060074 -0.109716
zero y  1.271532  0.713416
     x  1.271532  0.713416</pre>
</div>
<div class="section" id="swapping-levels-with-swaplevel">
<h3>Swapping levels with <code class="docutils literal notranslate"><span class="pre">swaplevel</span></code><a class="headerlink" href="#swapping-levels-with-swaplevel" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">swaplevel()</span></code> method can switch the order of two levels:</p>
<pre class="literal-block">In [87]: df[:5]
Out[87]: 
               0         1
one  y  1.519970 -0.493662
     x  0.600178  0.274230
zero y  0.132885 -0.023688
     x  2.410179  1.450520

In [88]: df[:5].swaplevel(0, 1, axis=0)
Out[88]: 
               0         1
y one   1.519970 -0.493662
x one   0.600178  0.274230
y zero  0.132885 -0.023688
x zero  2.410179  1.450520</pre>
</div>
<div class="section" id="reordering-levels-with-reorder-levels">
<span id="advanced-reorderlevels"></span><h3>Reordering levels with <code class="docutils literal notranslate"><span class="pre">reorder_levels</span></code><a class="headerlink" href="#reordering-levels-with-reorder-levels" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">reorder_levels()</span></code> method generalizes the <code class="docutils literal notranslate"><span class="pre">swaplevel</span></code>
method, allowing you to permute the hierarchical index levels in one step:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [89]: </span><span class="n">df</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">reorder_levels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gh">Out[89]: </span><span class="go"></span>
<span class="go">               0         1</span>
<span class="go">y one   1.519970 -0.493662</span>
<span class="go">x one   0.600178  0.274230</span>
<span class="go">y zero  0.132885 -0.023688</span>
<span class="go">x zero  2.410179  1.450520</span>
</pre></div>
</div>
</div>
<div class="section" id="renaming-names-of-an-index-or-multiindex">
<span id="advanced-index-names"></span><h3>Renaming names of an <code class="docutils literal notranslate"><span class="pre">Index</span></code> or <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code><a class="headerlink" href="#renaming-names-of-an-index-or-multiindex" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../reference/api/pandas.DataFrame.rename.html#pandas.DataFrame.rename" title="pandas.DataFrame.rename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rename()</span></code></a> method is used to rename the labels of a
<code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>, and is typically used to rename the columns of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.
The <code class="docutils literal notranslate"><span class="pre">columns</span></code> argument of <code class="docutils literal notranslate"><span class="pre">rename</span></code> allows a dictionary to be specified
that includes only the columns you wish to rename.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [90]: </span><span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;col0&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;col1&quot;</span><span class="p">})</span>
<span class="gh">Out[90]: </span><span class="go"></span>
<span class="go">            col0      col1</span>
<span class="go">one  y  1.519970 -0.493662</span>
<span class="go">     x  0.600178  0.274230</span>
<span class="go">zero y  0.132885 -0.023688</span>
<span class="go">     x  2.410179  1.450520</span>
</pre></div>
</div>
<p>This method can also be used to rename specific labels of the main index
of the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [91]: </span><span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;one&quot;</span><span class="p">:</span> <span class="s2">&quot;two&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="s2">&quot;z&quot;</span><span class="p">})</span>
<span class="gh">Out[91]: </span><span class="go"></span>
<span class="go">               0         1</span>
<span class="go">two  z  1.519970 -0.493662</span>
<span class="go">     x  0.600178  0.274230</span>
<span class="go">zero z  0.132885 -0.023688</span>
<span class="go">     x  2.410179  1.450520</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../reference/api/pandas.DataFrame.rename_axis.html#pandas.DataFrame.rename_axis" title="pandas.DataFrame.rename_axis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rename_axis()</span></code></a> method is used to rename the name of a
<code class="docutils literal notranslate"><span class="pre">Index</span></code> or <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>. In particular, the names of the levels of a
<code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> can be specified, which is useful if <code class="docutils literal notranslate"><span class="pre">reset_index()</span></code> is later
used to move the values from the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> to a column.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [92]: </span><span class="n">df</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="s1">&#39;def&#39;</span><span class="p">])</span>
<span class="gh">Out[92]: </span><span class="go"></span>
<span class="go">                 0         1</span>
<span class="go">abc  def                    </span>
<span class="go">one  y    1.519970 -0.493662</span>
<span class="go">     x    0.600178  0.274230</span>
<span class="go">zero y    0.132885 -0.023688</span>
<span class="go">     x    2.410179  1.450520</span>
</pre></div>
</div>
<p>Note that the columns of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> are an index, so that using
<code class="docutils literal notranslate"><span class="pre">rename_axis</span></code> with the <code class="docutils literal notranslate"><span class="pre">columns</span></code> argument will change the name of that
index.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [93]: </span><span class="n">df</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;Cols&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span>
<span class="gh">Out[93]: </span><span class="go">RangeIndex(start=0, stop=2, step=1, name=&#39;Cols&#39;)</span>
</pre></div>
</div>
<p>Both <code class="docutils literal notranslate"><span class="pre">rename</span></code> and <code class="docutils literal notranslate"><span class="pre">rename_axis</span></code> support specifying a dictionary,
<code class="docutils literal notranslate"><span class="pre">Series</span></code> or a mapping function to map labels/names to new values.</p>
</div>
</div>
<div class="section" id="sorting-a-multiindex">
<h2>Sorting a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code><a class="headerlink" href="#sorting-a-multiindex" title="Permalink to this headline">¶</a></h2>
<p>For <code class="xref py py-class docutils literal notranslate"><span class="pre">MultiIndex</span></code>-ed objects to be indexed and sliced effectively,
they need to be sorted. As with any index, you can use <a class="reference internal" href="../reference/api/pandas.DataFrame.sort_index.html#pandas.DataFrame.sort_index" title="pandas.DataFrame.sort_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_index()</span></code></a>.</p>
<pre class="literal-block">In [94]: import random

In [95]: random.shuffle(tuples)

In [96]: s = pd.Series(np.random.randn(8), index=pd.MultiIndex.from_tuples(tuples))

In [97]: s
Out[97]: 
baz  one    0.206053
qux  one   -0.251905
bar  two   -2.213588
foo  one    1.063327
     two    1.266143
baz  two    0.299368
qux  two   -0.863838
bar  one    0.408204
dtype: float64

In [98]: s.sort_index()
Out[98]: 
bar  one    0.408204
     two   -2.213588
baz  one    0.206053
     two    0.299368
foo  one    1.063327
     two    1.266143
qux  one   -0.251905
     two   -0.863838
dtype: float64

In [99]: s.sort_index(level=0)
Out[99]: 
bar  one    0.408204
     two   -2.213588
baz  one    0.206053
     two    0.299368
foo  one    1.063327
     two    1.266143
qux  one   -0.251905
     two   -0.863838
dtype: float64

In [100]: s.sort_index(level=1)
Out[100]: 
bar  one    0.408204
baz  one    0.206053
foo  one    1.063327
qux  one   -0.251905
bar  two   -2.213588
baz  two    0.299368
foo  two    1.266143
qux  two   -0.863838
dtype: float64</pre>
<p id="advanced-sortlevel-byname">You may also pass a level name to <code class="docutils literal notranslate"><span class="pre">sort_index</span></code> if the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> levels
are named.</p>
<pre class="literal-block">In [101]: s.index.set_names(['L1', 'L2'], inplace=True)

In [102]: s.sort_index(level='L1')
Out[102]: 
L1   L2 
bar  one    0.408204
     two   -2.213588
baz  one    0.206053
     two    0.299368
foo  one    1.063327
     two    1.266143
qux  one   -0.251905
     two   -0.863838
dtype: float64

In [103]: s.sort_index(level='L2')
Out[103]: 
L1   L2 
bar  one    0.408204
baz  one    0.206053
foo  one    1.063327
qux  one   -0.251905
bar  two   -2.213588
baz  two    0.299368
foo  two    1.266143
qux  two   -0.863838
dtype: float64</pre>
<p>On higher dimensional objects, you can sort any of the other axes by level if
they have a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [104]: </span><span class="n">df</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gh">Out[104]: </span><span class="go"></span>
<span class="go">        one      zero       one      zero</span>
<span class="go">          x         x         y         y</span>
<span class="go">0  0.600178  2.410179  1.519970  0.132885</span>
<span class="go">1  0.274230  1.450520 -0.493662 -0.023688</span>
</pre></div>
</div>
<p>Indexing will work even if the data are not sorted, but will be rather
inefficient (and show a <code class="docutils literal notranslate"><span class="pre">PerformanceWarning</span></code>). It will also
return a copy of the data rather than a view:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [105]: </span><span class="n">dfm</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;jim&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">   .....: </span>                    <span class="s1">&#39;joe&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">],</span>
<span class="gp">   .....: </span>                    <span class="s1">&#39;jolie&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">)})</span>
<span class="gp">   .....: </span>

<span class="gp">In [106]: </span><span class="n">dfm</span> <span class="o">=</span> <span class="n">dfm</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;jim&#39;</span><span class="p">,</span> <span class="s1">&#39;joe&#39;</span><span class="p">])</span>

<span class="gp">In [107]: </span><span class="n">dfm</span>
<span class="gh">Out[107]: </span><span class="go"></span>
<span class="go">            jolie</span>
<span class="go">jim joe          </span>
<span class="go">0   x    0.490671</span>
<span class="go">    x    0.120248</span>
<span class="go">1   z    0.537020</span>
<span class="go">    y    0.110968</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">dfm</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)]</span>
<span class="go">PerformanceWarning: indexing past lexsort depth may impact performance.</span>

<span class="gh">Out[4]:</span>
<span class="go">           jolie</span>
<span class="go">jim joe</span>
<span class="go">1   z    0.64094</span>
</pre></div>
</div>
<p id="advanced-unsorted">Furthermore, if you try to index something that is not fully lexsorted, this can raise:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [5]: </span><span class="n">dfm</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">):(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)]</span>
<span class="go">UnsortedIndexError: &#39;Key length (2) was greater than MultiIndex lexsort depth (1)&#39;</span>
</pre></div>
</div>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">is_lexsorted()</span></code> method on a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> shows if the
index is sorted, and the <code class="docutils literal notranslate"><span class="pre">lexsort_depth</span></code> property returns the sort depth:</p>
<pre class="literal-block">In [108]: dfm.index.is_lexsorted()
Out[108]: False

In [109]: dfm.index.lexsort_depth
Out[109]: 1</pre>
<pre class="literal-block">In [110]: dfm = dfm.sort_index()

In [111]: dfm
Out[111]: 
            jolie
jim joe          
0   x    0.490671
    x    0.120248
1   y    0.110968
    z    0.537020

In [112]: dfm.index.is_lexsorted()
Out[112]: True

In [113]: dfm.index.lexsort_depth
Out[113]: 2</pre>
<p>And now selection works as expected.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [114]: </span><span class="n">dfm</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">):(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)]</span>
<span class="gh">Out[114]: </span><span class="go"></span>
<span class="go">            jolie</span>
<span class="go">jim joe          </span>
<span class="go">1   y    0.110968</span>
<span class="go">    z    0.537020</span>
</pre></div>
</div>
</div>
<div class="section" id="take-methods">
<h2>Take Methods<a class="headerlink" href="#take-methods" title="Permalink to this headline">¶</a></h2>
<p id="advanced-take">Similar to NumPy ndarrays, pandas <code class="docutils literal notranslate"><span class="pre">Index</span></code>, <code class="docutils literal notranslate"><span class="pre">Series</span></code>, and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> also provides
the <a class="reference internal" href="../reference/api/pandas.DataFrame.take.html#pandas.DataFrame.take" title="pandas.DataFrame.take"><code class="xref py py-meth docutils literal notranslate"><span class="pre">take()</span></code></a> method that retrieves elements along a given axis at the given
indices. The given indices must be either a list or an ndarray of integer
index positions. <code class="docutils literal notranslate"><span class="pre">take</span></code> will also accept negative integers as relative positions to the end of the object.</p>
<pre class="literal-block">In [115]: index = pd.Index(np.random.randint(0, 1000, 10))

In [116]: index
Out[116]: Int64Index([214, 502, 712, 567, 786, 175, 993, 133, 758, 329], dtype='int64')

In [117]: positions = [0, 9, 3]

In [118]: index[positions]
Out[118]: Int64Index([214, 329, 567], dtype='int64')

In [119]: index.take(positions)
Out[119]: Int64Index([214, 329, 567], dtype='int64')

In [120]: ser = pd.Series(np.random.randn(10))

In [121]: ser.iloc[positions]
Out[121]: 
0   -0.179666
9    1.824375
3    0.392149
dtype: float64

In [122]: ser.take(positions)
Out[122]: 
0   -0.179666
9    1.824375
3    0.392149
dtype: float64</pre>
<p>For DataFrames, the given indices should be a 1d list or ndarray that specifies
row or column positions.</p>
<pre class="literal-block">In [123]: frm = pd.DataFrame(np.random.randn(5, 3))

In [124]: frm.take([1, 4, 3])
Out[124]: 
          0         1         2
1 -1.237881  0.106854 -1.276829
4  0.629675 -1.425966  1.857704
3  0.979542 -1.633678  0.615855

In [125]: frm.take([0, 2], axis=1)
Out[125]: 
          0         2
0  0.595974  0.601544
1 -1.237881 -1.276829
2 -0.767101  1.499591
3  0.979542  0.615855
4  0.629675  1.857704</pre>
<p>It is important to note that the <code class="docutils literal notranslate"><span class="pre">take</span></code> method on pandas objects are not
intended to work on boolean indices and may return unexpected results.</p>
<pre class="literal-block">In [126]: arr = np.random.randn(10)

In [127]: arr.take([False, False, True, True])
Out[127]: array([-1.1935, -1.1935,  0.6775,  0.6775])

In [128]: arr[[0, 1]]
Out[128]: array([-1.1935,  0.6775])

In [129]: ser = pd.Series(np.random.randn(10))

In [130]: ser.take([False, False, True, True])
Out[130]: 
0    0.233141
0    0.233141
1   -0.223540
1   -0.223540
dtype: float64

In [131]: ser.iloc[[0, 1]]
Out[131]: 
0    0.233141
1   -0.223540
dtype: float64</pre>
<p>Finally, as a small note on performance, because the <code class="docutils literal notranslate"><span class="pre">take</span></code> method handles
a narrower range of inputs, it can offer performance that is a good deal
faster than fancy indexing.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [132]: </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="gp">In [133]: </span><span class="n">indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>

<span class="gp">In [134]: </span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>

<span class="gp">In [135]: </span><span class="o">%</span><span class="k">timeit</span> arr[indexer]
<span class="gp">   .....: </span><span class="o">%</span><span class="k">timeit</span> arr.take(indexer, axis=0)
<span class="gp">   .....: </span>
<span class="go">164 us +- 3.68 us per loop (mean +- std. dev. of 7 runs, 10000 loops each)</span>
<span class="go">50.4 us +- 774 ns per loop (mean +- std. dev. of 7 runs, 10000 loops each)</span>
</pre></div>
</div>
</div>
<div class="section" id="index-types">
<span id="indexing-index-types"></span><h2>Index Types<a class="headerlink" href="#index-types" title="Permalink to this headline">¶</a></h2>
<p>We have discussed <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> in the previous sections pretty extensively.
Documentation about <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> and <code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code> are shown <a class="reference internal" href="timeseries.html#timeseries-overview"><span class="std std-ref">here</span></a>,
and documentation about <code class="docutils literal notranslate"><span class="pre">TimedeltaIndex</span></code> is found <a class="reference internal" href="timedeltas.html#timedeltas-index"><span class="std std-ref">here</span></a>.</p>
<p>In the following sub-sections we will highlight some other index types.</p>
<div class="section" id="categoricalindex">
<span id="indexing-categoricalindex"></span><h3>CategoricalIndex<a class="headerlink" href="#categoricalindex" title="Permalink to this headline">¶</a></h3>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoricalIndex</span></code> is a type of index that is useful for supporting
indexing with duplicates. This is a container around a <code class="xref py py-class docutils literal notranslate"><span class="pre">Categorical</span></code>
and allows efficient indexing and storage of an index with a large number of duplicated elements.</p>
<pre class="literal-block">In [136]: from pandas.api.types import CategoricalDtype

In [137]: df = pd.DataFrame({'A': np.arange(6),
   .....:                    'B': list('aabbca')})
   .....: 

In [138]: df['B'] = df['B'].astype(CategoricalDtype(list('cab')))

In [139]: df
Out[139]: 
   A  B
0  0  a
1  1  a
2  2  b
3  3  b
4  4  c
5  5  a

In [140]: df.dtypes
Out[140]: 
A       int64
B    category
dtype: object

In [141]: df.B.cat.categories
Out[141]: Index(['c', 'a', 'b'], dtype='object')</pre>
<p>Setting the index will create a <code class="docutils literal notranslate"><span class="pre">CategoricalIndex</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [142]: </span><span class="n">df2</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>

<span class="gp">In [143]: </span><span class="n">df2</span><span class="o">.</span><span class="n">index</span>
<span class="gh">Out[143]: </span><span class="go">CategoricalIndex([&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;], categories=[&#39;c&#39;, &#39;a&#39;, &#39;b&#39;], ordered=False, name=&#39;B&#39;, dtype=&#39;category&#39;)</span>
</pre></div>
</div>
<p>Indexing with <code class="docutils literal notranslate"><span class="pre">__getitem__/.iloc/.loc</span></code> works similarly to an <code class="docutils literal notranslate"><span class="pre">Index</span></code> with duplicates.
The indexers <strong>must</strong> be in the category or the operation will raise a <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [144]: </span><span class="n">df2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="gh">Out[144]: </span><span class="go"></span>
<span class="go">   A</span>
<span class="go">B   </span>
<span class="go">a  0</span>
<span class="go">a  1</span>
<span class="go">a  5</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">CategoricalIndex</span></code> is <strong>preserved</strong> after indexing:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [145]: </span><span class="n">df2</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
<span class="gh">Out[145]: </span><span class="go">CategoricalIndex([&#39;a&#39;, &#39;a&#39;, &#39;a&#39;], categories=[&#39;c&#39;, &#39;a&#39;, &#39;b&#39;], ordered=False, name=&#39;B&#39;, dtype=&#39;category&#39;)</span>
</pre></div>
</div>
<p>Sorting the index will sort by the order of the categories (recall that we
created the index with <code class="docutils literal notranslate"><span class="pre">CategoricalDtype(list('cab'))</span></code>, so the sorted
order is <code class="docutils literal notranslate"><span class="pre">cab</span></code>).</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [146]: </span><span class="n">df2</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
<span class="gh">Out[146]: </span><span class="go"></span>
<span class="go">   A</span>
<span class="go">B   </span>
<span class="go">c  4</span>
<span class="go">a  0</span>
<span class="go">a  1</span>
<span class="go">a  5</span>
<span class="go">b  2</span>
<span class="go">b  3</span>
</pre></div>
</div>
<p>Groupby operations on the index will preserve the index nature as well.</p>
<pre class="literal-block">In [147]: df2.groupby(level=0).sum()
Out[147]: 
   A
B   
c  4
a  6
b  5

In [148]: df2.groupby(level=0).sum().index
Out[148]: CategoricalIndex(['c', 'a', 'b'], categories=['c', 'a', 'b'], ordered=False, name='B', dtype='category')</pre>
<p>Reindexing operations will return a resulting index based on the type of the passed
indexer. Passing a list will return a plain-old <code class="docutils literal notranslate"><span class="pre">Index</span></code>; indexing with
a <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> will return a <code class="docutils literal notranslate"><span class="pre">CategoricalIndex</span></code>, indexed according to the categories
of the <strong>passed</strong> <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> dtype. This allows one to arbitrarily index these even with
values <strong>not</strong> in the categories, similarly to how you can reindex <strong>any</strong> pandas index.</p>
<pre class="literal-block">In [149]: df2.reindex(['a', 'e'])
Out[149]: 
     A
B     
a  0.0
a  1.0
a  5.0
e  NaN

In [150]: df2.reindex(['a', 'e']).index
Out[150]: Index(['a', 'a', 'a', 'e'], dtype='object', name='B')

In [151]: df2.reindex(pd.Categorical(['a', 'e'], categories=list('abcde')))
Out[151]: 
     A
B     
a  0.0
a  1.0
a  5.0
e  NaN

In [152]: df2.reindex(pd.Categorical(['a', 'e'], categories=list('abcde'))).index
Out[152]: CategoricalIndex(['a', 'a', 'a', 'e'], categories=['a', 'b', 'c', 'd', 'e'], ordered=False, name='B', dtype='category')</pre>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Reshaping and Comparison operations on a <code class="docutils literal notranslate"><span class="pre">CategoricalIndex</span></code> must have the same categories
or a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> will be raised.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [9]: </span><span class="n">df3</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;aabbca&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)})</span>

<span class="gp">In [11]: </span><span class="n">df3</span> <span class="o">=</span> <span class="n">df3</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>

<span class="gp">In [11]: </span><span class="n">df3</span><span class="o">.</span><span class="n">index</span>
<span class="gh">Out[11]: </span><span class="go">CategoricalIndex([u&#39;a&#39;, u&#39;a&#39;, u&#39;b&#39;, u&#39;b&#39;, u&#39;c&#39;, u&#39;a&#39;], categories=[u&#39;a&#39;, u&#39;b&#39;, u&#39;c&#39;], ordered=False, name=u&#39;B&#39;, dtype=&#39;category&#39;)</span>

<span class="gp">In [12]: </span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df2</span><span class="p">,</span> <span class="n">df3</span><span class="p">])</span>
<span class="go">TypeError: categories must match existing categories when appending</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="int64index-and-rangeindex">
<span id="indexing-rangeindex"></span><h3>Int64Index and RangeIndex<a class="headerlink" href="#int64index-and-rangeindex" title="Permalink to this headline">¶</a></h3>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Indexing on an integer-based Index with floats has been clarified in 0.18.0, for a summary of the changes, see <a class="reference internal" href="../whatsnew/v0.18.0.html#whatsnew-0180-float-indexers"><span class="std std-ref">here</span></a>.</p>
</div>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Int64Index</span></code> is a fundamental basic index in pandas.
This is an immutable array implementing an ordered, sliceable set.
Prior to 0.18.0, the <code class="docutils literal notranslate"><span class="pre">Int64Index</span></code> would provide the default index for all <code class="docutils literal notranslate"><span class="pre">NDFrame</span></code> objects.</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">RangeIndex</span></code> is a sub-class of <code class="docutils literal notranslate"><span class="pre">Int64Index</span></code> added in version 0.18.0, now providing the default index for all <code class="docutils literal notranslate"><span class="pre">NDFrame</span></code> objects.
<code class="docutils literal notranslate"><span class="pre">RangeIndex</span></code> is an optimized version of <code class="docutils literal notranslate"><span class="pre">Int64Index</span></code> that can represent a monotonic ordered set. These are analogous to Python <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#typesseq-range">range types</a>.</p>
</div>
<div class="section" id="float64index">
<span id="indexing-float64index"></span><h3>Float64Index<a class="headerlink" href="#float64index" title="Permalink to this headline">¶</a></h3>
<p>By default a <code class="xref py py-class docutils literal notranslate"><span class="pre">Float64Index</span></code> will be automatically created when passing floating, or mixed-integer-floating values in index creation.
This enables a pure label-based slicing paradigm that makes <code class="docutils literal notranslate"><span class="pre">[],ix,loc</span></code> for scalar indexing and slicing work exactly the
same.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [153]: </span><span class="n">indexf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

<span class="gp">In [154]: </span><span class="n">indexf</span>
<span class="gh">Out[154]: </span><span class="go">Float64Index([1.5, 2.0, 3.0, 4.5, 5.0], dtype=&#39;float64&#39;)</span>

<span class="gp">In [155]: </span><span class="n">sf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">indexf</span><span class="p">)</span>

<span class="gp">In [156]: </span><span class="n">sf</span>
<span class="gh">Out[156]: </span><span class="go"></span>
<span class="go">1.5    0</span>
<span class="go">2.0    1</span>
<span class="go">3.0    2</span>
<span class="go">4.5    3</span>
<span class="go">5.0    4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Scalar selection for <code class="docutils literal notranslate"><span class="pre">[],.loc</span></code> will always be label based. An integer will match an equal float index (e.g. <code class="docutils literal notranslate"><span class="pre">3</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">3.0</span></code>).</p>
<pre class="literal-block">In [157]: sf[3]
Out[157]: 2

In [158]: sf[3.0]
Out[158]: 2

In [159]: sf.loc[3]
Out[159]: 2

In [160]: sf.loc[3.0]
Out[160]: 2</pre>
<p>The only positional indexing is via <code class="docutils literal notranslate"><span class="pre">iloc</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [161]: </span><span class="n">sf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="gh">Out[161]: </span><span class="go">3</span>
</pre></div>
</div>
<p>A scalar index that is not found will raise a <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>.
Slicing is primarily on the values of the index when using <code class="docutils literal notranslate"><span class="pre">[],ix,loc</span></code>, and
<strong>always</strong> positional when using <code class="docutils literal notranslate"><span class="pre">iloc</span></code>. The exception is when the slice is
boolean, in which case it will always be positional.</p>
<pre class="literal-block">In [162]: sf[2:4]
Out[162]: 
2.0    1
3.0    2
dtype: int64

In [163]: sf.loc[2:4]
Out[163]: 
2.0    1
3.0    2
dtype: int64

In [164]: sf.iloc[2:4]
Out[164]: 
3.0    2
4.5    3
dtype: int64</pre>
<p>In float indexes, slicing using floats is allowed.</p>
<pre class="literal-block">In [165]: sf[2.1:4.6]
Out[165]: 
3.0    2
4.5    3
dtype: int64

In [166]: sf.loc[2.1:4.6]
Out[166]: 
3.0    2
4.5    3
dtype: int64</pre>
<p>In non-float indexes, slicing using floats will raise a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))[</span><span class="mf">3.5</span><span class="p">]</span>
<span class="go">TypeError: the label [3.5] is not a proper indexer for this index type (Int64Index)</span>

<span class="gp">In [1]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))[</span><span class="mf">3.5</span><span class="p">:</span><span class="mf">4.5</span><span class="p">]</span>
<span class="go">TypeError: the slice start [3.5] is not a proper indexer for this index type (Int64Index)</span>
</pre></div>
</div>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>Using a scalar float indexer for <code class="docutils literal notranslate"><span class="pre">.iloc</span></code> has been removed in 0.18.0, so the following will raise a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [3]: </span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mf">3.0</span><span class="p">]</span>
<span class="go">TypeError: cannot do positional indexing on &lt;class &#39;pandas.indexes.range.RangeIndex&#39;&gt; with these indexers [3.0] of &lt;type &#39;float&#39;&gt;</span>
</pre></div>
</div>
</div>
<p>Here is a typical use-case for using this type of indexing. Imagine that you have a somewhat
irregular timedelta-like indexing scheme, but the data is recorded as floats. This could, for
example, be millisecond offsets.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [167]: </span><span class="n">dfir</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">   .....: </span>                               <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mf">250.0</span><span class="p">,</span>
<span class="gp">   .....: </span>                               <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;AB&#39;</span><span class="p">)),</span>
<span class="gp">   .....: </span>                  <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">   .....: </span>                               <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mf">250.1</span><span class="p">,</span>
<span class="gp">   .....: </span>                               <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;AB&#39;</span><span class="p">))])</span>
<span class="gp">   .....: </span>

<span class="gp">In [168]: </span><span class="n">dfir</span>
<span class="gh">Out[168]: </span><span class="go"></span>
<span class="go">               A         B</span>
<span class="go">0.0    -0.435772 -1.188928</span>
<span class="go">250.0  -0.808286 -0.284634</span>
<span class="go">500.0  -1.815703  1.347213</span>
<span class="go">750.0  -0.243487  0.514704</span>
<span class="go">1000.0  1.162969 -0.287725</span>
<span class="go">1000.4 -0.179734  0.993962</span>
<span class="go">1250.5 -0.212673  0.909872</span>
<span class="go">1500.6 -0.733333 -0.349893</span>
<span class="go">1750.7  0.456434 -0.306735</span>
<span class="go">2000.8  0.553396  0.166221</span>
<span class="go">2250.9 -0.101684 -0.734907</span>
</pre></div>
</div>
<p>Selection operations then will always work on a value basis, for all selection operators.</p>
<pre class="literal-block">In [169]: dfir[0:1000.4]
Out[169]: 
               A         B
0.0    -0.435772 -1.188928
250.0  -0.808286 -0.284634
500.0  -1.815703  1.347213
750.0  -0.243487  0.514704
1000.0  1.162969 -0.287725
1000.4 -0.179734  0.993962

In [170]: dfir.loc[0:1001, 'A']
Out[170]: 
0.0      -0.435772
250.0    -0.808286
500.0    -1.815703
750.0    -0.243487
1000.0    1.162969
1000.4   -0.179734
Name: A, dtype: float64

In [171]: dfir.loc[1000.4]
Out[171]: 
A   -0.179734
B    0.993962
Name: 1000.4, dtype: float64</pre>
<p>You could retrieve the first 1 second (1000 ms) of data as such:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [172]: </span><span class="n">dfir</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1000</span><span class="p">]</span>
<span class="gh">Out[172]: </span><span class="go"></span>
<span class="go">               A         B</span>
<span class="go">0.0    -0.435772 -1.188928</span>
<span class="go">250.0  -0.808286 -0.284634</span>
<span class="go">500.0  -1.815703  1.347213</span>
<span class="go">750.0  -0.243487  0.514704</span>
<span class="go">1000.0  1.162969 -0.287725</span>
</pre></div>
</div>
<p>If you need integer based selection, you should use <code class="docutils literal notranslate"><span class="pre">iloc</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [173]: </span><span class="n">dfir</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="gh">Out[173]: </span><span class="go"></span>
<span class="go">               A         B</span>
<span class="go">0.0    -0.435772 -1.188928</span>
<span class="go">250.0  -0.808286 -0.284634</span>
<span class="go">500.0  -1.815703  1.347213</span>
<span class="go">750.0  -0.243487  0.514704</span>
<span class="go">1000.0  1.162969 -0.287725</span>
</pre></div>
</div>
</div>
<div class="section" id="intervalindex">
<span id="advanced-intervalindex"></span><h3>IntervalIndex<a class="headerlink" href="#intervalindex" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.20.0.</span></p>
</div>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">IntervalIndex</span></code> together with its own dtype, <code class="xref py py-class docutils literal notranslate"><span class="pre">IntervalDtype</span></code>
as well as the <code class="xref py py-class docutils literal notranslate"><span class="pre">Interval</span></code> scalar type,  allow first-class support in pandas
for interval notation.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> allows some unique indexing and is also used as a
return type for the categories in <a class="reference internal" href="../reference/api/pandas.cut.html#pandas.cut" title="pandas.cut"><code class="xref py py-func docutils literal notranslate"><span class="pre">cut()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.qcut.html#pandas.qcut" title="pandas.qcut"><code class="xref py py-func docutils literal notranslate"><span class="pre">qcut()</span></code></a>.</p>
<div class="alert alert-warning">
<p class="admonition-title">Warning</p>
<p>These indexing behaviors are provisional and may change in a future version of pandas.</p>
</div>
<p>An <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> can be used in <code class="docutils literal notranslate"><span class="pre">Series</span></code> and in <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> as the index.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [174]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>
<span class="gp">   .....: </span>                  <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">IntervalIndex</span><span class="o">.</span><span class="n">from_breaks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]))</span>
<span class="gp">   .....: </span>

<span class="gp">In [175]: </span><span class="n">df</span>
<span class="gh">Out[175]: </span><span class="go"></span>
<span class="go">        A</span>
<span class="go">(0, 1]  1</span>
<span class="go">(1, 2]  2</span>
<span class="go">(2, 3]  3</span>
<span class="go">(3, 4]  4</span>
</pre></div>
</div>
<p>Label based indexing via <code class="docutils literal notranslate"><span class="pre">.loc</span></code> along the edges of an interval works as you would expect,
selecting that particular interval.</p>
<pre class="literal-block">In [176]: df.loc[2]
Out[176]: 
A    2
Name: (1, 2], dtype: int64

In [177]: df.loc[[2, 3]]
Out[177]: 
        A
(1, 2]  2
(2, 3]  3</pre>
<p>If you select a label <em>contained</em> within an interval, this will also select the interval.</p>
<pre class="literal-block">In [178]: df.loc[2.5]
Out[178]: 
A    3
Name: (2, 3], dtype: int64

In [179]: df.loc[[2.5, 3.5]]
Out[179]: 
        A
(2, 3]  3
(3, 4]  4</pre>
<p><code class="docutils literal notranslate"><span class="pre">Interval</span></code> and <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> are used by <code class="docutils literal notranslate"><span class="pre">cut</span></code> and <code class="docutils literal notranslate"><span class="pre">qcut</span></code>:</p>
<pre class="literal-block">In [180]: c = pd.cut(range(4), bins=2)

In [181]: c
Out[181]: 
[(-0.003, 1.5], (-0.003, 1.5], (1.5, 3.0], (1.5, 3.0]]
Categories (2, interval[float64]): [(-0.003, 1.5] &lt; (1.5, 3.0]]

In [182]: c.categories
Out[182]: 
IntervalIndex([(-0.003, 1.5], (1.5, 3.0]],
              closed='right',
              dtype='interval[float64]')</pre>
<p>Furthermore, <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> allows one to bin <em>other</em> data with these same
bins, with <code class="docutils literal notranslate"><span class="pre">NaN</span></code> representing a missing value similar to other dtypes.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [183]: </span><span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span>
<span class="gh">Out[183]: </span><span class="go"></span>
<span class="go">[(-0.003, 1.5], (1.5, 3.0], NaN, (-0.003, 1.5]]</span>
<span class="go">Categories (2, interval[float64]): [(-0.003, 1.5] &lt; (1.5, 3.0]]</span>
</pre></div>
</div>
<div class="section" id="generating-ranges-of-intervals">
<h4>Generating Ranges of Intervals<a class="headerlink" href="#generating-ranges-of-intervals" title="Permalink to this headline">¶</a></h4>
<p>If we need intervals on a regular frequency, we can use the <a class="reference internal" href="../reference/api/pandas.interval_range.html#pandas.interval_range" title="pandas.interval_range"><code class="xref py py-func docutils literal notranslate"><span class="pre">interval_range()</span></code></a> function
to create an <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> using various combinations of <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>, and <code class="docutils literal notranslate"><span class="pre">periods</span></code>.
The default frequency for <code class="docutils literal notranslate"><span class="pre">interval_range</span></code> is a 1 for numeric intervals, and calendar day for
datetime-like intervals:</p>
<pre class="literal-block">In [184]: pd.interval_range(start=0, end=5)
Out[184]: 
IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],
              closed='right',
              dtype='interval[int64]')

In [185]: pd.interval_range(start=pd.Timestamp('2017-01-01'), periods=4)
Out[185]: 
IntervalIndex([(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03], (2017-01-03, 2017-01-04], (2017-01-04, 2017-01-05]],
              closed='right',
              dtype='interval[datetime64[ns]]')

In [186]: pd.interval_range(end=pd.Timedelta('3 days'), periods=3)
Out[186]: 
IntervalIndex([(0 days 00:00:00, 1 days 00:00:00], (1 days 00:00:00, 2 days 00:00:00], (2 days 00:00:00, 3 days 00:00:00]],
              closed='right',
              dtype='interval[timedelta64[ns]]')</pre>
<p>The <code class="docutils literal notranslate"><span class="pre">freq</span></code> parameter can used to specify non-default frequencies, and can utilize a variety
of <a class="reference internal" href="timeseries.html#timeseries-offset-aliases"><span class="std std-ref">frequency aliases</span></a> with datetime-like intervals:</p>
<pre class="literal-block">In [187]: pd.interval_range(start=0, periods=5, freq=1.5)
Out[187]: 
IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0], (6.0, 7.5]],
              closed='right',
              dtype='interval[float64]')

In [188]: pd.interval_range(start=pd.Timestamp('2017-01-01'), periods=4, freq='W')
Out[188]: 
IntervalIndex([(2017-01-01, 2017-01-08], (2017-01-08, 2017-01-15], (2017-01-15, 2017-01-22], (2017-01-22, 2017-01-29]],
              closed='right',
              dtype='interval[datetime64[ns]]')

In [189]: pd.interval_range(start=pd.Timedelta('0 days'), periods=3, freq='9H')
Out[189]: 
IntervalIndex([(0 days 00:00:00, 0 days 09:00:00], (0 days 09:00:00, 0 days 18:00:00], (0 days 18:00:00, 1 days 03:00:00]],
              closed='right',
              dtype='interval[timedelta64[ns]]')</pre>
<p>Additionally, the <code class="docutils literal notranslate"><span class="pre">closed</span></code> parameter can be used to specify which side(s) the intervals
are closed on.  Intervals are closed on the right side by default.</p>
<pre class="literal-block">In [190]: pd.interval_range(start=0, end=4, closed='both')
Out[190]: 
IntervalIndex([[0, 1], [1, 2], [2, 3], [3, 4]],
              closed='both',
              dtype='interval[int64]')

In [191]: pd.interval_range(start=0, end=4, closed='neither')
Out[191]: 
IntervalIndex([(0, 1), (1, 2), (2, 3), (3, 4)],
              closed='neither',
              dtype='interval[int64]')</pre>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.23.0.</span></p>
</div>
<p>Specifying <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>, and <code class="docutils literal notranslate"><span class="pre">periods</span></code> will generate a range of evenly spaced
intervals from <code class="docutils literal notranslate"><span class="pre">start</span></code> to <code class="docutils literal notranslate"><span class="pre">end</span></code> inclusively, with <code class="docutils literal notranslate"><span class="pre">periods</span></code> number of elements
in the resulting <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code>:</p>
<pre class="literal-block">In [192]: pd.interval_range(start=0, end=6, periods=4)
Out[192]: 
IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]],
              closed='right',
              dtype='interval[float64]')

In [193]: pd.interval_range(pd.Timestamp('2018-01-01'),
   .....:                   pd.Timestamp('2018-02-28'), periods=3)
   .....: 
Out[193]: 
IntervalIndex([(2018-01-01, 2018-01-20 08:00:00], (2018-01-20 08:00:00, 2018-02-08 16:00:00], (2018-02-08 16:00:00, 2018-02-28]],
              closed='right',
              dtype='interval[datetime64[ns]]')</pre>
</div>
</div>
</div>
<div class="section" id="miscellaneous-indexing-faq">
<h2>Miscellaneous indexing FAQ<a class="headerlink" href="#miscellaneous-indexing-faq" title="Permalink to this headline">¶</a></h2>
<div class="section" id="integer-indexing">
<h3>Integer indexing<a class="headerlink" href="#integer-indexing" title="Permalink to this headline">¶</a></h3>
<p>Label-based indexing with integer axis labels is a thorny topic. It has been
discussed heavily on mailing lists and among various members of the scientific
Python community. In pandas, our general viewpoint is that labels matter more
than integer locations. Therefore, with an integer axis index <em>only</em>
label-based indexing is possible with the standard tools like <code class="docutils literal notranslate"><span class="pre">.loc</span></code>. The
following code will generate exceptions:</p>
<pre class="literal-block">In [194]: s = pd.Series(range(5))

In [195]: s[-1]
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
&lt;ipython-input-195-76c3dce40054&gt; in &lt;module&gt;
----&gt; 1 s[-1]

~/miniconda/lib/python3.7/site-packages/pandas/core/series.py in __getitem__(self, key)
   1069         key = com.apply_if_callable(key, self)
   1070         try:
-&gt; 1071             result = self.index.get_value(self, key)
   1072 
   1073             if not is_scalar(result):

~/miniconda/lib/python3.7/site-packages/pandas/core/indexes/base.py in get_value(self, series, key)
   4728         k = self._convert_scalar_indexer(k, kind=&quot;getitem&quot;)
   4729         try:
-&gt; 4730             return self._engine.get_value(s, k, tz=getattr(series.dtype, &quot;tz&quot;, None))
   4731         except KeyError as e1:
   4732             if len(self) &gt; 0 and (self.holds_integer() or self.is_boolean()):

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_value()

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_value()

pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.Int64HashTable.get_item()

pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.Int64HashTable.get_item()

KeyError: -1

In [196]: df = pd.DataFrame(np.random.randn(5, 4))

In [197]: df
Out[197]: 
          0         1         2         3
0 -0.130121 -0.476046  0.759104  0.213379
1 -0.082641  0.448008  0.656420 -1.051443
2  0.594956 -0.151360 -0.069303  1.221431
3 -0.182832  0.791235  0.042745  2.069775
4  1.446552  0.019814 -1.389212 -0.702312

In [198]: df.loc[-2:]
Out[198]: 
          0         1         2         3
0 -0.130121 -0.476046  0.759104  0.213379
1 -0.082641  0.448008  0.656420 -1.051443
2  0.594956 -0.151360 -0.069303  1.221431
3 -0.182832  0.791235  0.042745  2.069775
4  1.446552  0.019814 -1.389212 -0.702312</pre>
<p>This deliberate decision was made to prevent ambiguities and subtle bugs (many
users reported finding bugs when the API change was made to stop “falling back”
on position-based indexing).</p>
</div>
<div class="section" id="non-monotonic-indexes-require-exact-matches">
<h3>Non-monotonic indexes require exact matches<a class="headerlink" href="#non-monotonic-indexes-require-exact-matches" title="Permalink to this headline">¶</a></h3>
<p>If the index of a <code class="docutils literal notranslate"><span class="pre">Series</span></code> or <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> is monotonically increasing or decreasing, then the bounds
of a label-based slice can be outside the range of the index, much like slice indexing a
normal Python <code class="docutils literal notranslate"><span class="pre">list</span></code>. Monotonicity of an index can be tested with the <code class="xref py py-meth docutils literal notranslate"><span class="pre">is_monotonic_increasing()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">is_monotonic_decreasing()</span></code> attributes.</p>
<pre class="literal-block">In [199]: df = pd.DataFrame(index=[2, 3, 3, 4, 5], columns=['data'], data=list(range(5)))

In [200]: df.index.is_monotonic_increasing
Out[200]: True

# no rows 0 or 1, but still returns rows 2, 3 (both of them), and 4:
In [201]: df.loc[0:4, :]
Out[201]: 
   data
2     0
3     1
3     2
4     3

# slice is are outside the index, so empty DataFrame is returned
In [202]: df.loc[13:15, :]
Out[202]: 
Empty DataFrame
Columns: [data]
Index: []</pre>
<p>On the other hand, if the index is not monotonic, then both slice bounds must be
<em>unique</em> members of the index.</p>
<pre class="literal-block">In [203]: df = pd.DataFrame(index=[2, 3, 1, 4, 3, 5],
   .....:                   columns=['data'], data=list(range(6)))
   .....: 

In [204]: df.index.is_monotonic_increasing
Out[204]: False

# OK because 2 and 4 are in the index
In [205]: df.loc[2:4, :]
Out[205]: 
   data
2     0
3     1
1     2
4     3</pre>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># 0 is not in the index</span>
<span class="gp">In [9]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">KeyError: 0</span>

<span class="go"># 3 is not a unique label</span>
<span class="gp">In [11]: </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">KeyError: &#39;Cannot get right slice bound for non-unique label: 3&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Index.is_monotonic_increasing</span></code> and <code class="docutils literal notranslate"><span class="pre">Index.is_monotonic_decreasing</span></code> only check that
an index is weakly monotonic. To check for strict monotonicity, you can combine one of those with
the <code class="xref py py-meth docutils literal notranslate"><span class="pre">is_unique()</span></code> attribute.</p>
<pre class="literal-block">In [206]: weakly_monotonic = pd.Index(['a', 'b', 'c', 'c'])

In [207]: weakly_monotonic
Out[207]: Index(['a', 'b', 'c', 'c'], dtype='object')

In [208]: weakly_monotonic.is_monotonic_increasing
Out[208]: True

In [209]: weakly_monotonic.is_monotonic_increasing &amp; weakly_monotonic.is_unique
Out[209]: False</pre>
</div>
<div class="section" id="endpoints-are-inclusive">
<h3>Endpoints are inclusive<a class="headerlink" href="#endpoints-are-inclusive" title="Permalink to this headline">¶</a></h3>
<p>Compared with standard Python sequence slicing in which the slice endpoint is
not inclusive, label-based slicing in pandas <strong>is inclusive</strong>. The primary
reason for this is that it is often not possible to easily determine the
“successor” or next element after a particular label in an index. For example,
consider the following <code class="docutils literal notranslate"><span class="pre">Series</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [210]: </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;abcdef&#39;</span><span class="p">))</span>

<span class="gp">In [211]: </span><span class="n">s</span>
<span class="gh">Out[211]: </span><span class="go"></span>
<span class="go">a    0.301379</span>
<span class="go">b    1.240445</span>
<span class="go">c   -0.846068</span>
<span class="go">d   -0.043312</span>
<span class="go">e   -1.658747</span>
<span class="go">f   -0.819549</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>Suppose we wished to slice from <code class="docutils literal notranslate"><span class="pre">c</span></code> to <code class="docutils literal notranslate"><span class="pre">e</span></code>, using integers this would be
accomplished as such:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [212]: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="gh">Out[212]: </span><span class="go"></span>
<span class="go">c   -0.846068</span>
<span class="go">d   -0.043312</span>
<span class="go">e   -1.658747</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>However, if you only had <code class="docutils literal notranslate"><span class="pre">c</span></code> and <code class="docutils literal notranslate"><span class="pre">e</span></code>, determining the next element in the
index can be somewhat complicated. For example, the following does not work:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">:</span><span class="s1">&#39;e&#39;</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>A very common use case is to limit a time series to start and end at two
specific dates. To enable this, we made the design to make label-based
slicing include both endpoints:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [213]: </span><span class="n">s</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">:</span><span class="s1">&#39;e&#39;</span><span class="p">]</span>
<span class="gh">Out[213]: </span><span class="go"></span>
<span class="go">c   -0.846068</span>
<span class="go">d   -0.043312</span>
<span class="go">e   -1.658747</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>This is most definitely a “practicality beats purity” sort of thing, but it is
something to watch out for if you expect label-based slicing to behave exactly
in the way that standard Python integer slicing works.</p>
</div>
<div class="section" id="indexing-potentially-changes-underlying-series-dtype">
<h3>Indexing potentially changes underlying Series dtype<a class="headerlink" href="#indexing-potentially-changes-underlying-series-dtype" title="Permalink to this headline">¶</a></h3>
<p>The different indexing operation can potentially change the dtype of a <code class="docutils literal notranslate"><span class="pre">Series</span></code>.</p>
<pre class="literal-block">In [214]: series1 = pd.Series([1, 2, 3])

In [215]: series1.dtype
Out[215]: dtype('int64')

In [216]: res = series1.reindex([0, 4])

In [217]: res.dtype
Out[217]: dtype('float64')

In [218]: res
Out[218]: 
0    1.0
4    NaN
dtype: float64</pre>
<pre class="literal-block">In [219]: series2 = pd.Series([True])

In [220]: series2.dtype
Out[220]: dtype('bool')

In [221]: res = series2.reindex_like(series1)

In [222]: res.dtype
Out[222]: dtype('O')

In [223]: res
Out[223]: 
0    True
1     NaN
2     NaN
dtype: object</pre>
<p>This is because the (re)indexing operations above silently inserts <code class="docutils literal notranslate"><span class="pre">NaNs</span></code> and the <code class="docutils literal notranslate"><span class="pre">dtype</span></code>
changes accordingly.  This can cause some issues when using <code class="docutils literal notranslate"><span class="pre">numpy</span></code> <code class="docutils literal notranslate"><span class="pre">ufuncs</span></code>
such as <code class="docutils literal notranslate"><span class="pre">numpy.logical_and</span></code>.</p>
<p>See the <a class="reference external" href="https://github.com/pydata/pandas/issues/2388">this old issue</a> for a more
detailed discussion.</p>
</div>
</div>
</div>


              </div>
              <div class='prev-next-bottom'>
                
    <a class='left-prev' id="prev-link" href="indexing.html" title="previous page">Indexing and Selecting Data</a>
    <a class='right-next' id="next-link" href="merging.html" title="next page">Merge, join, and concatenate</a>

              </div>
          </main>

      </div>
    </div><script>
    // TOC sidebar - add "active" class to parent list
    //
    // Bootstrap's scrollspy adds the active class to the <a> link,
    // but for the automatic collapsing we need this on the parent list item.
    //
    // The event is triggered on "window" (and not the nav item as documented),
    // see https://github.com/twbs/bootstrap/issues/20086
    $(window).on("activate.bs.scrollspy", function(){
    var navLinks = document.querySelectorAll('#bd-toc-nav a');
    for (var i = 0; i < navLinks.length; i++) {
        var navLink = navLinks[i];
        navLink.parentElement.classList.remove('active');
    }
    var navLinks = document.querySelectorAll('#bd-toc-nav a.active');
    for (var i = 0; i < navLinks.length; i++) {
        var navLink = navLinks[i];
        navLink.parentElement.classList.add('active');
    }
    });

    /**
     * Use left and right arrow keys to navigate forward and backwards.
    */
    const LEFT_ARROW_KEYCODE = 37
    const RIGHT_ARROW_KEYCODE = 39

    const getPrevUrl = () => document.getElementById('prev-link').href
    const getNextUrl = () => document.getElementById('next-link').href
    const initPageNav = (event) => {
        const keycode = event.which

        if (keycode === LEFT_ARROW_KEYCODE) {
            window.location.href = getPrevUrl();
        } else if (keycode === RIGHT_ARROW_KEYCODE) {
            window.location.href = getNextUrl();
        }
    };

    var keyboardListener = false;
    $( document ).ready(() => {
        if (keyboardListener === false) {
            document.addEventListener('keydown', initPageNav)
            keyboardListener = true;
        }
    });
</script>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2008-2014, the pandas development team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.1.
    </div>
  </body>
</html>