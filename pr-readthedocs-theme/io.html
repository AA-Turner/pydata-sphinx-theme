

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>IO Tools (Text, CSV, HDF5, …) &mdash; pandas 0.22.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API Reference" href="api.html" />
    <link rel="prev" title="Essential Basic Functionality" href="basics.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> pandas
          

          
          </a>

          
            
            
              <div class="version">
                0.22.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing to pandas</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Package overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="dsintro.html">Intro to Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="basics.html">Essential Basic Functionality</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">IO Tools (Text, CSV, HDF5, …)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#csv-text-files">CSV &amp; Text files</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#parsing-options">Parsing options</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#basic">Basic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#column-and-index-locations-and-names">Column and Index Locations and Names</a></li>
<li class="toctree-l4"><a class="reference internal" href="#general-parsing-configuration">General Parsing Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#na-and-missing-data-handling">NA and Missing Data Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#datetime-handling">Datetime Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#iteration">Iteration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#quoting-compression-and-file-format">Quoting, Compression, and File Format</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error-handling">Error Handling</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#specifying-column-data-types">Specifying column data types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#specifying-categorical-dtype">Specifying Categorical dtype</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="release.html">Release Notes</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pandas</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>IO Tools (Text, CSV, HDF5, …)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/io.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}
</style>
<div class="section" id="io-tools-text-csv-hdf5">
<span id="io"></span><h1>IO Tools (Text, CSV, HDF5, …)<a class="headerlink" href="#io-tools-text-csv-hdf5" title="Permalink to this headline">¶</a></h1>
<div class="section" id="csv-text-files">
<span id="io-read-csv-table"></span><h2>CSV &amp; Text files<a class="headerlink" href="#csv-text-files" title="Permalink to this headline">¶</a></h2>
<p>The two workhorse functions for reading text files (a.k.a. flat files) are
<code class="xref py py-func docutils literal notranslate"><span class="pre">read_csv()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">read_table()</span></code>. They both use the same parsing code to
intelligently convert tabular data into a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> object. See the
<span class="xref std std-ref">cookbook</span> for some advanced strategies.</p>
<div class="section" id="parsing-options">
<h3>Parsing options<a class="headerlink" href="#parsing-options" title="Permalink to this headline">¶</a></h3>
<p>The functions <code class="xref py py-func docutils literal notranslate"><span class="pre">read_csv()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">read_table()</span></code> accept the following
common arguments:</p>
<div class="section" id="basic">
<h4>Basic<a class="headerlink" href="#basic" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>filepath_or_buffer <span class="classifier-delimiter">:</span> <span class="classifier">various</span></dt>
<dd>Either a path to a file (a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.6)"><code class="docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path" title="(in Python v3.6)"><code class="docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a>,
or <code class="xref py py-class docutils literal notranslate"><span class="pre">py._path.local.LocalPath</span></code>), URL (including http, ftp, and S3
locations), or any object with a <code class="docutils literal notranslate"><span class="pre">read()</span></code> method (such as an open file or
<a class="reference external" href="https://docs.python.org/3/library/io.html#io.StringIO" title="(in Python v3.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">StringIO</span></code></a>).</dd>
<dt>sep <span class="classifier-delimiter">:</span> <span class="classifier">str, defaults to <code class="docutils literal notranslate"><span class="pre">','</span></code> for <code class="xref py py-func docutils literal notranslate"><span class="pre">read_csv()</span></code>, <code class="docutils literal notranslate"><span class="pre">\t</span></code> for <code class="xref py py-func docutils literal notranslate"><span class="pre">read_table()</span></code></span></dt>
<dd>Delimiter to use. If sep is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the C engine cannot automatically detect
the separator, but the Python parsing engine can, meaning the latter will be
used and automatically detect the separator by Python’s builtin sniffer tool,
<a class="reference external" href="https://docs.python.org/3/library/csv.html#csv.Sniffer" title="(in Python v3.6)"><code class="docutils literal notranslate"><span class="pre">csv.Sniffer</span></code></a>. In addition, separators longer than 1 character and
different from <code class="docutils literal notranslate"><span class="pre">'\s+'</span></code> will be interpreted as regular expressions and
will also force the use of the Python parsing engine. Note that regex
delimiters are prone to ignoring quoted data. Regex example: <code class="docutils literal notranslate"><span class="pre">'\\r\\t'</span></code>.</dd>
<dt>delimiter <span class="classifier-delimiter">:</span> <span class="classifier">str, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd>Alternative argument name for sep.</dd>
<dt>delim_whitespace <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default False</span></dt>
<dd><p class="first">Specifies whether or not whitespace (e.g. <code class="docutils literal notranslate"><span class="pre">'</span> <span class="pre">'</span></code> or <code class="docutils literal notranslate"><span class="pre">'\t'</span></code>)
will be used as the delimiter. Equivalent to setting <code class="docutils literal notranslate"><span class="pre">sep='\s+'</span></code>.
If this option is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, nothing should be passed in for the
<code class="docutils literal notranslate"><span class="pre">delimiter</span></code> parameter.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.18.1: </span>support for the Python parser.</p>
</div>
</dd>
</dl>
</div>
<div class="section" id="column-and-index-locations-and-names">
<h4>Column and Index Locations and Names<a class="headerlink" href="#column-and-index-locations-and-names" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>header <span class="classifier-delimiter">:</span> <span class="classifier">int or list of ints, default <code class="docutils literal notranslate"><span class="pre">'infer'</span></code></span></dt>
<dd><p class="first">Row number(s) to use as the column names, and the start of the
data. Default behavior is to infer the column names: if no names are
passed the behavior is identical to <code class="docutils literal notranslate"><span class="pre">header=0</span></code> and column names
are inferred from the first line of the file, if column names are
passed explicitly then the behavior is identical to
<code class="docutils literal notranslate"><span class="pre">header=None</span></code>. Explicitly pass <code class="docutils literal notranslate"><span class="pre">header=0</span></code> to be able to replace
existing names.</p>
<p class="last">The header can be a list of ints that specify row locations
for a multi-index on the columns e.g. <code class="docutils literal notranslate"><span class="pre">[0,1,3]</span></code>. Intervening rows
that are not specified will be skipped (e.g. 2 in this example is
skipped). Note that this parameter ignores commented lines and empty
lines if <code class="docutils literal notranslate"><span class="pre">skip_blank_lines=True</span></code>, so header=0 denotes the first
line of data rather than the first line of the file.</p>
</dd>
<dt>names <span class="classifier-delimiter">:</span> <span class="classifier">array-like, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd>List of column names to use. If file contains no header row, then you should
explicitly pass <code class="docutils literal notranslate"><span class="pre">header=None</span></code>. Duplicates in this list will cause
a <code class="docutils literal notranslate"><span class="pre">UserWarning</span></code> to be issued.</dd>
<dt>index_col <span class="classifier-delimiter">:</span> <span class="classifier">int or sequence or <code class="docutils literal notranslate"><span class="pre">False</span></code>, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd>Column to use as the row labels of the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>. If a sequence is given, a
MultiIndex is used. If you have a malformed file with delimiters at the end of
each line, you might consider <code class="docutils literal notranslate"><span class="pre">index_col=False</span></code> to force pandas to <em>not</em> use
the first column as the index (row names).</dd>
<dt>usecols <span class="classifier-delimiter">:</span> <span class="classifier">list-like or callable, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd><p class="first">Return a subset of the columns. If list-like, all elements must either
be positional (i.e. integer indices into the document columns) or strings
that correspond to column names provided either by the user in <cite>names</cite> or
inferred from the document header row(s). For example, a valid list-like
<cite>usecols</cite> parameter would be <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2]</span></code> or <code class="docutils literal notranslate"><span class="pre">['foo',</span> <span class="pre">'bar',</span> <span class="pre">'baz']</span></code>.</p>
<p>Element order is ignored, so <code class="docutils literal notranslate"><span class="pre">usecols=[0,</span> <span class="pre">1]</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">0]</span></code>. To
instantiate a DataFrame from <code class="docutils literal notranslate"><span class="pre">data</span></code> with element order preserved use
<code class="docutils literal notranslate"><span class="pre">pd.read_csv(data,</span> <span class="pre">usecols=['foo',</span> <span class="pre">'bar'])[['foo',</span> <span class="pre">'bar']]</span></code> for columns
in <code class="docutils literal notranslate"><span class="pre">['foo',</span> <span class="pre">'bar']</span></code> order or
<code class="docutils literal notranslate"><span class="pre">pd.read_csv(data,</span> <span class="pre">usecols=['foo',</span> <span class="pre">'bar'])[['bar',</span> <span class="pre">'foo']]</span></code> for
<code class="docutils literal notranslate"><span class="pre">['bar',</span> <span class="pre">'foo']</span></code> order.</p>
<p>If callable, the callable function will be evaluated against the column names,
returning names where the callable function evaluates to True:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;col1,col2,col3</span><span class="se">\n</span><span class="s1">a,b,1</span><span class="se">\n</span><span class="s1">a,b,2</span><span class="se">\n</span><span class="s1">c,d,3&#39;</span>

<span class="gp">In [2]: </span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="gh">Out[2]: </span><span class="go"></span>
<span class="go">  col1 col2  col3</span>
<span class="go">0    a    b     1</span>
<span class="go">1    a    b     2</span>
<span class="go">2    c    d     3</span>

<span class="gp">In [3]: </span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">usecols</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;COL1&#39;</span><span class="p">,</span> <span class="s1">&#39;COL3&#39;</span><span class="p">])</span>
<span class="go">                                                                                 Out[3]: </span>
<span class="go">  col1  col3</span>
<span class="go">0    a     1</span>
<span class="go">1    a     2</span>
<span class="go">2    c     3</span>
</pre></div>
</div>
<p class="last">Using this parameter results in much faster parsing time and lower memory usage.</p>
</dd>
<dt>squeeze <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt>
<dd>If the parsed data only contains one column then return a <code class="docutils literal notranslate"><span class="pre">Series</span></code>.</dd>
<dt>prefix <span class="classifier-delimiter">:</span> <span class="classifier">str, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd>Prefix to add to column numbers when no header, e.g. ‘X’ for X0, X1, …</dd>
<dt>mangle_dupe_cols <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code class="docutils literal notranslate"><span class="pre">True</span></code></span></dt>
<dd>Duplicate columns will be specified as ‘X’, ‘X.1’…’X.N’, rather than ‘X’…’X’.
Passing in <code class="docutils literal notranslate"><span class="pre">False</span></code> will cause data to be overwritten if there are duplicate
names in the columns.</dd>
</dl>
</div>
<div class="section" id="general-parsing-configuration">
<h4>General Parsing Configuration<a class="headerlink" href="#general-parsing-configuration" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">Type name or dict of column -&gt; type, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd><p class="first">Data type for data or columns. E.g. <code class="docutils literal notranslate"><span class="pre">{'a':</span> <span class="pre">np.float64,</span> <span class="pre">'b':</span> <span class="pre">np.int32}</span></code>
(unsupported with <code class="docutils literal notranslate"><span class="pre">engine='python'</span></code>). Use <cite>str</cite> or <cite>object</cite> to preserve and
not interpret dtype.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.20.0: </span>support for the Python parser.</p>
</div>
</dd>
<dt>engine <span class="classifier-delimiter">:</span> <span class="classifier">{<code class="docutils literal notranslate"><span class="pre">'c'</span></code>, <code class="docutils literal notranslate"><span class="pre">'python'</span></code>}</span></dt>
<dd>Parser engine to use. The C engine is faster while the Python engine is
currently more feature-complete.</dd>
<dt>converters <span class="classifier-delimiter">:</span> <span class="classifier">dict, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd>Dict of functions for converting values in certain columns. Keys can either be
integers or column labels.</dd>
<dt>true_values <span class="classifier-delimiter">:</span> <span class="classifier">list, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd>Values to consider as <code class="docutils literal notranslate"><span class="pre">True</span></code>.</dd>
<dt>false_values <span class="classifier-delimiter">:</span> <span class="classifier">list, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd>Values to consider as <code class="docutils literal notranslate"><span class="pre">False</span></code>.</dd>
<dt>skipinitialspace <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt>
<dd>Skip spaces after delimiter.</dd>
<dt>skiprows <span class="classifier-delimiter">:</span> <span class="classifier">list-like or integer, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd><p class="first">Line numbers to skip (0-indexed) or number of lines to skip (int) at the start
of the file.</p>
<p>If callable, the callable function will be evaluated against the row
indices, returning True if the row should be skipped and False otherwise:</p>
<div class="last highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [4]: </span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;col1,col2,col3</span><span class="se">\n</span><span class="s1">a,b,1</span><span class="se">\n</span><span class="s1">a,b,2</span><span class="se">\n</span><span class="s1">c,d,3&#39;</span>

<span class="gp">In [5]: </span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="gh">Out[5]: </span><span class="go"></span>
<span class="go">  col1 col2  col3</span>
<span class="go">0    a    b     1</span>
<span class="go">1    a    b     2</span>
<span class="go">2    c    d     3</span>

<span class="gp">In [6]: </span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">skiprows</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">                                                                                 Out[6]: </span>
<span class="go">  col1 col2  col3</span>
<span class="go">0    a    b     2</span>
</pre></div>
</div>
</dd>
<dt>skipfooter <span class="classifier-delimiter">:</span> <span class="classifier">int, default <code class="docutils literal notranslate"><span class="pre">0</span></code></span></dt>
<dd>Number of lines at bottom of file to skip (unsupported with engine=’c’).</dd>
<dt>nrows <span class="classifier-delimiter">:</span> <span class="classifier">int, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd>Number of rows of file to read. Useful for reading pieces of large files.</dd>
<dt>low_memory <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code class="docutils literal notranslate"><span class="pre">True</span></code></span></dt>
<dd>Internally process the file in chunks, resulting in lower memory use
while parsing, but possibly mixed type inference.  To ensure no mixed
types either set <code class="docutils literal notranslate"><span class="pre">False</span></code>, or specify the type with the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> parameter.
Note that the entire file is read into a single <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> regardless,
use the <code class="docutils literal notranslate"><span class="pre">chunksize</span></code> or <code class="docutils literal notranslate"><span class="pre">iterator</span></code> parameter to return the data in chunks.
(Only valid with C parser)</dd>
<dt>memory_map <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default False</span></dt>
<dd>If a filepath is provided for <code class="docutils literal notranslate"><span class="pre">filepath_or_buffer</span></code>, map the file object
directly onto memory and access the data directly from there. Using this
option can improve performance because there is no longer any I/O overhead.</dd>
</dl>
</div>
<div class="section" id="na-and-missing-data-handling">
<h4>NA and Missing Data Handling<a class="headerlink" href="#na-and-missing-data-handling" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>na_values <span class="classifier-delimiter">:</span> <span class="classifier">scalar, str, list-like, or dict, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd>Additional strings to recognize as NA/NaN. If dict passed, specific per-column
NA values. See <span class="xref std std-ref">na values const</span> below
for a list of the values interpreted as NaN by default.</dd>
<dt>keep_default_na <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code class="docutils literal notranslate"><span class="pre">True</span></code></span></dt>
<dd><p class="first">Whether or not to include the default NaN values when parsing the data.
Depending on whether <cite>na_values</cite> is passed in, the behavior is as follows:</p>
<ul class="simple">
<li>If <cite>keep_default_na</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <cite>na_values</cite> are specified, <cite>na_values</cite>
is appended to the default NaN values used for parsing.</li>
<li>If <cite>keep_default_na</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <cite>na_values</cite> are not specified, only
the default NaN values are used for parsing.</li>
<li>If <cite>keep_default_na</cite> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, and <cite>na_values</cite> are specified, only
the NaN values specified <cite>na_values</cite> are used for parsing.</li>
<li>If <cite>keep_default_na</cite> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, and <cite>na_values</cite> are not specified, no
strings will be parsed as NaN.</li>
</ul>
<p class="last">Note that if <cite>na_filter</cite> is passed in as <code class="docutils literal notranslate"><span class="pre">False</span></code>, the <cite>keep_default_na</cite> and
<cite>na_values</cite> parameters will be ignored.</p>
</dd>
<dt>na_filter <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code class="docutils literal notranslate"><span class="pre">True</span></code></span></dt>
<dd>Detect missing value markers (empty strings and the value of na_values). In
data without any NAs, passing <code class="docutils literal notranslate"><span class="pre">na_filter=False</span></code> can improve the performance
of reading a large file.</dd>
<dt>verbose <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt>
<dd>Indicate number of NA values placed in non-numeric columns.</dd>
<dt>skip_blank_lines <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code class="docutils literal notranslate"><span class="pre">True</span></code></span></dt>
<dd>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, skip over blank lines rather than interpreting as NaN values.</dd>
</dl>
</div>
<div class="section" id="datetime-handling">
<h4>Datetime Handling<a class="headerlink" href="#datetime-handling" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>parse_dates <span class="classifier-delimiter">:</span> <span class="classifier">boolean or list of ints or names or list of lists or dict, default <code class="docutils literal notranslate"><span class="pre">False</span></code>.</span></dt>
<dd><ul class="first last simple">
<li>If <code class="docutils literal notranslate"><span class="pre">True</span></code> -&gt; try parsing the index.</li>
<li>If <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> -&gt;  try parsing columns 1, 2, 3 each as a separate date
column.</li>
<li>If <code class="docutils literal notranslate"><span class="pre">[[1,</span> <span class="pre">3]]</span></code> -&gt; combine columns 1 and 3 and parse as a single date
column.</li>
<li>If <code class="docutils literal notranslate"><span class="pre">{'foo':</span> <span class="pre">[1,</span> <span class="pre">3]}</span></code> -&gt; parse columns 1, 3 as date and call result ‘foo’.
A fast-path exists for iso8601-formatted dates.</li>
</ul>
</dd>
<dt>infer_datetime_format <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt>
<dd>If <code class="docutils literal notranslate"><span class="pre">True</span></code> and parse_dates is enabled for a column, attempt to infer the
datetime format to speed up the processing.</dd>
<dt>keep_date_col <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt>
<dd>If <code class="docutils literal notranslate"><span class="pre">True</span></code> and parse_dates specifies combining multiple columns then keep the
original columns.</dd>
<dt>date_parser <span class="classifier-delimiter">:</span> <span class="classifier">function, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd>Function to use for converting a sequence of string columns to an array of
datetime instances. The default uses <code class="docutils literal notranslate"><span class="pre">dateutil.parser.parser</span></code> to do the
conversion. Pandas will try to call date_parser in three different ways,
advancing to the next if an exception occurs: 1) Pass one or more arrays (as
defined by parse_dates) as arguments; 2) concatenate (row-wise) the string
values from the columns defined by parse_dates into a single array and pass
that; and 3) call date_parser once for each row using one or more strings
(corresponding to the columns defined by parse_dates) as arguments.</dd>
<dt>dayfirst <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt>
<dd>DD/MM format dates, international and European format.</dd>
</dl>
</div>
<div class="section" id="iteration">
<h4>Iteration<a class="headerlink" href="#iteration" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>iterator <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt>
<dd>Return <cite>TextFileReader</cite> object for iteration or getting chunks with
<code class="docutils literal notranslate"><span class="pre">get_chunk()</span></code>.</dd>
<dt>chunksize <span class="classifier-delimiter">:</span> <span class="classifier">int, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd>Return <cite>TextFileReader</cite> object for iteration. See <span class="xref std std-ref">iterating and chunking</span> below.</dd>
</dl>
</div>
<div class="section" id="quoting-compression-and-file-format">
<h4>Quoting, Compression, and File Format<a class="headerlink" href="#quoting-compression-and-file-format" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>compression <span class="classifier-delimiter">:</span> <span class="classifier">{<code class="docutils literal notranslate"><span class="pre">'infer'</span></code>, <code class="docutils literal notranslate"><span class="pre">'gzip'</span></code>, <code class="docutils literal notranslate"><span class="pre">'bz2'</span></code>, <code class="docutils literal notranslate"><span class="pre">'zip'</span></code>, <code class="docutils literal notranslate"><span class="pre">'xz'</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code>}, default <code class="docutils literal notranslate"><span class="pre">'infer'</span></code></span></dt>
<dd><p class="first">For on-the-fly decompression of on-disk data. If ‘infer’, then use gzip,
bz2, zip, or xz if filepath_or_buffer is a string ending in ‘.gz’, ‘.bz2’,
‘.zip’, or ‘.xz’, respectively, and no decompression otherwise. If using ‘zip’,
the ZIP file must contain only one data file to be read in.
Set to <code class="docutils literal notranslate"><span class="pre">None</span></code> for no decompression.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.18.1: </span>support for ‘zip’ and ‘xz’ compression.</p>
</div>
</dd>
<dt>thousands <span class="classifier-delimiter">:</span> <span class="classifier">str, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd>Thousands separator.</dd>
<dt>decimal <span class="classifier-delimiter">:</span> <span class="classifier">str, default <code class="docutils literal notranslate"><span class="pre">'.'</span></code></span></dt>
<dd>Character to recognize as decimal point. E.g. use <code class="docutils literal notranslate"><span class="pre">','</span></code> for European data.</dd>
<dt>float_precision <span class="classifier-delimiter">:</span> <span class="classifier">string, default None</span></dt>
<dd>Specifies which converter the C engine should use for floating-point values.
The options are <code class="docutils literal notranslate"><span class="pre">None</span></code> for the ordinary converter, <code class="docutils literal notranslate"><span class="pre">high</span></code> for the
high-precision converter, and <code class="docutils literal notranslate"><span class="pre">round_trip</span></code> for the round-trip converter.</dd>
<dt>lineterminator <span class="classifier-delimiter">:</span> <span class="classifier">str (length 1), default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd>Character to break file into lines. Only valid with C parser.</dd>
<dt>quotechar <span class="classifier-delimiter">:</span> <span class="classifier">str (length 1)</span></dt>
<dd>The character used to denote the start and end of a quoted item. Quoted items
can include the delimiter and it will be ignored.</dd>
<dt>quoting <span class="classifier-delimiter">:</span> <span class="classifier">int or <code class="docutils literal notranslate"><span class="pre">csv.QUOTE_*</span></code> instance, default <code class="docutils literal notranslate"><span class="pre">0</span></code></span></dt>
<dd>Control field quoting behavior per <code class="docutils literal notranslate"><span class="pre">csv.QUOTE_*</span></code> constants. Use one of
<code class="docutils literal notranslate"><span class="pre">QUOTE_MINIMAL</span></code> (0), <code class="docutils literal notranslate"><span class="pre">QUOTE_ALL</span></code> (1), <code class="docutils literal notranslate"><span class="pre">QUOTE_NONNUMERIC</span></code> (2) or
<code class="docutils literal notranslate"><span class="pre">QUOTE_NONE</span></code> (3).</dd>
<dt>doublequote <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code class="docutils literal notranslate"><span class="pre">True</span></code></span></dt>
<dd>When <code class="docutils literal notranslate"><span class="pre">quotechar</span></code> is specified and <code class="docutils literal notranslate"><span class="pre">quoting</span></code> is not <code class="docutils literal notranslate"><span class="pre">QUOTE_NONE</span></code>,
indicate whether or not to interpret two consecutive <code class="docutils literal notranslate"><span class="pre">quotechar</span></code> elements
<strong>inside</strong> a field as a single <code class="docutils literal notranslate"><span class="pre">quotechar</span></code> element.</dd>
<dt>escapechar <span class="classifier-delimiter">:</span> <span class="classifier">str (length 1), default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd>One-character string used to escape delimiter when quoting is <code class="docutils literal notranslate"><span class="pre">QUOTE_NONE</span></code>.</dd>
<dt>comment <span class="classifier-delimiter">:</span> <span class="classifier">str, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd>Indicates remainder of line should not be parsed. If found at the beginning of
a line, the line will be ignored altogether. This parameter must be a single
character. Like empty lines (as long as <code class="docutils literal notranslate"><span class="pre">skip_blank_lines=True</span></code>), fully
commented lines are ignored by the parameter <cite>header</cite> but not by <cite>skiprows</cite>.
For example, if <code class="docutils literal notranslate"><span class="pre">comment='#'</span></code>, parsing ‘#empty\na,b,c\n1,2,3’ with
<cite>header=0</cite> will result in ‘a,b,c’ being treated as the header.</dd>
<dt>encoding <span class="classifier-delimiter">:</span> <span class="classifier">str, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd>Encoding to use for UTF when reading/writing (e.g. <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>). <a class="reference external" href="https://docs.python.org/3/library/codecs.html#standard-encodings">List of
Python standard encodings</a>.</dd>
<dt>dialect <span class="classifier-delimiter">:</span> <span class="classifier">str or <a class="reference external" href="https://docs.python.org/3/library/csv.html#csv.Dialect" title="(in Python v3.6)"><code class="docutils literal notranslate"><span class="pre">csv.Dialect</span></code></a> instance, default <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd>If provided, this parameter will override values (default or not) for the
following parameters: <cite>delimiter</cite>, <cite>doublequote</cite>, <cite>escapechar</cite>,
<cite>skipinitialspace</cite>, <cite>quotechar</cite>, and <cite>quoting</cite>. If it is necessary to
override values, a ParserWarning will be issued. See <a class="reference external" href="https://docs.python.org/3/library/csv.html#csv.Dialect" title="(in Python v3.6)"><code class="docutils literal notranslate"><span class="pre">csv.Dialect</span></code></a>
documentation for more details.</dd>
<dt>tupleize_cols <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code class="docutils literal notranslate"><span class="pre">False</span></code></span></dt>
<dd><blockquote class="first">
<div><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 0.21.0.</span></p>
</div>
<p>This argument will be removed and will always convert to MultiIndex</p>
</div></blockquote>
<p class="last">Leave a list of tuples on columns as is (default is to convert to a MultiIndex
on the columns).</p>
</dd>
</dl>
</div>
<div class="section" id="error-handling">
<h4>Error Handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>error_bad_lines <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code class="docutils literal notranslate"><span class="pre">True</span></code></span></dt>
<dd>Lines with too many fields (e.g. a csv line with too many commas) will by
default cause an exception to be raised, and no <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> will be
returned. If <code class="docutils literal notranslate"><span class="pre">False</span></code>, then these “bad lines” will dropped from the
<code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> that is returned. See <span class="xref std std-ref">bad lines</span>
below.</dd>
<dt>warn_bad_lines <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default <code class="docutils literal notranslate"><span class="pre">True</span></code></span></dt>
<dd>If error_bad_lines is <code class="docutils literal notranslate"><span class="pre">False</span></code>, and warn_bad_lines is <code class="docutils literal notranslate"><span class="pre">True</span></code>, a warning for
each “bad line” will be output.</dd>
</dl>
</div>
</div>
<div class="section" id="specifying-column-data-types">
<span id="io-dtypes"></span><h3>Specifying column data types<a class="headerlink" href="#specifying-column-data-types" title="Permalink to this headline">¶</a></h3>
<p>You can indicate the data type for the whole <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> or individual
columns:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [7]: </span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;a,b,c</span><span class="se">\n</span><span class="s1">1,2,3</span><span class="se">\n</span><span class="s1">4,5,6</span><span class="se">\n</span><span class="s1">7,8,9&#39;</span>

<span class="gp">In [8]: </span><span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">a,b,c</span>
<span class="go">1,2,3</span>
<span class="go">4,5,6</span>
<span class="go">7,8,9</span>

<span class="gp">In [9]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

<span class="gp">In [10]: </span><span class="n">df</span>
<span class="gh">Out[10]: </span><span class="go"></span>
<span class="go">   a  b  c</span>
<span class="go">0  1  2  3</span>
<span class="go">1  4  5  6</span>
<span class="go">2  7  8  9</span>

<span class="gp">In [11]: </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="go">                                                      Out[11]: &#39;1&#39;</span>

<span class="gp">In [12]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">})</span>

<span class="gp">In [13]: </span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span>
<span class="gh">Out[13]: </span><span class="go"></span>
<span class="go">a      int64</span>
<span class="go">b     object</span>
<span class="go">c    float64</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Fortunately, pandas offers more than one way to ensure that your column(s)
contain only one <code class="docutils literal notranslate"><span class="pre">dtype</span></code>. If you’re unfamiliar with these concepts, you can
see <a class="reference internal" href="basics.html#basics-dtypes"><span class="std std-ref">here</span></a> to learn more about dtypes, and
<a class="reference internal" href="basics.html#basics-object-conversion"><span class="std std-ref">here</span></a> to learn more about <code class="docutils literal notranslate"><span class="pre">object</span></code> conversion in
pandas.</p>
<p>For instance, you can use the <code class="docutils literal notranslate"><span class="pre">converters</span></code> argument
of <code class="xref py py-func docutils literal notranslate"><span class="pre">read_csv()</span></code>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [14]: </span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;col_1</span><span class="se">\n</span><span class="s2">1</span><span class="se">\n</span><span class="s2">2</span><span class="se">\n</span><span class="s2">&#39;A&#39;</span><span class="se">\n</span><span class="s2">4.22&quot;</span>

<span class="gp">In [15]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">converters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;col_1&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">})</span>

<span class="gp">In [16]: </span><span class="n">df</span>
<span class="gh">Out[16]: </span><span class="go"></span>
<span class="go">  col_1</span>
<span class="go">0     1</span>
<span class="go">1     2</span>
<span class="go">2   &#39;A&#39;</span>
<span class="go">3  4.22</span>

<span class="gp">In [17]: </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;col_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
<span class="go">                                                  Out[17]: </span>
<span class="go">&lt;class &#39;str&#39;&gt;    4</span>
<span class="go">Name: col_1, dtype: int64</span>
</pre></div>
</div>
<p>Or you can use the <code class="xref py py-func docutils literal notranslate"><span class="pre">to_numeric()</span></code> function to coerce the
dtypes after reading in the data,</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [18]: </span><span class="n">df2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

<span class="gp">In [19]: </span><span class="n">df2</span><span class="p">[</span><span class="s1">&#39;col_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">df2</span><span class="p">[</span><span class="s1">&#39;col_1&#39;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;coerce&#39;</span><span class="p">)</span>

<span class="gp">In [20]: </span><span class="n">df2</span>
<span class="gh">Out[20]: </span><span class="go"></span>
<span class="go">   col_1</span>
<span class="go">0   1.00</span>
<span class="go">1   2.00</span>
<span class="go">2    NaN</span>
<span class="go">3   4.22</span>

<span class="gp">In [21]: </span><span class="n">df2</span><span class="p">[</span><span class="s1">&#39;col_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
<span class="go">                                                       Out[21]: </span>
<span class="go">&lt;class &#39;float&#39;&gt;    4</span>
<span class="go">Name: col_1, dtype: int64</span>
</pre></div>
</div>
<p>which will convert all valid parsing to floats, leaving the invalid parsing
as <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p>
<p>Ultimately, how you deal with reading in columns containing mixed dtypes
depends on your specific needs. In the case above, if you wanted to <code class="docutils literal notranslate"><span class="pre">NaN</span></code> out
the data anomalies, then <code class="xref py py-func docutils literal notranslate"><span class="pre">to_numeric()</span></code> is probably your best option.
However, if you wanted for all the data to be coerced, no matter the type, then
using the <code class="docutils literal notranslate"><span class="pre">converters</span></code> argument of <code class="xref py py-func docutils literal notranslate"><span class="pre">read_csv()</span></code> would certainly be
worth trying.</p>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified">New in version 0.20.0: </span>support for the Python parser.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">dtype</span></code> option is supported by the ‘python’ engine.</p>
</div>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In some cases, reading in abnormal data with columns containing mixed dtypes
will result in an inconsistent dataset. If you rely on pandas to infer the
dtypes of your columns, the parsing engine will go and infer the dtypes for
different chunks of the data, rather than the whole dataset at once. Consequently,
you can end up with column(s) with mixed dtypes. For example,</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [22]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;col_1&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">500000</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">500000</span><span class="p">))})</span>

<span class="gp">In [23]: </span><span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;foo.csv&#39;</span><span class="p">)</span>

<span class="gp">In [24]: </span><span class="n">mixed_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;foo.csv&#39;</span><span class="p">)</span>

<span class="gp">In [25]: </span><span class="n">mixed_df</span><span class="p">[</span><span class="s1">&#39;col_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
<span class="gh">Out[25]: </span><span class="go"></span>
<span class="go">&lt;class &#39;int&#39;&gt;    737858</span>
<span class="go">&lt;class &#39;str&#39;&gt;    262144</span>
<span class="go">Name: col_1, dtype: int64</span>

<span class="gp">In [26]: </span><span class="n">mixed_df</span><span class="p">[</span><span class="s1">&#39;col_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">                                                                                    Out[26]: dtype(&#39;O&#39;)</span>
</pre></div>
</div>
<p class="last">will result with <cite>mixed_df</cite> containing an <code class="docutils literal notranslate"><span class="pre">int</span></code> dtype for certain chunks
of the column, and <code class="docutils literal notranslate"><span class="pre">str</span></code> for others due to the mixed dtypes from the
data that was read in. It is important to note that the overall column will be
marked with a <code class="docutils literal notranslate"><span class="pre">dtype</span></code> of <code class="docutils literal notranslate"><span class="pre">object</span></code>, which is used for columns with mixed dtypes.</p>
</div>
</div>
<div class="section" id="specifying-categorical-dtype">
<span id="io-categorical"></span><h3>Specifying Categorical dtype<a class="headerlink" href="#specifying-categorical-dtype" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.19.0.</span></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Categorical</span></code> columns can be parsed directly by specifying <code class="docutils literal notranslate"><span class="pre">dtype='category'</span></code> or
<code class="docutils literal notranslate"><span class="pre">dtype=CategoricalDtype(categories,</span> <span class="pre">ordered)</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [27]: </span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;col1,col2,col3</span><span class="se">\n</span><span class="s1">a,b,1</span><span class="se">\n</span><span class="s1">a,b,2</span><span class="se">\n</span><span class="s1">c,d,3&#39;</span>

<span class="gp">In [28]: </span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="gh">Out[28]: </span><span class="go"></span>
<span class="go">  col1 col2  col3</span>
<span class="go">0    a    b     1</span>
<span class="go">1    a    b     2</span>
<span class="go">2    c    d     3</span>

<span class="gp">In [29]: </span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">dtypes</span>
<span class="go">                                                                                  Out[29]: </span>
<span class="go">col1    object</span>
<span class="go">col2    object</span>
<span class="go">col3     int64</span>
<span class="go">dtype: object</span>

<span class="gp">In [30]: </span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;category&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">dtypes</span>
<span class="go">                                                                                                                                                       Out[30]: </span>
<span class="go">col1    category</span>
<span class="go">col2    category</span>
<span class="go">col3    category</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Individual columns can be parsed as a <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> using a dict
specification:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [31]: </span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;col1&#39;</span><span class="p">:</span> <span class="s1">&#39;category&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">dtypes</span>
<span class="gh">Out[31]: </span><span class="go"></span>
<span class="go">col1    category</span>
<span class="go">col2      object</span>
<span class="go">col3       int64</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.21.0.</span></p>
</div>
<p>Specifying <code class="docutils literal notranslate"><span class="pre">dtype='cateogry'</span></code> will result in an unordered <code class="docutils literal notranslate"><span class="pre">Categorical</span></code>
whose <code class="docutils literal notranslate"><span class="pre">categories</span></code> are the unique values observed in the data. For more
control on the categories and order, create a
<code class="xref py py-class docutils literal notranslate"><span class="pre">CategoricalDtype</span></code> ahead of time, and pass that for
that column’s <code class="docutils literal notranslate"><span class="pre">dtype</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [32]: </span><span class="kn">from</span> <span class="nn">pandas.api.types</span> <span class="kn">import</span> <span class="n">CategoricalDtype</span>

<span class="gp">In [33]: </span><span class="n">dtype</span> <span class="o">=</span> <span class="n">CategoricalDtype</span><span class="p">([</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="n">ordered</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="gp">In [34]: </span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;col1&#39;</span><span class="p">:</span> <span class="n">dtype</span><span class="p">})</span><span class="o">.</span><span class="n">dtypes</span>
<span class="gh">Out[34]: </span><span class="go"></span>
<span class="go">col1    category</span>
<span class="go">col2      object</span>
<span class="go">col3       int64</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>When using <code class="docutils literal notranslate"><span class="pre">dtype=CategoricalDtype</span></code>, “unexpected” values outside of
<code class="docutils literal notranslate"><span class="pre">dtype.categories</span></code> are treated as missing values.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [35]: </span><span class="n">dtype</span> <span class="o">=</span> <span class="n">CategoricalDtype</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">])</span>  <span class="c1"># No &#39;c&#39;</span>

<span class="gp">In [36]: </span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;col1&#39;</span><span class="p">:</span> <span class="n">dtype</span><span class="p">})</span><span class="o">.</span><span class="n">col1</span>
<span class="gh">Out[36]: </span><span class="go"></span>
<span class="go">0      a</span>
<span class="go">1      a</span>
<span class="go">2    NaN</span>
<span class="go">Name: col1, dtype: category</span>
<span class="go">Categories (3, object): [a, b, d]</span>
</pre></div>
</div>
<p>This matches the behavior of <code class="xref py py-meth docutils literal notranslate"><span class="pre">Categorical.set_categories()</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>With <code class="docutils literal notranslate"><span class="pre">dtype='category'</span></code>, the resulting categories will always be parsed
as strings (object dtype). If the categories are numeric they can be
converted using the <code class="xref py py-func docutils literal notranslate"><span class="pre">to_numeric()</span></code> function, or as appropriate, another
converter such as <code class="xref py py-func docutils literal notranslate"><span class="pre">to_datetime()</span></code>.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">dtype</span></code> is a <code class="docutils literal notranslate"><span class="pre">CategoricalDtype</span></code> with homogenous <code class="docutils literal notranslate"><span class="pre">categories</span></code> (
all numeric, all datetimes, etc.), the conversion is done automatically.</p>
<div class="last highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [37]: </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>

<span class="gp">In [38]: </span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span>
<span class="gh">Out[38]: </span><span class="go"></span>
<span class="go">col1    category</span>
<span class="go">col2    category</span>
<span class="go">col3    category</span>
<span class="go">dtype: object</span>

<span class="gp">In [39]: </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;col3&#39;</span><span class="p">]</span>
<span class="go">                                                                           Out[39]: </span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">Name: col3, dtype: category</span>
<span class="go">Categories (3, object): [1, 2, 3]</span>

<span class="gp">In [40]: </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;col3&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;col3&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span>

<span class="gp">In [41]: </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;col3&#39;</span><span class="p">]</span>
<span class="gh">Out[41]: </span><span class="go"></span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">Name: col3, dtype: category</span>
<span class="go">Categories (3, int64): [1, 2, 3]</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="api.html" class="btn btn-neutral float-right" title="API Reference" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="basics.html" class="btn btn-neutral" title="Essential Basic Functionality" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2008-2014, the pandas development team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.22.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>